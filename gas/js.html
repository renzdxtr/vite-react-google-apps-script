<script>
  function K0(g, I) {
    for (var e = 0; e < I.length; e++) {
      const C = I[e];
      if (typeof C != "string" && !Array.isArray(C)) {
        for (const l in C)
          if (l !== "default" && !(l in g)) {
            const t = Object.getOwnPropertyDescriptor(C, l);
            t &&
              Object.defineProperty(
                g,
                l,
                t.get ? t : { enumerable: !0, get: () => C[l] }
              );
          }
      }
    }
    return Object.freeze(
      Object.defineProperty(g, Symbol.toStringTag, { value: "Module" })
    );
  }
  (function () {
    const I = document.createElement("link").relList;
    if (I && I.supports && I.supports("modulepreload")) return;
    for (const l of document.querySelectorAll('link[rel="modulepreload"]'))
      C(l);
    new MutationObserver((l) => {
      for (const t of l)
        if (t.type === "childList")
          for (const n of t.addedNodes)
            n.tagName === "LINK" && n.rel === "modulepreload" && C(n);
    }).observe(document, { childList: !0, subtree: !0 });
    function e(l) {
      const t = {};
      return (
        l.integrity && (t.integrity = l.integrity),
        l.referrerPolicy && (t.referrerPolicy = l.referrerPolicy),
        l.crossOrigin === "use-credentials"
          ? (t.credentials = "include")
          : l.crossOrigin === "anonymous"
          ? (t.credentials = "omit")
          : (t.credentials = "same-origin"),
        t
      );
    }
    function C(l) {
      if (l.ep) return;
      l.ep = !0;
      const t = e(l);
      fetch(l.href, t);
    }
  })();
  function vs(g) {
    return g &&
      g.__esModule &&
      Object.prototype.hasOwnProperty.call(g, "default")
      ? g.default
      : g;
  }
  var ks = { exports: {} },
    xo = {},
    fs = { exports: {} },
    Ig = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var Ut = Symbol.for("react.element"),
    F0 = Symbol.for("react.portal"),
    x0 = Symbol.for("react.fragment"),
    M0 = Symbol.for("react.strict_mode"),
    z0 = Symbol.for("react.profiler"),
    E0 = Symbol.for("react.provider"),
    U0 = Symbol.for("react.context"),
    Q0 = Symbol.for("react.forward_ref"),
    L0 = Symbol.for("react.suspense"),
    D0 = Symbol.for("react.memo"),
    T0 = Symbol.for("react.lazy"),
    ka = Symbol.iterator;
  function j0(g) {
    return g === null || typeof g != "object"
      ? null
      : ((g = (ka && g[ka]) || g["@@iterator"]),
        typeof g == "function" ? g : null);
  }
  var Ys = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    Hs = Object.assign,
    ws = {};
  function Gl(g, I, e) {
    (this.props = g),
      (this.context = I),
      (this.refs = ws),
      (this.updater = e || Ys);
  }
  Gl.prototype.isReactComponent = {};
  Gl.prototype.setState = function (g, I) {
    if (typeof g != "object" && typeof g != "function" && g != null)
      throw Error(
        "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, g, I, "setState");
  };
  Gl.prototype.forceUpdate = function (g) {
    this.updater.enqueueForceUpdate(this, g, "forceUpdate");
  };
  function Ns() {}
  Ns.prototype = Gl.prototype;
  function Qd(g, I, e) {
    (this.props = g),
      (this.context = I),
      (this.refs = ws),
      (this.updater = e || Ys);
  }
  var Ld = (Qd.prototype = new Ns());
  Ld.constructor = Qd;
  Hs(Ld, Gl.prototype);
  Ld.isPureReactComponent = !0;
  var fa = Array.isArray,
    Ks = Object.prototype.hasOwnProperty,
    Dd = { current: null },
    Fs = { key: !0, ref: !0, __self: !0, __source: !0 };
  function xs(g, I, e) {
    var C,
      l = {},
      t = null,
      n = null;
    if (I != null)
      for (C in (I.ref !== void 0 && (n = I.ref),
      I.key !== void 0 && (t = "" + I.key),
      I))
        Ks.call(I, C) && !Fs.hasOwnProperty(C) && (l[C] = I[C]);
    var o = arguments.length - 2;
    if (o === 1) l.children = e;
    else if (1 < o) {
      for (var A = Array(o), c = 0; c < o; c++) A[c] = arguments[c + 2];
      l.children = A;
    }
    if (g && g.defaultProps)
      for (C in ((o = g.defaultProps), o)) l[C] === void 0 && (l[C] = o[C]);
    return {
      $$typeof: Ut,
      type: g,
      key: t,
      ref: n,
      props: l,
      _owner: Dd.current,
    };
  }
  function P0(g, I) {
    return {
      $$typeof: Ut,
      type: g.type,
      key: I,
      ref: g.ref,
      props: g.props,
      _owner: g._owner,
    };
  }
  function Td(g) {
    return typeof g == "object" && g !== null && g.$$typeof === Ut;
  }
  function O0(g) {
    var I = { "=": "=0", ":": "=2" };
    return (
      "$" +
      g.replace(/[=:]/g, function (e) {
        return I[e];
      })
    );
  }
  var Ya = /\/+/g;
  function RA(g, I) {
    return typeof g == "object" && g !== null && g.key != null
      ? O0("" + g.key)
      : I.toString(36);
  }
  function Hn(g, I, e, C, l) {
    var t = typeof g;
    (t === "undefined" || t === "boolean") && (g = null);
    var n = !1;
    if (g === null) n = !0;
    else
      switch (t) {
        case "string":
        case "number":
          n = !0;
          break;
        case "object":
          switch (g.$$typeof) {
            case Ut:
            case F0:
              n = !0;
          }
      }
    if (n)
      return (
        (n = g),
        (l = l(n)),
        (g = C === "" ? "." + RA(n, 0) : C),
        fa(l)
          ? ((e = ""),
            g != null && (e = g.replace(Ya, "$&/") + "/"),
            Hn(l, I, e, "", function (c) {
              return c;
            }))
          : l != null &&
            (Td(l) &&
              (l = P0(
                l,
                e +
                  (!l.key || (n && n.key === l.key)
                    ? ""
                    : ("" + l.key).replace(Ya, "$&/") + "/") +
                  g
              )),
            I.push(l)),
        1
      );
    if (((n = 0), (C = C === "" ? "." : C + ":"), fa(g)))
      for (var o = 0; o < g.length; o++) {
        t = g[o];
        var A = C + RA(t, o);
        n += Hn(t, I, e, A, l);
      }
    else if (((A = j0(g)), typeof A == "function"))
      for (g = A.call(g), o = 0; !(t = g.next()).done; )
        (t = t.value), (A = C + RA(t, o++)), (n += Hn(t, I, e, A, l));
    else if (t === "object")
      throw (
        ((I = String(g)),
        Error(
          "Objects are not valid as a React child (found: " +
            (I === "[object Object]"
              ? "object with keys {" + Object.keys(g).join(", ") + "}"
              : I) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return n;
  }
  function tn(g, I, e) {
    if (g == null) return g;
    var C = [],
      l = 0;
    return (
      Hn(g, C, "", "", function (t) {
        return I.call(e, t, l++);
      }),
      C
    );
  }
  function _0(g) {
    if (g._status === -1) {
      var I = g._result;
      (I = I()),
        I.then(
          function (e) {
            (g._status === 0 || g._status === -1) &&
              ((g._status = 1), (g._result = e));
          },
          function (e) {
            (g._status === 0 || g._status === -1) &&
              ((g._status = 2), (g._result = e));
          }
        ),
        g._status === -1 && ((g._status = 0), (g._result = I));
    }
    if (g._status === 1) return g._result.default;
    throw g._result;
  }
  var _g = { current: null },
    wn = { transition: null },
    q0 = {
      ReactCurrentDispatcher: _g,
      ReactCurrentBatchConfig: wn,
      ReactCurrentOwner: Dd,
    };
  function Ms() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  Ig.Children = {
    map: tn,
    forEach: function (g, I, e) {
      tn(
        g,
        function () {
          I.apply(this, arguments);
        },
        e
      );
    },
    count: function (g) {
      var I = 0;
      return (
        tn(g, function () {
          I++;
        }),
        I
      );
    },
    toArray: function (g) {
      return (
        tn(g, function (I) {
          return I;
        }) || []
      );
    },
    only: function (g) {
      if (!Td(g))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return g;
    },
  };
  Ig.Component = Gl;
  Ig.Fragment = x0;
  Ig.Profiler = z0;
  Ig.PureComponent = Qd;
  Ig.StrictMode = M0;
  Ig.Suspense = L0;
  Ig.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = q0;
  Ig.act = Ms;
  Ig.cloneElement = function (g, I, e) {
    if (g == null)
      throw Error(
        "React.cloneElement(...): The argument must be a React element, but you passed " +
          g +
          "."
      );
    var C = Hs({}, g.props),
      l = g.key,
      t = g.ref,
      n = g._owner;
    if (I != null) {
      if (
        (I.ref !== void 0 && ((t = I.ref), (n = Dd.current)),
        I.key !== void 0 && (l = "" + I.key),
        g.type && g.type.defaultProps)
      )
        var o = g.type.defaultProps;
      for (A in I)
        Ks.call(I, A) &&
          !Fs.hasOwnProperty(A) &&
          (C[A] = I[A] === void 0 && o !== void 0 ? o[A] : I[A]);
    }
    var A = arguments.length - 2;
    if (A === 1) C.children = e;
    else if (1 < A) {
      o = Array(A);
      for (var c = 0; c < A; c++) o[c] = arguments[c + 2];
      C.children = o;
    }
    return { $$typeof: Ut, type: g.type, key: l, ref: t, props: C, _owner: n };
  };
  Ig.createContext = function (g) {
    return (
      (g = {
        $$typeof: U0,
        _currentValue: g,
        _currentValue2: g,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null,
      }),
      (g.Provider = { $$typeof: E0, _context: g }),
      (g.Consumer = g)
    );
  };
  Ig.createElement = xs;
  Ig.createFactory = function (g) {
    var I = xs.bind(null, g);
    return (I.type = g), I;
  };
  Ig.createRef = function () {
    return { current: null };
  };
  Ig.forwardRef = function (g) {
    return { $$typeof: Q0, render: g };
  };
  Ig.isValidElement = Td;
  Ig.lazy = function (g) {
    return { $$typeof: T0, _payload: { _status: -1, _result: g }, _init: _0 };
  };
  Ig.memo = function (g, I) {
    return { $$typeof: D0, type: g, compare: I === void 0 ? null : I };
  };
  Ig.startTransition = function (g) {
    var I = wn.transition;
    wn.transition = {};
    try {
      g();
    } finally {
      wn.transition = I;
    }
  };
  Ig.unstable_act = Ms;
  Ig.useCallback = function (g, I) {
    return _g.current.useCallback(g, I);
  };
  Ig.useContext = function (g) {
    return _g.current.useContext(g);
  };
  Ig.useDebugValue = function () {};
  Ig.useDeferredValue = function (g) {
    return _g.current.useDeferredValue(g);
  };
  Ig.useEffect = function (g, I) {
    return _g.current.useEffect(g, I);
  };
  Ig.useId = function () {
    return _g.current.useId();
  };
  Ig.useImperativeHandle = function (g, I, e) {
    return _g.current.useImperativeHandle(g, I, e);
  };
  Ig.useInsertionEffect = function (g, I) {
    return _g.current.useInsertionEffect(g, I);
  };
  Ig.useLayoutEffect = function (g, I) {
    return _g.current.useLayoutEffect(g, I);
  };
  Ig.useMemo = function (g, I) {
    return _g.current.useMemo(g, I);
  };
  Ig.useReducer = function (g, I, e) {
    return _g.current.useReducer(g, I, e);
  };
  Ig.useRef = function (g) {
    return _g.current.useRef(g);
  };
  Ig.useState = function (g) {
    return _g.current.useState(g);
  };
  Ig.useSyncExternalStore = function (g, I, e) {
    return _g.current.useSyncExternalStore(g, I, e);
  };
  Ig.useTransition = function () {
    return _g.current.useTransition();
  };
  Ig.version = "18.3.1";
  fs.exports = Ig;
  var a = fs.exports;
  const ee = vs(a),
    zs = K0({ __proto__: null, default: ee }, [a]);
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var $0 = a,
    gB = Symbol.for("react.element"),
    IB = Symbol.for("react.fragment"),
    eB = Object.prototype.hasOwnProperty,
    CB =
      $0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    lB = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Es(g, I, e) {
    var C,
      l = {},
      t = null,
      n = null;
    e !== void 0 && (t = "" + e),
      I.key !== void 0 && (t = "" + I.key),
      I.ref !== void 0 && (n = I.ref);
    for (C in I) eB.call(I, C) && !lB.hasOwnProperty(C) && (l[C] = I[C]);
    if (g && g.defaultProps)
      for (C in ((I = g.defaultProps), I)) l[C] === void 0 && (l[C] = I[C]);
    return {
      $$typeof: gB,
      type: g,
      key: t,
      ref: n,
      props: l,
      _owner: CB.current,
    };
  }
  xo.Fragment = IB;
  xo.jsx = Es;
  xo.jsxs = Es;
  ks.exports = xo;
  var s = ks.exports,
    Us = { exports: {} },
    ZI = {},
    Qs = { exports: {} },
    Ls = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ (function (g) {
    function I(R, X) {
      var H = R.length;
      R.push(X);
      g: for (; 0 < H; ) {
        var U = (H - 1) >>> 1,
          Cg = R[U];
        if (0 < l(Cg, X)) (R[U] = X), (R[H] = Cg), (H = U);
        else break g;
      }
    }
    function e(R) {
      return R.length === 0 ? null : R[0];
    }
    function C(R) {
      if (R.length === 0) return null;
      var X = R[0],
        H = R.pop();
      if (H !== X) {
        R[0] = H;
        g: for (var U = 0, Cg = R.length, $g = Cg >>> 1; U < $g; ) {
          var Rg = 2 * (U + 1) - 1,
            nI = R[Rg],
            Vg = Rg + 1,
            M = R[Vg];
          if (0 > l(nI, H))
            Vg < Cg && 0 > l(M, nI)
              ? ((R[U] = M), (R[Vg] = H), (U = Vg))
              : ((R[U] = nI), (R[Rg] = H), (U = Rg));
          else if (Vg < Cg && 0 > l(M, H)) (R[U] = M), (R[Vg] = H), (U = Vg);
          else break g;
        }
      }
      return X;
    }
    function l(R, X) {
      var H = R.sortIndex - X.sortIndex;
      return H !== 0 ? H : R.id - X.id;
    }
    if (
      typeof performance == "object" &&
      typeof performance.now == "function"
    ) {
      var t = performance;
      g.unstable_now = function () {
        return t.now();
      };
    } else {
      var n = Date,
        o = n.now();
      g.unstable_now = function () {
        return n.now() - o;
      };
    }
    var A = [],
      c = [],
      d = 1,
      i = null,
      r = 3,
      u = !1,
      b = !1,
      m = !1,
      p = typeof setTimeout == "function" ? setTimeout : null,
      G = typeof clearTimeout == "function" ? clearTimeout : null,
      Z = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" &&
      navigator.scheduling !== void 0 &&
      navigator.scheduling.isInputPending !== void 0 &&
      navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function B(R) {
      for (var X = e(c); X !== null; ) {
        if (X.callback === null) C(c);
        else if (X.startTime <= R)
          C(c), (X.sortIndex = X.expirationTime), I(A, X);
        else break;
        X = e(c);
      }
    }
    function y(R) {
      if (((m = !1), B(R), !b))
        if (e(A) !== null) (b = !0), z(h);
        else {
          var X = e(c);
          X !== null && gg(y, X.startTime - R);
        }
    }
    function h(R, X) {
      (b = !1), m && ((m = !1), G(V), (V = -1)), (u = !0);
      var H = r;
      try {
        for (
          B(X), i = e(A);
          i !== null && (!(i.expirationTime > X) || (R && !F()));

        ) {
          var U = i.callback;
          if (typeof U == "function") {
            (i.callback = null), (r = i.priorityLevel);
            var Cg = U(i.expirationTime <= X);
            (X = g.unstable_now()),
              typeof Cg == "function" ? (i.callback = Cg) : i === e(A) && C(A),
              B(X);
          } else C(A);
          i = e(A);
        }
        if (i !== null) var $g = !0;
        else {
          var Rg = e(c);
          Rg !== null && gg(y, Rg.startTime - X), ($g = !1);
        }
        return $g;
      } finally {
        (i = null), (r = H), (u = !1);
      }
    }
    var W = !1,
      S = null,
      V = -1,
      f = 5,
      k = -1;
    function F() {
      return !(g.unstable_now() - k < f);
    }
    function K() {
      if (S !== null) {
        var R = g.unstable_now();
        k = R;
        var X = !0;
        try {
          X = S(!0, R);
        } finally {
          X ? P() : ((W = !1), (S = null));
        }
      } else W = !1;
    }
    var P;
    if (typeof Z == "function")
      P = function () {
        Z(K);
      };
    else if (typeof MessageChannel < "u") {
      var T = new MessageChannel(),
        ng = T.port2;
      (T.port1.onmessage = K),
        (P = function () {
          ng.postMessage(null);
        });
    } else
      P = function () {
        p(K, 0);
      };
    function z(R) {
      (S = R), W || ((W = !0), P());
    }
    function gg(R, X) {
      V = p(function () {
        R(g.unstable_now());
      }, X);
    }
    (g.unstable_IdlePriority = 5),
      (g.unstable_ImmediatePriority = 1),
      (g.unstable_LowPriority = 4),
      (g.unstable_NormalPriority = 3),
      (g.unstable_Profiling = null),
      (g.unstable_UserBlockingPriority = 2),
      (g.unstable_cancelCallback = function (R) {
        R.callback = null;
      }),
      (g.unstable_continueExecution = function () {
        b || u || ((b = !0), z(h));
      }),
      (g.unstable_forceFrameRate = function (R) {
        0 > R || 125 < R
          ? console.error(
              "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
            )
          : (f = 0 < R ? Math.floor(1e3 / R) : 5);
      }),
      (g.unstable_getCurrentPriorityLevel = function () {
        return r;
      }),
      (g.unstable_getFirstCallbackNode = function () {
        return e(A);
      }),
      (g.unstable_next = function (R) {
        switch (r) {
          case 1:
          case 2:
          case 3:
            var X = 3;
            break;
          default:
            X = r;
        }
        var H = r;
        r = X;
        try {
          return R();
        } finally {
          r = H;
        }
      }),
      (g.unstable_pauseExecution = function () {}),
      (g.unstable_requestPaint = function () {}),
      (g.unstable_runWithPriority = function (R, X) {
        switch (R) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            R = 3;
        }
        var H = r;
        r = R;
        try {
          return X();
        } finally {
          r = H;
        }
      }),
      (g.unstable_scheduleCallback = function (R, X, H) {
        var U = g.unstable_now();
        switch (
          (typeof H == "object" && H !== null
            ? ((H = H.delay), (H = typeof H == "number" && 0 < H ? U + H : U))
            : (H = U),
          R)
        ) {
          case 1:
            var Cg = -1;
            break;
          case 2:
            Cg = 250;
            break;
          case 5:
            Cg = 1073741823;
            break;
          case 4:
            Cg = 1e4;
            break;
          default:
            Cg = 5e3;
        }
        return (
          (Cg = H + Cg),
          (R = {
            id: d++,
            callback: X,
            priorityLevel: R,
            startTime: H,
            expirationTime: Cg,
            sortIndex: -1,
          }),
          H > U
            ? ((R.sortIndex = H),
              I(c, R),
              e(A) === null &&
                R === e(c) &&
                (m ? (G(V), (V = -1)) : (m = !0), gg(y, H - U)))
            : ((R.sortIndex = Cg), I(A, R), b || u || ((b = !0), z(h))),
          R
        );
      }),
      (g.unstable_shouldYield = F),
      (g.unstable_wrapCallback = function (R) {
        var X = r;
        return function () {
          var H = r;
          r = X;
          try {
            return R.apply(this, arguments);
          } finally {
            r = H;
          }
        };
      });
  })(Ls);
  Qs.exports = Ls;
  var tB = Qs.exports;
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var nB = a,
    uI = tB;
  function J(g) {
    for (
      var I = "https://reactjs.org/docs/error-decoder.html?invariant=" + g,
        e = 1;
      e < arguments.length;
      e++
    )
      I += "&args[]=" + encodeURIComponent(arguments[e]);
    return (
      "Minified React error #" +
      g +
      "; visit " +
      I +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var Ds = new Set(),
    tt = {};
  function hC(g, I) {
    nl(g, I), nl(g + "Capture", I);
  }
  function nl(g, I) {
    for (tt[g] = I, g = 0; g < I.length; g++) Ds.add(I[g]);
  }
  var ce = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    bc = Object.prototype.hasOwnProperty,
    oB =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Ha = {},
    wa = {};
  function AB(g) {
    return bc.call(wa, g)
      ? !0
      : bc.call(Ha, g)
      ? !1
      : oB.test(g)
      ? (wa[g] = !0)
      : ((Ha[g] = !0), !1);
  }
  function cB(g, I, e, C) {
    if (e !== null && e.type === 0) return !1;
    switch (typeof I) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return C
          ? !1
          : e !== null
          ? !e.acceptsBooleans
          : ((g = g.toLowerCase().slice(0, 5)), g !== "data-" && g !== "aria-");
      default:
        return !1;
    }
  }
  function dB(g, I, e, C) {
    if (I === null || typeof I > "u" || cB(g, I, e, C)) return !0;
    if (C) return !1;
    if (e !== null)
      switch (e.type) {
        case 3:
          return !I;
        case 4:
          return I === !1;
        case 5:
          return isNaN(I);
        case 6:
          return isNaN(I) || 1 > I;
      }
    return !1;
  }
  function qg(g, I, e, C, l, t, n) {
    (this.acceptsBooleans = I === 2 || I === 3 || I === 4),
      (this.attributeName = C),
      (this.attributeNamespace = l),
      (this.mustUseProperty = e),
      (this.propertyName = g),
      (this.type = I),
      (this.sanitizeURL = t),
      (this.removeEmptyString = n);
  }
  var Fg = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (g) {
      Fg[g] = new qg(g, 0, !1, g, null, !1, !1);
    });
  [
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
  ].forEach(function (g) {
    var I = g[0];
    Fg[I] = new qg(I, 1, !1, g[1], null, !1, !1);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (g) {
    Fg[g] = new qg(g, 2, !1, g.toLowerCase(), null, !1, !1);
  });
  [
    "autoReverse",
    "externalResourcesRequired",
    "focusable",
    "preserveAlpha",
  ].forEach(function (g) {
    Fg[g] = new qg(g, 2, !1, g, null, !1, !1);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
    .split(" ")
    .forEach(function (g) {
      Fg[g] = new qg(g, 3, !1, g.toLowerCase(), null, !1, !1);
    });
  ["checked", "multiple", "muted", "selected"].forEach(function (g) {
    Fg[g] = new qg(g, 3, !0, g, null, !1, !1);
  });
  ["capture", "download"].forEach(function (g) {
    Fg[g] = new qg(g, 4, !1, g, null, !1, !1);
  });
  ["cols", "rows", "size", "span"].forEach(function (g) {
    Fg[g] = new qg(g, 6, !1, g, null, !1, !1);
  });
  ["rowSpan", "start"].forEach(function (g) {
    Fg[g] = new qg(g, 5, !1, g.toLowerCase(), null, !1, !1);
  });
  var jd = /[\-:]([a-z])/g;
  function Pd(g) {
    return g[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (g) {
      var I = g.replace(jd, Pd);
      Fg[I] = new qg(I, 1, !1, g, null, !1, !1);
    });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
    .split(" ")
    .forEach(function (g) {
      var I = g.replace(jd, Pd);
      Fg[I] = new qg(I, 1, !1, g, "http://www.w3.org/1999/xlink", !1, !1);
    });
  ["xml:base", "xml:lang", "xml:space"].forEach(function (g) {
    var I = g.replace(jd, Pd);
    Fg[I] = new qg(I, 1, !1, g, "http://www.w3.org/XML/1998/namespace", !1, !1);
  });
  ["tabIndex", "crossOrigin"].forEach(function (g) {
    Fg[g] = new qg(g, 1, !1, g.toLowerCase(), null, !1, !1);
  });
  Fg.xlinkHref = new qg(
    "xlinkHref",
    1,
    !1,
    "xlink:href",
    "http://www.w3.org/1999/xlink",
    !0,
    !1
  );
  ["src", "href", "action", "formAction"].forEach(function (g) {
    Fg[g] = new qg(g, 1, !1, g.toLowerCase(), null, !0, !0);
  });
  function Od(g, I, e, C) {
    var l = Fg.hasOwnProperty(I) ? Fg[I] : null;
    (l !== null
      ? l.type !== 0
      : C ||
        !(2 < I.length) ||
        (I[0] !== "o" && I[0] !== "O") ||
        (I[1] !== "n" && I[1] !== "N")) &&
      (dB(I, e, l, C) && (e = null),
      C || l === null
        ? AB(I) &&
          (e === null ? g.removeAttribute(I) : g.setAttribute(I, "" + e))
        : l.mustUseProperty
        ? (g[l.propertyName] = e === null ? (l.type === 3 ? !1 : "") : e)
        : ((I = l.attributeName),
          (C = l.attributeNamespace),
          e === null
            ? g.removeAttribute(I)
            : ((l = l.type),
              (e = l === 3 || (l === 4 && e === !0) ? "" : "" + e),
              C ? g.setAttributeNS(C, I, e) : g.setAttribute(I, e))));
  }
  var me = nB.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    nn = Symbol.for("react.element"),
    NC = Symbol.for("react.portal"),
    KC = Symbol.for("react.fragment"),
    _d = Symbol.for("react.strict_mode"),
    Bc = Symbol.for("react.profiler"),
    Ts = Symbol.for("react.provider"),
    js = Symbol.for("react.context"),
    qd = Symbol.for("react.forward_ref"),
    pc = Symbol.for("react.suspense"),
    yc = Symbol.for("react.suspense_list"),
    $d = Symbol.for("react.memo"),
    pe = Symbol.for("react.lazy"),
    Ps = Symbol.for("react.offscreen"),
    Na = Symbol.iterator;
  function vl(g) {
    return g === null || typeof g != "object"
      ? null
      : ((g = (Na && g[Na]) || g["@@iterator"]),
        typeof g == "function" ? g : null);
  }
  var hg = Object.assign,
    XA;
  function zl(g) {
    if (XA === void 0)
      try {
        throw Error();
      } catch (e) {
        var I = e.stack.trim().match(/\n( *(at )?)/);
        XA = (I && I[1]) || "";
      }
    return (
      `
` +
      XA +
      g
    );
  }
  var JA = !1;
  function vA(g, I) {
    if (!g || JA) return "";
    JA = !0;
    var e = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (I)
        if (
          ((I = function () {
            throw Error();
          }),
          Object.defineProperty(I.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(I, []);
          } catch (c) {
            var C = c;
          }
          Reflect.construct(g, [], I);
        } else {
          try {
            I.call();
          } catch (c) {
            C = c;
          }
          g.call(I.prototype);
        }
      else {
        try {
          throw Error();
        } catch (c) {
          C = c;
        }
        g();
      }
    } catch (c) {
      if (c && C && typeof c.stack == "string") {
        for (
          var l = c.stack.split(`
`),
            t = C.stack.split(`
`),
            n = l.length - 1,
            o = t.length - 1;
          1 <= n && 0 <= o && l[n] !== t[o];

        )
          o--;
        for (; 1 <= n && 0 <= o; n--, o--)
          if (l[n] !== t[o]) {
            if (n !== 1 || o !== 1)
              do
                if ((n--, o--, 0 > o || l[n] !== t[o])) {
                  var A =
                    `
` + l[n].replace(" at new ", " at ");
                  return (
                    g.displayName &&
                      A.includes("<anonymous>") &&
                      (A = A.replace("<anonymous>", g.displayName)),
                    A
                  );
                }
              while (1 <= n && 0 <= o);
            break;
          }
      }
    } finally {
      (JA = !1), (Error.prepareStackTrace = e);
    }
    return (g = g ? g.displayName || g.name : "") ? zl(g) : "";
  }
  function iB(g) {
    switch (g.tag) {
      case 5:
        return zl(g.type);
      case 16:
        return zl("Lazy");
      case 13:
        return zl("Suspense");
      case 19:
        return zl("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (g = vA(g.type, !1)), g;
      case 11:
        return (g = vA(g.type.render, !1)), g;
      case 1:
        return (g = vA(g.type, !0)), g;
      default:
        return "";
    }
  }
  function hc(g) {
    if (g == null) return null;
    if (typeof g == "function") return g.displayName || g.name || null;
    if (typeof g == "string") return g;
    switch (g) {
      case KC:
        return "Fragment";
      case NC:
        return "Portal";
      case Bc:
        return "Profiler";
      case _d:
        return "StrictMode";
      case pc:
        return "Suspense";
      case yc:
        return "SuspenseList";
    }
    if (typeof g == "object")
      switch (g.$$typeof) {
        case js:
          return (g.displayName || "Context") + ".Consumer";
        case Ts:
          return (g._context.displayName || "Context") + ".Provider";
        case qd:
          var I = g.render;
          return (
            (g = g.displayName),
            g ||
              ((g = I.displayName || I.name || ""),
              (g = g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef")),
            g
          );
        case $d:
          return (
            (I = g.displayName || null), I !== null ? I : hc(g.type) || "Memo"
          );
        case pe:
          (I = g._payload), (g = g._init);
          try {
            return hc(g(I));
          } catch {}
      }
    return null;
  }
  function aB(g) {
    var I = g.type;
    switch (g.tag) {
      case 24:
        return "Cache";
      case 9:
        return (I.displayName || "Context") + ".Consumer";
      case 10:
        return (I._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (g = I.render),
          (g = g.displayName || g.name || ""),
          I.displayName || (g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return I;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return hc(I);
      case 8:
        return I === _d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof I == "function") return I.displayName || I.name || null;
        if (typeof I == "string") return I;
    }
    return null;
  }
  function Me(g) {
    switch (typeof g) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return g;
      case "object":
        return g;
      default:
        return "";
    }
  }
  function Os(g) {
    var I = g.type;
    return (
      (g = g.nodeName) &&
      g.toLowerCase() === "input" &&
      (I === "checkbox" || I === "radio")
    );
  }
  function rB(g) {
    var I = Os(g) ? "checked" : "value",
      e = Object.getOwnPropertyDescriptor(g.constructor.prototype, I),
      C = "" + g[I];
    if (
      !g.hasOwnProperty(I) &&
      typeof e < "u" &&
      typeof e.get == "function" &&
      typeof e.set == "function"
    ) {
      var l = e.get,
        t = e.set;
      return (
        Object.defineProperty(g, I, {
          configurable: !0,
          get: function () {
            return l.call(this);
          },
          set: function (n) {
            (C = "" + n), t.call(this, n);
          },
        }),
        Object.defineProperty(g, I, { enumerable: e.enumerable }),
        {
          getValue: function () {
            return C;
          },
          setValue: function (n) {
            C = "" + n;
          },
          stopTracking: function () {
            (g._valueTracker = null), delete g[I];
          },
        }
      );
    }
  }
  function on(g) {
    g._valueTracker || (g._valueTracker = rB(g));
  }
  function _s(g) {
    if (!g) return !1;
    var I = g._valueTracker;
    if (!I) return !0;
    var e = I.getValue(),
      C = "";
    return (
      g && (C = Os(g) ? (g.checked ? "true" : "false") : g.value),
      (g = C),
      g !== e ? (I.setValue(g), !0) : !1
    );
  }
  function On(g) {
    if (
      ((g = g || (typeof document < "u" ? document : void 0)), typeof g > "u")
    )
      return null;
    try {
      return g.activeElement || g.body;
    } catch {
      return g.body;
    }
  }
  function Sc(g, I) {
    var e = I.checked;
    return hg({}, I, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: e ?? g._wrapperState.initialChecked,
    });
  }
  function Ka(g, I) {
    var e = I.defaultValue == null ? "" : I.defaultValue,
      C = I.checked != null ? I.checked : I.defaultChecked;
    (e = Me(I.value != null ? I.value : e)),
      (g._wrapperState = {
        initialChecked: C,
        initialValue: e,
        controlled:
          I.type === "checkbox" || I.type === "radio"
            ? I.checked != null
            : I.value != null,
      });
  }
  function qs(g, I) {
    (I = I.checked), I != null && Od(g, "checked", I, !1);
  }
  function Vc(g, I) {
    qs(g, I);
    var e = Me(I.value),
      C = I.type;
    if (e != null)
      C === "number"
        ? ((e === 0 && g.value === "") || g.value != e) && (g.value = "" + e)
        : g.value !== "" + e && (g.value = "" + e);
    else if (C === "submit" || C === "reset") {
      g.removeAttribute("value");
      return;
    }
    I.hasOwnProperty("value")
      ? Wc(g, I.type, e)
      : I.hasOwnProperty("defaultValue") && Wc(g, I.type, Me(I.defaultValue)),
      I.checked == null &&
        I.defaultChecked != null &&
        (g.defaultChecked = !!I.defaultChecked);
  }
  function Fa(g, I, e) {
    if (I.hasOwnProperty("value") || I.hasOwnProperty("defaultValue")) {
      var C = I.type;
      if (
        !(
          (C !== "submit" && C !== "reset") ||
          (I.value !== void 0 && I.value !== null)
        )
      )
        return;
      (I = "" + g._wrapperState.initialValue),
        e || I === g.value || (g.value = I),
        (g.defaultValue = I);
    }
    (e = g.name),
      e !== "" && (g.name = ""),
      (g.defaultChecked = !!g._wrapperState.initialChecked),
      e !== "" && (g.name = e);
  }
  function Wc(g, I, e) {
    (I !== "number" || On(g.ownerDocument) !== g) &&
      (e == null
        ? (g.defaultValue = "" + g._wrapperState.initialValue)
        : g.defaultValue !== "" + e && (g.defaultValue = "" + e));
  }
  var El = Array.isArray;
  function OC(g, I, e, C) {
    if (((g = g.options), I)) {
      I = {};
      for (var l = 0; l < e.length; l++) I["$" + e[l]] = !0;
      for (e = 0; e < g.length; e++)
        (l = I.hasOwnProperty("$" + g[e].value)),
          g[e].selected !== l && (g[e].selected = l),
          l && C && (g[e].defaultSelected = !0);
    } else {
      for (e = "" + Me(e), I = null, l = 0; l < g.length; l++) {
        if (g[l].value === e) {
          (g[l].selected = !0), C && (g[l].defaultSelected = !0);
          return;
        }
        I !== null || g[l].disabled || (I = g[l]);
      }
      I !== null && (I.selected = !0);
    }
  }
  function Rc(g, I) {
    if (I.dangerouslySetInnerHTML != null) throw Error(J(91));
    return hg({}, I, {
      value: void 0,
      defaultValue: void 0,
      children: "" + g._wrapperState.initialValue,
    });
  }
  function xa(g, I) {
    var e = I.value;
    if (e == null) {
      if (((e = I.children), (I = I.defaultValue), e != null)) {
        if (I != null) throw Error(J(92));
        if (El(e)) {
          if (1 < e.length) throw Error(J(93));
          e = e[0];
        }
        I = e;
      }
      I == null && (I = ""), (e = I);
    }
    g._wrapperState = { initialValue: Me(e) };
  }
  function $s(g, I) {
    var e = Me(I.value),
      C = Me(I.defaultValue);
    e != null &&
      ((e = "" + e),
      e !== g.value && (g.value = e),
      I.defaultValue == null && g.defaultValue !== e && (g.defaultValue = e)),
      C != null && (g.defaultValue = "" + C);
  }
  function Ma(g) {
    var I = g.textContent;
    I === g._wrapperState.initialValue &&
      I !== "" &&
      I !== null &&
      (g.value = I);
  }
  function gu(g) {
    switch (g) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Xc(g, I) {
    return g == null || g === "http://www.w3.org/1999/xhtml"
      ? gu(I)
      : g === "http://www.w3.org/2000/svg" && I === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : g;
  }
  var An,
    Iu = (function (g) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (I, e, C, l) {
            MSApp.execUnsafeLocalFunction(function () {
              return g(I, e, C, l);
            });
          }
        : g;
    })(function (g, I) {
      if (g.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in g)
        g.innerHTML = I;
      else {
        for (
          An = An || document.createElement("div"),
            An.innerHTML = "<svg>" + I.valueOf().toString() + "</svg>",
            I = An.firstChild;
          g.firstChild;

        )
          g.removeChild(g.firstChild);
        for (; I.firstChild; ) g.appendChild(I.firstChild);
      }
    });
  function nt(g, I) {
    if (I) {
      var e = g.firstChild;
      if (e && e === g.lastChild && e.nodeType === 3) {
        e.nodeValue = I;
        return;
      }
    }
    g.textContent = I;
  }
  var Pl = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    sB = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Pl).forEach(function (g) {
    sB.forEach(function (I) {
      (I = I + g.charAt(0).toUpperCase() + g.substring(1)), (Pl[I] = Pl[g]);
    });
  });
  function eu(g, I, e) {
    return I == null || typeof I == "boolean" || I === ""
      ? ""
      : e || typeof I != "number" || I === 0 || (Pl.hasOwnProperty(g) && Pl[g])
      ? ("" + I).trim()
      : I + "px";
  }
  function Cu(g, I) {
    g = g.style;
    for (var e in I)
      if (I.hasOwnProperty(e)) {
        var C = e.indexOf("--") === 0,
          l = eu(e, I[e], C);
        e === "float" && (e = "cssFloat"), C ? g.setProperty(e, l) : (g[e] = l);
      }
  }
  var uB = hg(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function Jc(g, I) {
    if (I) {
      if (uB[g] && (I.children != null || I.dangerouslySetInnerHTML != null))
        throw Error(J(137, g));
      if (I.dangerouslySetInnerHTML != null) {
        if (I.children != null) throw Error(J(60));
        if (
          typeof I.dangerouslySetInnerHTML != "object" ||
          !("__html" in I.dangerouslySetInnerHTML)
        )
          throw Error(J(61));
      }
      if (I.style != null && typeof I.style != "object") throw Error(J(62));
    }
  }
  function vc(g, I) {
    if (g.indexOf("-") === -1) return typeof I.is == "string";
    switch (g) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var kc = null;
  function gi(g) {
    return (
      (g = g.target || g.srcElement || window),
      g.correspondingUseElement && (g = g.correspondingUseElement),
      g.nodeType === 3 ? g.parentNode : g
    );
  }
  var fc = null,
    _C = null,
    qC = null;
  function za(g) {
    if ((g = Dt(g))) {
      if (typeof fc != "function") throw Error(J(280));
      var I = g.stateNode;
      I && ((I = Qo(I)), fc(g.stateNode, g.type, I));
    }
  }
  function lu(g) {
    _C ? (qC ? qC.push(g) : (qC = [g])) : (_C = g);
  }
  function tu() {
    if (_C) {
      var g = _C,
        I = qC;
      if (((qC = _C = null), za(g), I)) for (g = 0; g < I.length; g++) za(I[g]);
    }
  }
  function nu(g, I) {
    return g(I);
  }
  function ou() {}
  var kA = !1;
  function Au(g, I, e) {
    if (kA) return g(I, e);
    kA = !0;
    try {
      return nu(g, I, e);
    } finally {
      (kA = !1), (_C !== null || qC !== null) && (ou(), tu());
    }
  }
  function ot(g, I) {
    var e = g.stateNode;
    if (e === null) return null;
    var C = Qo(e);
    if (C === null) return null;
    e = C[I];
    g: switch (I) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (C = !C.disabled) ||
          ((g = g.type),
          (C = !(
            g === "button" ||
            g === "input" ||
            g === "select" ||
            g === "textarea"
          ))),
          (g = !C);
        break g;
      default:
        g = !1;
    }
    if (g) return null;
    if (e && typeof e != "function") throw Error(J(231, I, typeof e));
    return e;
  }
  var Yc = !1;
  if (ce)
    try {
      var kl = {};
      Object.defineProperty(kl, "passive", {
        get: function () {
          Yc = !0;
        },
      }),
        window.addEventListener("test", kl, kl),
        window.removeEventListener("test", kl, kl);
    } catch {
      Yc = !1;
    }
  function mB(g, I, e, C, l, t, n, o, A) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
      I.apply(e, c);
    } catch (d) {
      this.onError(d);
    }
  }
  var Ol = !1,
    _n = null,
    qn = !1,
    Hc = null,
    ZB = {
      onError: function (g) {
        (Ol = !0), (_n = g);
      },
    };
  function GB(g, I, e, C, l, t, n, o, A) {
    (Ol = !1), (_n = null), mB.apply(ZB, arguments);
  }
  function bB(g, I, e, C, l, t, n, o, A) {
    if ((GB.apply(this, arguments), Ol)) {
      if (Ol) {
        var c = _n;
        (Ol = !1), (_n = null);
      } else throw Error(J(198));
      qn || ((qn = !0), (Hc = c));
    }
  }
  function SC(g) {
    var I = g,
      e = g;
    if (g.alternate) for (; I.return; ) I = I.return;
    else {
      g = I;
      do (I = g), I.flags & 4098 && (e = I.return), (g = I.return);
      while (g);
    }
    return I.tag === 3 ? e : null;
  }
  function cu(g) {
    if (g.tag === 13) {
      var I = g.memoizedState;
      if (
        (I === null && ((g = g.alternate), g !== null && (I = g.memoizedState)),
        I !== null)
      )
        return I.dehydrated;
    }
    return null;
  }
  function Ea(g) {
    if (SC(g) !== g) throw Error(J(188));
  }
  function BB(g) {
    var I = g.alternate;
    if (!I) {
      if (((I = SC(g)), I === null)) throw Error(J(188));
      return I !== g ? null : g;
    }
    for (var e = g, C = I; ; ) {
      var l = e.return;
      if (l === null) break;
      var t = l.alternate;
      if (t === null) {
        if (((C = l.return), C !== null)) {
          e = C;
          continue;
        }
        break;
      }
      if (l.child === t.child) {
        for (t = l.child; t; ) {
          if (t === e) return Ea(l), g;
          if (t === C) return Ea(l), I;
          t = t.sibling;
        }
        throw Error(J(188));
      }
      if (e.return !== C.return) (e = l), (C = t);
      else {
        for (var n = !1, o = l.child; o; ) {
          if (o === e) {
            (n = !0), (e = l), (C = t);
            break;
          }
          if (o === C) {
            (n = !0), (C = l), (e = t);
            break;
          }
          o = o.sibling;
        }
        if (!n) {
          for (o = t.child; o; ) {
            if (o === e) {
              (n = !0), (e = t), (C = l);
              break;
            }
            if (o === C) {
              (n = !0), (C = t), (e = l);
              break;
            }
            o = o.sibling;
          }
          if (!n) throw Error(J(189));
        }
      }
      if (e.alternate !== C) throw Error(J(190));
    }
    if (e.tag !== 3) throw Error(J(188));
    return e.stateNode.current === e ? g : I;
  }
  function du(g) {
    return (g = BB(g)), g !== null ? iu(g) : null;
  }
  function iu(g) {
    if (g.tag === 5 || g.tag === 6) return g;
    for (g = g.child; g !== null; ) {
      var I = iu(g);
      if (I !== null) return I;
      g = g.sibling;
    }
    return null;
  }
  var au = uI.unstable_scheduleCallback,
    Ua = uI.unstable_cancelCallback,
    pB = uI.unstable_shouldYield,
    yB = uI.unstable_requestPaint,
    Wg = uI.unstable_now,
    hB = uI.unstable_getCurrentPriorityLevel,
    Ii = uI.unstable_ImmediatePriority,
    ru = uI.unstable_UserBlockingPriority,
    $n = uI.unstable_NormalPriority,
    SB = uI.unstable_LowPriority,
    su = uI.unstable_IdlePriority,
    Mo = null,
    TI = null;
  function VB(g) {
    if (TI && typeof TI.onCommitFiberRoot == "function")
      try {
        TI.onCommitFiberRoot(Mo, g, void 0, (g.current.flags & 128) === 128);
      } catch {}
  }
  var HI = Math.clz32 ? Math.clz32 : XB,
    WB = Math.log,
    RB = Math.LN2;
  function XB(g) {
    return (g >>>= 0), g === 0 ? 32 : (31 - ((WB(g) / RB) | 0)) | 0;
  }
  var cn = 64,
    dn = 4194304;
  function Ul(g) {
    switch (g & -g) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return g & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return g & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return g;
    }
  }
  function go(g, I) {
    var e = g.pendingLanes;
    if (e === 0) return 0;
    var C = 0,
      l = g.suspendedLanes,
      t = g.pingedLanes,
      n = e & 268435455;
    if (n !== 0) {
      var o = n & ~l;
      o !== 0 ? (C = Ul(o)) : ((t &= n), t !== 0 && (C = Ul(t)));
    } else (n = e & ~l), n !== 0 ? (C = Ul(n)) : t !== 0 && (C = Ul(t));
    if (C === 0) return 0;
    if (
      I !== 0 &&
      I !== C &&
      !(I & l) &&
      ((l = C & -C), (t = I & -I), l >= t || (l === 16 && (t & 4194240) !== 0))
    )
      return I;
    if ((C & 4 && (C |= e & 16), (I = g.entangledLanes), I !== 0))
      for (g = g.entanglements, I &= C; 0 < I; )
        (e = 31 - HI(I)), (l = 1 << e), (C |= g[e]), (I &= ~l);
    return C;
  }
  function JB(g, I) {
    switch (g) {
      case 1:
      case 2:
      case 4:
        return I + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return I + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function vB(g, I) {
    for (
      var e = g.suspendedLanes,
        C = g.pingedLanes,
        l = g.expirationTimes,
        t = g.pendingLanes;
      0 < t;

    ) {
      var n = 31 - HI(t),
        o = 1 << n,
        A = l[n];
      A === -1
        ? (!(o & e) || o & C) && (l[n] = JB(o, I))
        : A <= I && (g.expiredLanes |= o),
        (t &= ~o);
    }
  }
  function wc(g) {
    return (
      (g = g.pendingLanes & -1073741825),
      g !== 0 ? g : g & 1073741824 ? 1073741824 : 0
    );
  }
  function uu() {
    var g = cn;
    return (cn <<= 1), !(cn & 4194240) && (cn = 64), g;
  }
  function fA(g) {
    for (var I = [], e = 0; 31 > e; e++) I.push(g);
    return I;
  }
  function Qt(g, I, e) {
    (g.pendingLanes |= I),
      I !== 536870912 && ((g.suspendedLanes = 0), (g.pingedLanes = 0)),
      (g = g.eventTimes),
      (I = 31 - HI(I)),
      (g[I] = e);
  }
  function kB(g, I) {
    var e = g.pendingLanes & ~I;
    (g.pendingLanes = I),
      (g.suspendedLanes = 0),
      (g.pingedLanes = 0),
      (g.expiredLanes &= I),
      (g.mutableReadLanes &= I),
      (g.entangledLanes &= I),
      (I = g.entanglements);
    var C = g.eventTimes;
    for (g = g.expirationTimes; 0 < e; ) {
      var l = 31 - HI(e),
        t = 1 << l;
      (I[l] = 0), (C[l] = -1), (g[l] = -1), (e &= ~t);
    }
  }
  function ei(g, I) {
    var e = (g.entangledLanes |= I);
    for (g = g.entanglements; e; ) {
      var C = 31 - HI(e),
        l = 1 << C;
      (l & I) | (g[C] & I) && (g[C] |= I), (e &= ~l);
    }
  }
  var Ag = 0;
  function mu(g) {
    return (
      (g &= -g), 1 < g ? (4 < g ? (g & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var Zu,
    Ci,
    Gu,
    bu,
    Bu,
    Nc = !1,
    an = [],
    ve = null,
    ke = null,
    fe = null,
    At = new Map(),
    ct = new Map(),
    he = [],
    fB =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function Qa(g, I) {
    switch (g) {
      case "focusin":
      case "focusout":
        ve = null;
        break;
      case "dragenter":
      case "dragleave":
        ke = null;
        break;
      case "mouseover":
      case "mouseout":
        fe = null;
        break;
      case "pointerover":
      case "pointerout":
        At.delete(I.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ct.delete(I.pointerId);
    }
  }
  function fl(g, I, e, C, l, t) {
    return g === null || g.nativeEvent !== t
      ? ((g = {
          blockedOn: I,
          domEventName: e,
          eventSystemFlags: C,
          nativeEvent: t,
          targetContainers: [l],
        }),
        I !== null && ((I = Dt(I)), I !== null && Ci(I)),
        g)
      : ((g.eventSystemFlags |= C),
        (I = g.targetContainers),
        l !== null && I.indexOf(l) === -1 && I.push(l),
        g);
  }
  function YB(g, I, e, C, l) {
    switch (I) {
      case "focusin":
        return (ve = fl(ve, g, I, e, C, l)), !0;
      case "dragenter":
        return (ke = fl(ke, g, I, e, C, l)), !0;
      case "mouseover":
        return (fe = fl(fe, g, I, e, C, l)), !0;
      case "pointerover":
        var t = l.pointerId;
        return At.set(t, fl(At.get(t) || null, g, I, e, C, l)), !0;
      case "gotpointercapture":
        return (
          (t = l.pointerId), ct.set(t, fl(ct.get(t) || null, g, I, e, C, l)), !0
        );
    }
    return !1;
  }
  function pu(g) {
    var I = nC(g.target);
    if (I !== null) {
      var e = SC(I);
      if (e !== null) {
        if (((I = e.tag), I === 13)) {
          if (((I = cu(e)), I !== null)) {
            (g.blockedOn = I),
              Bu(g.priority, function () {
                Gu(e);
              });
            return;
          }
        } else if (I === 3 && e.stateNode.current.memoizedState.isDehydrated) {
          g.blockedOn = e.tag === 3 ? e.stateNode.containerInfo : null;
          return;
        }
      }
    }
    g.blockedOn = null;
  }
  function Nn(g) {
    if (g.blockedOn !== null) return !1;
    for (var I = g.targetContainers; 0 < I.length; ) {
      var e = Kc(g.domEventName, g.eventSystemFlags, I[0], g.nativeEvent);
      if (e === null) {
        e = g.nativeEvent;
        var C = new e.constructor(e.type, e);
        (kc = C), e.target.dispatchEvent(C), (kc = null);
      } else return (I = Dt(e)), I !== null && Ci(I), (g.blockedOn = e), !1;
      I.shift();
    }
    return !0;
  }
  function La(g, I, e) {
    Nn(g) && e.delete(I);
  }
  function HB() {
    (Nc = !1),
      ve !== null && Nn(ve) && (ve = null),
      ke !== null && Nn(ke) && (ke = null),
      fe !== null && Nn(fe) && (fe = null),
      At.forEach(La),
      ct.forEach(La);
  }
  function Yl(g, I) {
    g.blockedOn === I &&
      ((g.blockedOn = null),
      Nc ||
        ((Nc = !0),
        uI.unstable_scheduleCallback(uI.unstable_NormalPriority, HB)));
  }
  function dt(g) {
    function I(l) {
      return Yl(l, g);
    }
    if (0 < an.length) {
      Yl(an[0], g);
      for (var e = 1; e < an.length; e++) {
        var C = an[e];
        C.blockedOn === g && (C.blockedOn = null);
      }
    }
    for (
      ve !== null && Yl(ve, g),
        ke !== null && Yl(ke, g),
        fe !== null && Yl(fe, g),
        At.forEach(I),
        ct.forEach(I),
        e = 0;
      e < he.length;
      e++
    )
      (C = he[e]), C.blockedOn === g && (C.blockedOn = null);
    for (; 0 < he.length && ((e = he[0]), e.blockedOn === null); )
      pu(e), e.blockedOn === null && he.shift();
  }
  var $C = me.ReactCurrentBatchConfig,
    Io = !0;
  function wB(g, I, e, C) {
    var l = Ag,
      t = $C.transition;
    $C.transition = null;
    try {
      (Ag = 1), li(g, I, e, C);
    } finally {
      (Ag = l), ($C.transition = t);
    }
  }
  function NB(g, I, e, C) {
    var l = Ag,
      t = $C.transition;
    $C.transition = null;
    try {
      (Ag = 4), li(g, I, e, C);
    } finally {
      (Ag = l), ($C.transition = t);
    }
  }
  function li(g, I, e, C) {
    if (Io) {
      var l = Kc(g, I, e, C);
      if (l === null) EA(g, I, C, eo, e), Qa(g, C);
      else if (YB(l, g, I, e, C)) C.stopPropagation();
      else if ((Qa(g, C), I & 4 && -1 < fB.indexOf(g))) {
        for (; l !== null; ) {
          var t = Dt(l);
          if (
            (t !== null && Zu(t),
            (t = Kc(g, I, e, C)),
            t === null && EA(g, I, C, eo, e),
            t === l)
          )
            break;
          l = t;
        }
        l !== null && C.stopPropagation();
      } else EA(g, I, C, null, e);
    }
  }
  var eo = null;
  function Kc(g, I, e, C) {
    if (((eo = null), (g = gi(C)), (g = nC(g)), g !== null))
      if (((I = SC(g)), I === null)) g = null;
      else if (((e = I.tag), e === 13)) {
        if (((g = cu(I)), g !== null)) return g;
        g = null;
      } else if (e === 3) {
        if (I.stateNode.current.memoizedState.isDehydrated)
          return I.tag === 3 ? I.stateNode.containerInfo : null;
        g = null;
      } else I !== g && (g = null);
    return (eo = g), null;
  }
  function yu(g) {
    switch (g) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (hB()) {
          case Ii:
            return 1;
          case ru:
            return 4;
          case $n:
          case SB:
            return 16;
          case su:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var We = null,
    ti = null,
    Kn = null;
  function hu() {
    if (Kn) return Kn;
    var g,
      I = ti,
      e = I.length,
      C,
      l = "value" in We ? We.value : We.textContent,
      t = l.length;
    for (g = 0; g < e && I[g] === l[g]; g++);
    var n = e - g;
    for (C = 1; C <= n && I[e - C] === l[t - C]; C++);
    return (Kn = l.slice(g, 1 < C ? 1 - C : void 0));
  }
  function Fn(g) {
    var I = g.keyCode;
    return (
      "charCode" in g
        ? ((g = g.charCode), g === 0 && I === 13 && (g = 13))
        : (g = I),
      g === 10 && (g = 13),
      32 <= g || g === 13 ? g : 0
    );
  }
  function rn() {
    return !0;
  }
  function Da() {
    return !1;
  }
  function GI(g) {
    function I(e, C, l, t, n) {
      (this._reactName = e),
        (this._targetInst = l),
        (this.type = C),
        (this.nativeEvent = t),
        (this.target = n),
        (this.currentTarget = null);
      for (var o in g)
        g.hasOwnProperty(o) && ((e = g[o]), (this[o] = e ? e(t) : t[o]));
      return (
        (this.isDefaultPrevented = (
          t.defaultPrevented != null ? t.defaultPrevented : t.returnValue === !1
        )
          ? rn
          : Da),
        (this.isPropagationStopped = Da),
        this
      );
    }
    return (
      hg(I.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var e = this.nativeEvent;
          e &&
            (e.preventDefault
              ? e.preventDefault()
              : typeof e.returnValue != "unknown" && (e.returnValue = !1),
            (this.isDefaultPrevented = rn));
        },
        stopPropagation: function () {
          var e = this.nativeEvent;
          e &&
            (e.stopPropagation
              ? e.stopPropagation()
              : typeof e.cancelBubble != "unknown" && (e.cancelBubble = !0),
            (this.isPropagationStopped = rn));
        },
        persist: function () {},
        isPersistent: rn,
      }),
      I
    );
  }
  var bl = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (g) {
        return g.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    ni = GI(bl),
    Lt = hg({}, bl, { view: 0, detail: 0 }),
    KB = GI(Lt),
    YA,
    HA,
    Hl,
    zo = hg({}, Lt, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: oi,
      button: 0,
      buttons: 0,
      relatedTarget: function (g) {
        return g.relatedTarget === void 0
          ? g.fromElement === g.srcElement
            ? g.toElement
            : g.fromElement
          : g.relatedTarget;
      },
      movementX: function (g) {
        return "movementX" in g
          ? g.movementX
          : (g !== Hl &&
              (Hl && g.type === "mousemove"
                ? ((YA = g.screenX - Hl.screenX), (HA = g.screenY - Hl.screenY))
                : (HA = YA = 0),
              (Hl = g)),
            YA);
      },
      movementY: function (g) {
        return "movementY" in g ? g.movementY : HA;
      },
    }),
    Ta = GI(zo),
    FB = hg({}, zo, { dataTransfer: 0 }),
    xB = GI(FB),
    MB = hg({}, Lt, { relatedTarget: 0 }),
    wA = GI(MB),
    zB = hg({}, bl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    EB = GI(zB),
    UB = hg({}, bl, {
      clipboardData: function (g) {
        return "clipboardData" in g ? g.clipboardData : window.clipboardData;
      },
    }),
    QB = GI(UB),
    LB = hg({}, bl, { data: 0 }),
    ja = GI(LB),
    DB = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    TB = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    jB = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function PB(g) {
    var I = this.nativeEvent;
    return I.getModifierState
      ? I.getModifierState(g)
      : (g = jB[g])
      ? !!I[g]
      : !1;
  }
  function oi() {
    return PB;
  }
  var OB = hg({}, Lt, {
      key: function (g) {
        if (g.key) {
          var I = DB[g.key] || g.key;
          if (I !== "Unidentified") return I;
        }
        return g.type === "keypress"
          ? ((g = Fn(g)), g === 13 ? "Enter" : String.fromCharCode(g))
          : g.type === "keydown" || g.type === "keyup"
          ? TB[g.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: oi,
      charCode: function (g) {
        return g.type === "keypress" ? Fn(g) : 0;
      },
      keyCode: function (g) {
        return g.type === "keydown" || g.type === "keyup" ? g.keyCode : 0;
      },
      which: function (g) {
        return g.type === "keypress"
          ? Fn(g)
          : g.type === "keydown" || g.type === "keyup"
          ? g.keyCode
          : 0;
      },
    }),
    _B = GI(OB),
    qB = hg({}, zo, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Pa = GI(qB),
    $B = hg({}, Lt, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: oi,
    }),
    gp = GI($B),
    Ip = hg({}, bl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    ep = GI(Ip),
    Cp = hg({}, zo, {
      deltaX: function (g) {
        return "deltaX" in g
          ? g.deltaX
          : "wheelDeltaX" in g
          ? -g.wheelDeltaX
          : 0;
      },
      deltaY: function (g) {
        return "deltaY" in g
          ? g.deltaY
          : "wheelDeltaY" in g
          ? -g.wheelDeltaY
          : "wheelDelta" in g
          ? -g.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    lp = GI(Cp),
    tp = [9, 13, 27, 32],
    Ai = ce && "CompositionEvent" in window,
    _l = null;
  ce && "documentMode" in document && (_l = document.documentMode);
  var np = ce && "TextEvent" in window && !_l,
    Su = ce && (!Ai || (_l && 8 < _l && 11 >= _l)),
    Oa = " ",
    _a = !1;
  function Vu(g, I) {
    switch (g) {
      case "keyup":
        return tp.indexOf(I.keyCode) !== -1;
      case "keydown":
        return I.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Wu(g) {
    return (g = g.detail), typeof g == "object" && "data" in g ? g.data : null;
  }
  var FC = !1;
  function op(g, I) {
    switch (g) {
      case "compositionend":
        return Wu(I);
      case "keypress":
        return I.which !== 32 ? null : ((_a = !0), Oa);
      case "textInput":
        return (g = I.data), g === Oa && _a ? null : g;
      default:
        return null;
    }
  }
  function Ap(g, I) {
    if (FC)
      return g === "compositionend" || (!Ai && Vu(g, I))
        ? ((g = hu()), (Kn = ti = We = null), (FC = !1), g)
        : null;
    switch (g) {
      case "paste":
        return null;
      case "keypress":
        if (!(I.ctrlKey || I.altKey || I.metaKey) || (I.ctrlKey && I.altKey)) {
          if (I.char && 1 < I.char.length) return I.char;
          if (I.which) return String.fromCharCode(I.which);
        }
        return null;
      case "compositionend":
        return Su && I.locale !== "ko" ? null : I.data;
      default:
        return null;
    }
  }
  var cp = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function qa(g) {
    var I = g && g.nodeName && g.nodeName.toLowerCase();
    return I === "input" ? !!cp[g.type] : I === "textarea";
  }
  function Ru(g, I, e, C) {
    lu(C),
      (I = Co(I, "onChange")),
      0 < I.length &&
        ((e = new ni("onChange", "change", null, e, C)),
        g.push({ event: e, listeners: I }));
  }
  var ql = null,
    it = null;
  function dp(g) {
    Fu(g, 0);
  }
  function Eo(g) {
    var I = zC(g);
    if (_s(I)) return g;
  }
  function ip(g, I) {
    if (g === "change") return I;
  }
  var Xu = !1;
  if (ce) {
    var NA;
    if (ce) {
      var KA = "oninput" in document;
      if (!KA) {
        var $a = document.createElement("div");
        $a.setAttribute("oninput", "return;"),
          (KA = typeof $a.oninput == "function");
      }
      NA = KA;
    } else NA = !1;
    Xu = NA && (!document.documentMode || 9 < document.documentMode);
  }
  function gr() {
    ql && (ql.detachEvent("onpropertychange", Ju), (it = ql = null));
  }
  function Ju(g) {
    if (g.propertyName === "value" && Eo(it)) {
      var I = [];
      Ru(I, it, g, gi(g)), Au(dp, I);
    }
  }
  function ap(g, I, e) {
    g === "focusin"
      ? (gr(), (ql = I), (it = e), ql.attachEvent("onpropertychange", Ju))
      : g === "focusout" && gr();
  }
  function rp(g) {
    if (g === "selectionchange" || g === "keyup" || g === "keydown")
      return Eo(it);
  }
  function sp(g, I) {
    if (g === "click") return Eo(I);
  }
  function up(g, I) {
    if (g === "input" || g === "change") return Eo(I);
  }
  function mp(g, I) {
    return (g === I && (g !== 0 || 1 / g === 1 / I)) || (g !== g && I !== I);
  }
  var FI = typeof Object.is == "function" ? Object.is : mp;
  function at(g, I) {
    if (FI(g, I)) return !0;
    if (
      typeof g != "object" ||
      g === null ||
      typeof I != "object" ||
      I === null
    )
      return !1;
    var e = Object.keys(g),
      C = Object.keys(I);
    if (e.length !== C.length) return !1;
    for (C = 0; C < e.length; C++) {
      var l = e[C];
      if (!bc.call(I, l) || !FI(g[l], I[l])) return !1;
    }
    return !0;
  }
  function Ir(g) {
    for (; g && g.firstChild; ) g = g.firstChild;
    return g;
  }
  function er(g, I) {
    var e = Ir(g);
    g = 0;
    for (var C; e; ) {
      if (e.nodeType === 3) {
        if (((C = g + e.textContent.length), g <= I && C >= I))
          return { node: e, offset: I - g };
        g = C;
      }
      g: {
        for (; e; ) {
          if (e.nextSibling) {
            e = e.nextSibling;
            break g;
          }
          e = e.parentNode;
        }
        e = void 0;
      }
      e = Ir(e);
    }
  }
  function vu(g, I) {
    return g && I
      ? g === I
        ? !0
        : g && g.nodeType === 3
        ? !1
        : I && I.nodeType === 3
        ? vu(g, I.parentNode)
        : "contains" in g
        ? g.contains(I)
        : g.compareDocumentPosition
        ? !!(g.compareDocumentPosition(I) & 16)
        : !1
      : !1;
  }
  function ku() {
    for (var g = window, I = On(); I instanceof g.HTMLIFrameElement; ) {
      try {
        var e = typeof I.contentWindow.location.href == "string";
      } catch {
        e = !1;
      }
      if (e) g = I.contentWindow;
      else break;
      I = On(g.document);
    }
    return I;
  }
  function ci(g) {
    var I = g && g.nodeName && g.nodeName.toLowerCase();
    return (
      I &&
      ((I === "input" &&
        (g.type === "text" ||
          g.type === "search" ||
          g.type === "tel" ||
          g.type === "url" ||
          g.type === "password")) ||
        I === "textarea" ||
        g.contentEditable === "true")
    );
  }
  function Zp(g) {
    var I = ku(),
      e = g.focusedElem,
      C = g.selectionRange;
    if (
      I !== e &&
      e &&
      e.ownerDocument &&
      vu(e.ownerDocument.documentElement, e)
    ) {
      if (C !== null && ci(e)) {
        if (
          ((I = C.start),
          (g = C.end),
          g === void 0 && (g = I),
          "selectionStart" in e)
        )
          (e.selectionStart = I),
            (e.selectionEnd = Math.min(g, e.value.length));
        else if (
          ((g = ((I = e.ownerDocument || document) && I.defaultView) || window),
          g.getSelection)
        ) {
          g = g.getSelection();
          var l = e.textContent.length,
            t = Math.min(C.start, l);
          (C = C.end === void 0 ? t : Math.min(C.end, l)),
            !g.extend && t > C && ((l = C), (C = t), (t = l)),
            (l = er(e, t));
          var n = er(e, C);
          l &&
            n &&
            (g.rangeCount !== 1 ||
              g.anchorNode !== l.node ||
              g.anchorOffset !== l.offset ||
              g.focusNode !== n.node ||
              g.focusOffset !== n.offset) &&
            ((I = I.createRange()),
            I.setStart(l.node, l.offset),
            g.removeAllRanges(),
            t > C
              ? (g.addRange(I), g.extend(n.node, n.offset))
              : (I.setEnd(n.node, n.offset), g.addRange(I)));
        }
      }
      for (I = [], g = e; (g = g.parentNode); )
        g.nodeType === 1 &&
          I.push({ element: g, left: g.scrollLeft, top: g.scrollTop });
      for (typeof e.focus == "function" && e.focus(), e = 0; e < I.length; e++)
        (g = I[e]),
          (g.element.scrollLeft = g.left),
          (g.element.scrollTop = g.top);
    }
  }
  var Gp = ce && "documentMode" in document && 11 >= document.documentMode,
    xC = null,
    Fc = null,
    $l = null,
    xc = !1;
  function Cr(g, I, e) {
    var C =
      e.window === e ? e.document : e.nodeType === 9 ? e : e.ownerDocument;
    xc ||
      xC == null ||
      xC !== On(C) ||
      ((C = xC),
      "selectionStart" in C && ci(C)
        ? (C = { start: C.selectionStart, end: C.selectionEnd })
        : ((C = (
            (C.ownerDocument && C.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (C = {
            anchorNode: C.anchorNode,
            anchorOffset: C.anchorOffset,
            focusNode: C.focusNode,
            focusOffset: C.focusOffset,
          })),
      ($l && at($l, C)) ||
        (($l = C),
        (C = Co(Fc, "onSelect")),
        0 < C.length &&
          ((I = new ni("onSelect", "select", null, I, e)),
          g.push({ event: I, listeners: C }),
          (I.target = xC))));
  }
  function sn(g, I) {
    var e = {};
    return (
      (e[g.toLowerCase()] = I.toLowerCase()),
      (e["Webkit" + g] = "webkit" + I),
      (e["Moz" + g] = "moz" + I),
      e
    );
  }
  var MC = {
      animationend: sn("Animation", "AnimationEnd"),
      animationiteration: sn("Animation", "AnimationIteration"),
      animationstart: sn("Animation", "AnimationStart"),
      transitionend: sn("Transition", "TransitionEnd"),
    },
    FA = {},
    fu = {};
  ce &&
    ((fu = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete MC.animationend.animation,
      delete MC.animationiteration.animation,
      delete MC.animationstart.animation),
    "TransitionEvent" in window || delete MC.transitionend.transition);
  function Uo(g) {
    if (FA[g]) return FA[g];
    if (!MC[g]) return g;
    var I = MC[g],
      e;
    for (e in I) if (I.hasOwnProperty(e) && e in fu) return (FA[g] = I[e]);
    return g;
  }
  var Yu = Uo("animationend"),
    Hu = Uo("animationiteration"),
    wu = Uo("animationstart"),
    Nu = Uo("transitionend"),
    Ku = new Map(),
    lr =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function qe(g, I) {
    Ku.set(g, I), hC(I, [g]);
  }
  for (var xA = 0; xA < lr.length; xA++) {
    var MA = lr[xA],
      bp = MA.toLowerCase(),
      Bp = MA[0].toUpperCase() + MA.slice(1);
    qe(bp, "on" + Bp);
  }
  qe(Yu, "onAnimationEnd");
  qe(Hu, "onAnimationIteration");
  qe(wu, "onAnimationStart");
  qe("dblclick", "onDoubleClick");
  qe("focusin", "onFocus");
  qe("focusout", "onBlur");
  qe(Nu, "onTransitionEnd");
  nl("onMouseEnter", ["mouseout", "mouseover"]);
  nl("onMouseLeave", ["mouseout", "mouseover"]);
  nl("onPointerEnter", ["pointerout", "pointerover"]);
  nl("onPointerLeave", ["pointerout", "pointerover"]);
  hC(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(
      " "
    )
  );
  hC(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  );
  hC("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  hC(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  );
  hC(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  );
  hC(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Ql =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    pp = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(Ql)
    );
  function tr(g, I, e) {
    var C = g.type || "unknown-event";
    (g.currentTarget = e), bB(C, I, void 0, g), (g.currentTarget = null);
  }
  function Fu(g, I) {
    I = (I & 4) !== 0;
    for (var e = 0; e < g.length; e++) {
      var C = g[e],
        l = C.event;
      C = C.listeners;
      g: {
        var t = void 0;
        if (I)
          for (var n = C.length - 1; 0 <= n; n--) {
            var o = C[n],
              A = o.instance,
              c = o.currentTarget;
            if (((o = o.listener), A !== t && l.isPropagationStopped()))
              break g;
            tr(l, o, c), (t = A);
          }
        else
          for (n = 0; n < C.length; n++) {
            if (
              ((o = C[n]),
              (A = o.instance),
              (c = o.currentTarget),
              (o = o.listener),
              A !== t && l.isPropagationStopped())
            )
              break g;
            tr(l, o, c), (t = A);
          }
      }
    }
    if (qn) throw ((g = Hc), (qn = !1), (Hc = null), g);
  }
  function mg(g, I) {
    var e = I[Qc];
    e === void 0 && (e = I[Qc] = new Set());
    var C = g + "__bubble";
    e.has(C) || (xu(I, g, 2, !1), e.add(C));
  }
  function zA(g, I, e) {
    var C = 0;
    I && (C |= 4), xu(e, g, C, I);
  }
  var un = "_reactListening" + Math.random().toString(36).slice(2);
  function rt(g) {
    if (!g[un]) {
      (g[un] = !0),
        Ds.forEach(function (e) {
          e !== "selectionchange" && (pp.has(e) || zA(e, !1, g), zA(e, !0, g));
        });
      var I = g.nodeType === 9 ? g : g.ownerDocument;
      I === null || I[un] || ((I[un] = !0), zA("selectionchange", !1, I));
    }
  }
  function xu(g, I, e, C) {
    switch (yu(I)) {
      case 1:
        var l = wB;
        break;
      case 4:
        l = NB;
        break;
      default:
        l = li;
    }
    (e = l.bind(null, I, e, g)),
      (l = void 0),
      !Yc ||
        (I !== "touchstart" && I !== "touchmove" && I !== "wheel") ||
        (l = !0),
      C
        ? l !== void 0
          ? g.addEventListener(I, e, { capture: !0, passive: l })
          : g.addEventListener(I, e, !0)
        : l !== void 0
        ? g.addEventListener(I, e, { passive: l })
        : g.addEventListener(I, e, !1);
  }
  function EA(g, I, e, C, l) {
    var t = C;
    if (!(I & 1) && !(I & 2) && C !== null)
      g: for (;;) {
        if (C === null) return;
        var n = C.tag;
        if (n === 3 || n === 4) {
          var o = C.stateNode.containerInfo;
          if (o === l || (o.nodeType === 8 && o.parentNode === l)) break;
          if (n === 4)
            for (n = C.return; n !== null; ) {
              var A = n.tag;
              if (
                (A === 3 || A === 4) &&
                ((A = n.stateNode.containerInfo),
                A === l || (A.nodeType === 8 && A.parentNode === l))
              )
                return;
              n = n.return;
            }
          for (; o !== null; ) {
            if (((n = nC(o)), n === null)) return;
            if (((A = n.tag), A === 5 || A === 6)) {
              C = t = n;
              continue g;
            }
            o = o.parentNode;
          }
        }
        C = C.return;
      }
    Au(function () {
      var c = t,
        d = gi(e),
        i = [];
      g: {
        var r = Ku.get(g);
        if (r !== void 0) {
          var u = ni,
            b = g;
          switch (g) {
            case "keypress":
              if (Fn(e) === 0) break g;
            case "keydown":
            case "keyup":
              u = _B;
              break;
            case "focusin":
              (b = "focus"), (u = wA);
              break;
            case "focusout":
              (b = "blur"), (u = wA);
              break;
            case "beforeblur":
            case "afterblur":
              u = wA;
              break;
            case "click":
              if (e.button === 2) break g;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              u = Ta;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              u = xB;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              u = gp;
              break;
            case Yu:
            case Hu:
            case wu:
              u = EB;
              break;
            case Nu:
              u = ep;
              break;
            case "scroll":
              u = KB;
              break;
            case "wheel":
              u = lp;
              break;
            case "copy":
            case "cut":
            case "paste":
              u = QB;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              u = Pa;
          }
          var m = (I & 4) !== 0,
            p = !m && g === "scroll",
            G = m ? (r !== null ? r + "Capture" : null) : r;
          m = [];
          for (var Z = c, B; Z !== null; ) {
            B = Z;
            var y = B.stateNode;
            if (
              (B.tag === 5 &&
                y !== null &&
                ((B = y),
                G !== null &&
                  ((y = ot(Z, G)), y != null && m.push(st(Z, y, B)))),
              p)
            )
              break;
            Z = Z.return;
          }
          0 < m.length &&
            ((r = new u(r, b, null, e, d)), i.push({ event: r, listeners: m }));
        }
      }
      if (!(I & 7)) {
        g: {
          if (
            ((r = g === "mouseover" || g === "pointerover"),
            (u = g === "mouseout" || g === "pointerout"),
            r &&
              e !== kc &&
              (b = e.relatedTarget || e.fromElement) &&
              (nC(b) || b[de]))
          )
            break g;
          if (
            (u || r) &&
            ((r =
              d.window === d
                ? d
                : (r = d.ownerDocument)
                ? r.defaultView || r.parentWindow
                : window),
            u
              ? ((b = e.relatedTarget || e.toElement),
                (u = c),
                (b = b ? nC(b) : null),
                b !== null &&
                  ((p = SC(b)), b !== p || (b.tag !== 5 && b.tag !== 6)) &&
                  (b = null))
              : ((u = null), (b = c)),
            u !== b)
          ) {
            if (
              ((m = Ta),
              (y = "onMouseLeave"),
              (G = "onMouseEnter"),
              (Z = "mouse"),
              (g === "pointerout" || g === "pointerover") &&
                ((m = Pa),
                (y = "onPointerLeave"),
                (G = "onPointerEnter"),
                (Z = "pointer")),
              (p = u == null ? r : zC(u)),
              (B = b == null ? r : zC(b)),
              (r = new m(y, Z + "leave", u, e, d)),
              (r.target = p),
              (r.relatedTarget = B),
              (y = null),
              nC(d) === c &&
                ((m = new m(G, Z + "enter", b, e, d)),
                (m.target = B),
                (m.relatedTarget = p),
                (y = m)),
              (p = y),
              u && b)
            )
              I: {
                for (m = u, G = b, Z = 0, B = m; B; B = JC(B)) Z++;
                for (B = 0, y = G; y; y = JC(y)) B++;
                for (; 0 < Z - B; ) (m = JC(m)), Z--;
                for (; 0 < B - Z; ) (G = JC(G)), B--;
                for (; Z--; ) {
                  if (m === G || (G !== null && m === G.alternate)) break I;
                  (m = JC(m)), (G = JC(G));
                }
                m = null;
              }
            else m = null;
            u !== null && nr(i, r, u, m, !1),
              b !== null && p !== null && nr(i, p, b, m, !0);
          }
        }
        g: {
          if (
            ((r = c ? zC(c) : window),
            (u = r.nodeName && r.nodeName.toLowerCase()),
            u === "select" || (u === "input" && r.type === "file"))
          )
            var h = ip;
          else if (qa(r))
            if (Xu) h = up;
            else {
              h = rp;
              var W = ap;
            }
          else
            (u = r.nodeName) &&
              u.toLowerCase() === "input" &&
              (r.type === "checkbox" || r.type === "radio") &&
              (h = sp);
          if (h && (h = h(g, c))) {
            Ru(i, h, e, d);
            break g;
          }
          W && W(g, r, c),
            g === "focusout" &&
              (W = r._wrapperState) &&
              W.controlled &&
              r.type === "number" &&
              Wc(r, "number", r.value);
        }
        switch (((W = c ? zC(c) : window), g)) {
          case "focusin":
            (qa(W) || W.contentEditable === "true") &&
              ((xC = W), (Fc = c), ($l = null));
            break;
          case "focusout":
            $l = Fc = xC = null;
            break;
          case "mousedown":
            xc = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (xc = !1), Cr(i, e, d);
            break;
          case "selectionchange":
            if (Gp) break;
          case "keydown":
          case "keyup":
            Cr(i, e, d);
        }
        var S;
        if (Ai)
          g: {
            switch (g) {
              case "compositionstart":
                var V = "onCompositionStart";
                break g;
              case "compositionend":
                V = "onCompositionEnd";
                break g;
              case "compositionupdate":
                V = "onCompositionUpdate";
                break g;
            }
            V = void 0;
          }
        else
          FC
            ? Vu(g, e) && (V = "onCompositionEnd")
            : g === "keydown" &&
              e.keyCode === 229 &&
              (V = "onCompositionStart");
        V &&
          (Su &&
            e.locale !== "ko" &&
            (FC || V !== "onCompositionStart"
              ? V === "onCompositionEnd" && FC && (S = hu())
              : ((We = d),
                (ti = "value" in We ? We.value : We.textContent),
                (FC = !0))),
          (W = Co(c, V)),
          0 < W.length &&
            ((V = new ja(V, g, null, e, d)),
            i.push({ event: V, listeners: W }),
            S ? (V.data = S) : ((S = Wu(e)), S !== null && (V.data = S)))),
          (S = np ? op(g, e) : Ap(g, e)) &&
            ((c = Co(c, "onBeforeInput")),
            0 < c.length &&
              ((d = new ja("onBeforeInput", "beforeinput", null, e, d)),
              i.push({ event: d, listeners: c }),
              (d.data = S)));
      }
      Fu(i, I);
    });
  }
  function st(g, I, e) {
    return { instance: g, listener: I, currentTarget: e };
  }
  function Co(g, I) {
    for (var e = I + "Capture", C = []; g !== null; ) {
      var l = g,
        t = l.stateNode;
      l.tag === 5 &&
        t !== null &&
        ((l = t),
        (t = ot(g, e)),
        t != null && C.unshift(st(g, t, l)),
        (t = ot(g, I)),
        t != null && C.push(st(g, t, l))),
        (g = g.return);
    }
    return C;
  }
  function JC(g) {
    if (g === null) return null;
    do g = g.return;
    while (g && g.tag !== 5);
    return g || null;
  }
  function nr(g, I, e, C, l) {
    for (var t = I._reactName, n = []; e !== null && e !== C; ) {
      var o = e,
        A = o.alternate,
        c = o.stateNode;
      if (A !== null && A === C) break;
      o.tag === 5 &&
        c !== null &&
        ((o = c),
        l
          ? ((A = ot(e, t)), A != null && n.unshift(st(e, A, o)))
          : l || ((A = ot(e, t)), A != null && n.push(st(e, A, o)))),
        (e = e.return);
    }
    n.length !== 0 && g.push({ event: I, listeners: n });
  }
  var yp = /\r\n?/g,
    hp = /\u0000|\uFFFD/g;
  function or(g) {
    return (typeof g == "string" ? g : "" + g)
      .replace(
        yp,
        `
`
      )
      .replace(hp, "");
  }
  function mn(g, I, e) {
    if (((I = or(I)), or(g) !== I && e)) throw Error(J(425));
  }
  function lo() {}
  var Mc = null,
    zc = null;
  function Ec(g, I) {
    return (
      g === "textarea" ||
      g === "noscript" ||
      typeof I.children == "string" ||
      typeof I.children == "number" ||
      (typeof I.dangerouslySetInnerHTML == "object" &&
        I.dangerouslySetInnerHTML !== null &&
        I.dangerouslySetInnerHTML.__html != null)
    );
  }
  var Uc = typeof setTimeout == "function" ? setTimeout : void 0,
    Sp = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Ar = typeof Promise == "function" ? Promise : void 0,
    Vp =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof Ar < "u"
        ? function (g) {
            return Ar.resolve(null).then(g).catch(Wp);
          }
        : Uc;
  function Wp(g) {
    setTimeout(function () {
      throw g;
    });
  }
  function UA(g, I) {
    var e = I,
      C = 0;
    do {
      var l = e.nextSibling;
      if ((g.removeChild(e), l && l.nodeType === 8))
        if (((e = l.data), e === "/$")) {
          if (C === 0) {
            g.removeChild(l), dt(I);
            return;
          }
          C--;
        } else (e !== "$" && e !== "$?" && e !== "$!") || C++;
      e = l;
    } while (e);
    dt(I);
  }
  function Ye(g) {
    for (; g != null; g = g.nextSibling) {
      var I = g.nodeType;
      if (I === 1 || I === 3) break;
      if (I === 8) {
        if (((I = g.data), I === "$" || I === "$!" || I === "$?")) break;
        if (I === "/$") return null;
      }
    }
    return g;
  }
  function cr(g) {
    g = g.previousSibling;
    for (var I = 0; g; ) {
      if (g.nodeType === 8) {
        var e = g.data;
        if (e === "$" || e === "$!" || e === "$?") {
          if (I === 0) return g;
          I--;
        } else e === "/$" && I++;
      }
      g = g.previousSibling;
    }
    return null;
  }
  var Bl = Math.random().toString(36).slice(2),
    LI = "__reactFiber$" + Bl,
    ut = "__reactProps$" + Bl,
    de = "__reactContainer$" + Bl,
    Qc = "__reactEvents$" + Bl,
    Rp = "__reactListeners$" + Bl,
    Xp = "__reactHandles$" + Bl;
  function nC(g) {
    var I = g[LI];
    if (I) return I;
    for (var e = g.parentNode; e; ) {
      if ((I = e[de] || e[LI])) {
        if (
          ((e = I.alternate),
          I.child !== null || (e !== null && e.child !== null))
        )
          for (g = cr(g); g !== null; ) {
            if ((e = g[LI])) return e;
            g = cr(g);
          }
        return I;
      }
      (g = e), (e = g.parentNode);
    }
    return null;
  }
  function Dt(g) {
    return (
      (g = g[LI] || g[de]),
      !g || (g.tag !== 5 && g.tag !== 6 && g.tag !== 13 && g.tag !== 3)
        ? null
        : g
    );
  }
  function zC(g) {
    if (g.tag === 5 || g.tag === 6) return g.stateNode;
    throw Error(J(33));
  }
  function Qo(g) {
    return g[ut] || null;
  }
  var Lc = [],
    EC = -1;
  function $e(g) {
    return { current: g };
  }
  function Zg(g) {
    0 > EC || ((g.current = Lc[EC]), (Lc[EC] = null), EC--);
  }
  function sg(g, I) {
    EC++, (Lc[EC] = g.current), (g.current = I);
  }
  var ze = {},
    Lg = $e(ze),
    eI = $e(!1),
    aC = ze;
  function ol(g, I) {
    var e = g.type.contextTypes;
    if (!e) return ze;
    var C = g.stateNode;
    if (C && C.__reactInternalMemoizedUnmaskedChildContext === I)
      return C.__reactInternalMemoizedMaskedChildContext;
    var l = {},
      t;
    for (t in e) l[t] = I[t];
    return (
      C &&
        ((g = g.stateNode),
        (g.__reactInternalMemoizedUnmaskedChildContext = I),
        (g.__reactInternalMemoizedMaskedChildContext = l)),
      l
    );
  }
  function CI(g) {
    return (g = g.childContextTypes), g != null;
  }
  function to() {
    Zg(eI), Zg(Lg);
  }
  function dr(g, I, e) {
    if (Lg.current !== ze) throw Error(J(168));
    sg(Lg, I), sg(eI, e);
  }
  function Mu(g, I, e) {
    var C = g.stateNode;
    if (((I = I.childContextTypes), typeof C.getChildContext != "function"))
      return e;
    C = C.getChildContext();
    for (var l in C) if (!(l in I)) throw Error(J(108, aB(g) || "Unknown", l));
    return hg({}, e, C);
  }
  function no(g) {
    return (
      (g =
        ((g = g.stateNode) && g.__reactInternalMemoizedMergedChildContext) ||
        ze),
      (aC = Lg.current),
      sg(Lg, g),
      sg(eI, eI.current),
      !0
    );
  }
  function ir(g, I, e) {
    var C = g.stateNode;
    if (!C) throw Error(J(169));
    e
      ? ((g = Mu(g, I, aC)),
        (C.__reactInternalMemoizedMergedChildContext = g),
        Zg(eI),
        Zg(Lg),
        sg(Lg, g))
      : Zg(eI),
      sg(eI, e);
  }
  var te = null,
    Lo = !1,
    QA = !1;
  function zu(g) {
    te === null ? (te = [g]) : te.push(g);
  }
  function Jp(g) {
    (Lo = !0), zu(g);
  }
  function gC() {
    if (!QA && te !== null) {
      QA = !0;
      var g = 0,
        I = Ag;
      try {
        var e = te;
        for (Ag = 1; g < e.length; g++) {
          var C = e[g];
          do C = C(!0);
          while (C !== null);
        }
        (te = null), (Lo = !1);
      } catch (l) {
        throw (te !== null && (te = te.slice(g + 1)), au(Ii, gC), l);
      } finally {
        (Ag = I), (QA = !1);
      }
    }
    return null;
  }
  var UC = [],
    QC = 0,
    oo = null,
    Ao = 0,
    BI = [],
    pI = 0,
    rC = null,
    ne = 1,
    oe = "";
  function lC(g, I) {
    (UC[QC++] = Ao), (UC[QC++] = oo), (oo = g), (Ao = I);
  }
  function Eu(g, I, e) {
    (BI[pI++] = ne), (BI[pI++] = oe), (BI[pI++] = rC), (rC = g);
    var C = ne;
    g = oe;
    var l = 32 - HI(C) - 1;
    (C &= ~(1 << l)), (e += 1);
    var t = 32 - HI(I) + l;
    if (30 < t) {
      var n = l - (l % 5);
      (t = (C & ((1 << n) - 1)).toString(32)),
        (C >>= n),
        (l -= n),
        (ne = (1 << (32 - HI(I) + l)) | (e << l) | C),
        (oe = t + g);
    } else (ne = (1 << t) | (e << l) | C), (oe = g);
  }
  function di(g) {
    g.return !== null && (lC(g, 1), Eu(g, 1, 0));
  }
  function ii(g) {
    for (; g === oo; )
      (oo = UC[--QC]), (UC[QC] = null), (Ao = UC[--QC]), (UC[QC] = null);
    for (; g === rC; )
      (rC = BI[--pI]),
        (BI[pI] = null),
        (oe = BI[--pI]),
        (BI[pI] = null),
        (ne = BI[--pI]),
        (BI[pI] = null);
  }
  var aI = null,
    iI = null,
    bg = !1,
    fI = null;
  function Uu(g, I) {
    var e = yI(5, null, null, 0);
    (e.elementType = "DELETED"),
      (e.stateNode = I),
      (e.return = g),
      (I = g.deletions),
      I === null ? ((g.deletions = [e]), (g.flags |= 16)) : I.push(e);
  }
  function ar(g, I) {
    switch (g.tag) {
      case 5:
        var e = g.type;
        return (
          (I =
            I.nodeType !== 1 || e.toLowerCase() !== I.nodeName.toLowerCase()
              ? null
              : I),
          I !== null
            ? ((g.stateNode = I), (aI = g), (iI = Ye(I.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (I = g.pendingProps === "" || I.nodeType !== 3 ? null : I),
          I !== null ? ((g.stateNode = I), (aI = g), (iI = null), !0) : !1
        );
      case 13:
        return (
          (I = I.nodeType !== 8 ? null : I),
          I !== null
            ? ((e = rC !== null ? { id: ne, overflow: oe } : null),
              (g.memoizedState = {
                dehydrated: I,
                treeContext: e,
                retryLane: 1073741824,
              }),
              (e = yI(18, null, null, 0)),
              (e.stateNode = I),
              (e.return = g),
              (g.child = e),
              (aI = g),
              (iI = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function Dc(g) {
    return (g.mode & 1) !== 0 && (g.flags & 128) === 0;
  }
  function Tc(g) {
    if (bg) {
      var I = iI;
      if (I) {
        var e = I;
        if (!ar(g, I)) {
          if (Dc(g)) throw Error(J(418));
          I = Ye(e.nextSibling);
          var C = aI;
          I && ar(g, I)
            ? Uu(C, e)
            : ((g.flags = (g.flags & -4097) | 2), (bg = !1), (aI = g));
        }
      } else {
        if (Dc(g)) throw Error(J(418));
        (g.flags = (g.flags & -4097) | 2), (bg = !1), (aI = g);
      }
    }
  }
  function rr(g) {
    for (
      g = g.return;
      g !== null && g.tag !== 5 && g.tag !== 3 && g.tag !== 13;

    )
      g = g.return;
    aI = g;
  }
  function Zn(g) {
    if (g !== aI) return !1;
    if (!bg) return rr(g), (bg = !0), !1;
    var I;
    if (
      ((I = g.tag !== 3) &&
        !(I = g.tag !== 5) &&
        ((I = g.type),
        (I = I !== "head" && I !== "body" && !Ec(g.type, g.memoizedProps))),
      I && (I = iI))
    ) {
      if (Dc(g)) throw (Qu(), Error(J(418)));
      for (; I; ) Uu(g, I), (I = Ye(I.nextSibling));
    }
    if ((rr(g), g.tag === 13)) {
      if (((g = g.memoizedState), (g = g !== null ? g.dehydrated : null), !g))
        throw Error(J(317));
      g: {
        for (g = g.nextSibling, I = 0; g; ) {
          if (g.nodeType === 8) {
            var e = g.data;
            if (e === "/$") {
              if (I === 0) {
                iI = Ye(g.nextSibling);
                break g;
              }
              I--;
            } else (e !== "$" && e !== "$!" && e !== "$?") || I++;
          }
          g = g.nextSibling;
        }
        iI = null;
      }
    } else iI = aI ? Ye(g.stateNode.nextSibling) : null;
    return !0;
  }
  function Qu() {
    for (var g = iI; g; ) g = Ye(g.nextSibling);
  }
  function Al() {
    (iI = aI = null), (bg = !1);
  }
  function ai(g) {
    fI === null ? (fI = [g]) : fI.push(g);
  }
  var vp = me.ReactCurrentBatchConfig;
  function wl(g, I, e) {
    if (
      ((g = e.ref),
      g !== null && typeof g != "function" && typeof g != "object")
    ) {
      if (e._owner) {
        if (((e = e._owner), e)) {
          if (e.tag !== 1) throw Error(J(309));
          var C = e.stateNode;
        }
        if (!C) throw Error(J(147, g));
        var l = C,
          t = "" + g;
        return I !== null &&
          I.ref !== null &&
          typeof I.ref == "function" &&
          I.ref._stringRef === t
          ? I.ref
          : ((I = function (n) {
              var o = l.refs;
              n === null ? delete o[t] : (o[t] = n);
            }),
            (I._stringRef = t),
            I);
      }
      if (typeof g != "string") throw Error(J(284));
      if (!e._owner) throw Error(J(290, g));
    }
    return g;
  }
  function Gn(g, I) {
    throw (
      ((g = Object.prototype.toString.call(I)),
      Error(
        J(
          31,
          g === "[object Object]"
            ? "object with keys {" + Object.keys(I).join(", ") + "}"
            : g
        )
      ))
    );
  }
  function sr(g) {
    var I = g._init;
    return I(g._payload);
  }
  function Lu(g) {
    function I(G, Z) {
      if (g) {
        var B = G.deletions;
        B === null ? ((G.deletions = [Z]), (G.flags |= 16)) : B.push(Z);
      }
    }
    function e(G, Z) {
      if (!g) return null;
      for (; Z !== null; ) I(G, Z), (Z = Z.sibling);
      return null;
    }
    function C(G, Z) {
      for (G = new Map(); Z !== null; )
        Z.key !== null ? G.set(Z.key, Z) : G.set(Z.index, Z), (Z = Z.sibling);
      return G;
    }
    function l(G, Z) {
      return (G = Ke(G, Z)), (G.index = 0), (G.sibling = null), G;
    }
    function t(G, Z, B) {
      return (
        (G.index = B),
        g
          ? ((B = G.alternate),
            B !== null
              ? ((B = B.index), B < Z ? ((G.flags |= 2), Z) : B)
              : ((G.flags |= 2), Z))
          : ((G.flags |= 1048576), Z)
      );
    }
    function n(G) {
      return g && G.alternate === null && (G.flags |= 2), G;
    }
    function o(G, Z, B, y) {
      return Z === null || Z.tag !== 6
        ? ((Z = _A(B, G.mode, y)), (Z.return = G), Z)
        : ((Z = l(Z, B)), (Z.return = G), Z);
    }
    function A(G, Z, B, y) {
      var h = B.type;
      return h === KC
        ? d(G, Z, B.props.children, y, B.key)
        : Z !== null &&
          (Z.elementType === h ||
            (typeof h == "object" &&
              h !== null &&
              h.$$typeof === pe &&
              sr(h) === Z.type))
        ? ((y = l(Z, B.props)), (y.ref = wl(G, Z, B)), (y.return = G), y)
        : ((y = Ln(B.type, B.key, B.props, null, G.mode, y)),
          (y.ref = wl(G, Z, B)),
          (y.return = G),
          y);
    }
    function c(G, Z, B, y) {
      return Z === null ||
        Z.tag !== 4 ||
        Z.stateNode.containerInfo !== B.containerInfo ||
        Z.stateNode.implementation !== B.implementation
        ? ((Z = qA(B, G.mode, y)), (Z.return = G), Z)
        : ((Z = l(Z, B.children || [])), (Z.return = G), Z);
    }
    function d(G, Z, B, y, h) {
      return Z === null || Z.tag !== 7
        ? ((Z = dC(B, G.mode, y, h)), (Z.return = G), Z)
        : ((Z = l(Z, B)), (Z.return = G), Z);
    }
    function i(G, Z, B) {
      if ((typeof Z == "string" && Z !== "") || typeof Z == "number")
        return (Z = _A("" + Z, G.mode, B)), (Z.return = G), Z;
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case nn:
            return (
              (B = Ln(Z.type, Z.key, Z.props, null, G.mode, B)),
              (B.ref = wl(G, null, Z)),
              (B.return = G),
              B
            );
          case NC:
            return (Z = qA(Z, G.mode, B)), (Z.return = G), Z;
          case pe:
            var y = Z._init;
            return i(G, y(Z._payload), B);
        }
        if (El(Z) || vl(Z))
          return (Z = dC(Z, G.mode, B, null)), (Z.return = G), Z;
        Gn(G, Z);
      }
      return null;
    }
    function r(G, Z, B, y) {
      var h = Z !== null ? Z.key : null;
      if ((typeof B == "string" && B !== "") || typeof B == "number")
        return h !== null ? null : o(G, Z, "" + B, y);
      if (typeof B == "object" && B !== null) {
        switch (B.$$typeof) {
          case nn:
            return B.key === h ? A(G, Z, B, y) : null;
          case NC:
            return B.key === h ? c(G, Z, B, y) : null;
          case pe:
            return (h = B._init), r(G, Z, h(B._payload), y);
        }
        if (El(B) || vl(B)) return h !== null ? null : d(G, Z, B, y, null);
        Gn(G, B);
      }
      return null;
    }
    function u(G, Z, B, y, h) {
      if ((typeof y == "string" && y !== "") || typeof y == "number")
        return (G = G.get(B) || null), o(Z, G, "" + y, h);
      if (typeof y == "object" && y !== null) {
        switch (y.$$typeof) {
          case nn:
            return (
              (G = G.get(y.key === null ? B : y.key) || null), A(Z, G, y, h)
            );
          case NC:
            return (
              (G = G.get(y.key === null ? B : y.key) || null), c(Z, G, y, h)
            );
          case pe:
            var W = y._init;
            return u(G, Z, B, W(y._payload), h);
        }
        if (El(y) || vl(y)) return (G = G.get(B) || null), d(Z, G, y, h, null);
        Gn(Z, y);
      }
      return null;
    }
    function b(G, Z, B, y) {
      for (
        var h = null, W = null, S = Z, V = (Z = 0), f = null;
        S !== null && V < B.length;
        V++
      ) {
        S.index > V ? ((f = S), (S = null)) : (f = S.sibling);
        var k = r(G, S, B[V], y);
        if (k === null) {
          S === null && (S = f);
          break;
        }
        g && S && k.alternate === null && I(G, S),
          (Z = t(k, Z, V)),
          W === null ? (h = k) : (W.sibling = k),
          (W = k),
          (S = f);
      }
      if (V === B.length) return e(G, S), bg && lC(G, V), h;
      if (S === null) {
        for (; V < B.length; V++)
          (S = i(G, B[V], y)),
            S !== null &&
              ((Z = t(S, Z, V)),
              W === null ? (h = S) : (W.sibling = S),
              (W = S));
        return bg && lC(G, V), h;
      }
      for (S = C(G, S); V < B.length; V++)
        (f = u(S, G, V, B[V], y)),
          f !== null &&
            (g && f.alternate !== null && S.delete(f.key === null ? V : f.key),
            (Z = t(f, Z, V)),
            W === null ? (h = f) : (W.sibling = f),
            (W = f));
      return (
        g &&
          S.forEach(function (F) {
            return I(G, F);
          }),
        bg && lC(G, V),
        h
      );
    }
    function m(G, Z, B, y) {
      var h = vl(B);
      if (typeof h != "function") throw Error(J(150));
      if (((B = h.call(B)), B == null)) throw Error(J(151));
      for (
        var W = (h = null), S = Z, V = (Z = 0), f = null, k = B.next();
        S !== null && !k.done;
        V++, k = B.next()
      ) {
        S.index > V ? ((f = S), (S = null)) : (f = S.sibling);
        var F = r(G, S, k.value, y);
        if (F === null) {
          S === null && (S = f);
          break;
        }
        g && S && F.alternate === null && I(G, S),
          (Z = t(F, Z, V)),
          W === null ? (h = F) : (W.sibling = F),
          (W = F),
          (S = f);
      }
      if (k.done) return e(G, S), bg && lC(G, V), h;
      if (S === null) {
        for (; !k.done; V++, k = B.next())
          (k = i(G, k.value, y)),
            k !== null &&
              ((Z = t(k, Z, V)),
              W === null ? (h = k) : (W.sibling = k),
              (W = k));
        return bg && lC(G, V), h;
      }
      for (S = C(G, S); !k.done; V++, k = B.next())
        (k = u(S, G, V, k.value, y)),
          k !== null &&
            (g && k.alternate !== null && S.delete(k.key === null ? V : k.key),
            (Z = t(k, Z, V)),
            W === null ? (h = k) : (W.sibling = k),
            (W = k));
      return (
        g &&
          S.forEach(function (K) {
            return I(G, K);
          }),
        bg && lC(G, V),
        h
      );
    }
    function p(G, Z, B, y) {
      if (
        (typeof B == "object" &&
          B !== null &&
          B.type === KC &&
          B.key === null &&
          (B = B.props.children),
        typeof B == "object" && B !== null)
      ) {
        switch (B.$$typeof) {
          case nn:
            g: {
              for (var h = B.key, W = Z; W !== null; ) {
                if (W.key === h) {
                  if (((h = B.type), h === KC)) {
                    if (W.tag === 7) {
                      e(G, W.sibling),
                        (Z = l(W, B.props.children)),
                        (Z.return = G),
                        (G = Z);
                      break g;
                    }
                  } else if (
                    W.elementType === h ||
                    (typeof h == "object" &&
                      h !== null &&
                      h.$$typeof === pe &&
                      sr(h) === W.type)
                  ) {
                    e(G, W.sibling),
                      (Z = l(W, B.props)),
                      (Z.ref = wl(G, W, B)),
                      (Z.return = G),
                      (G = Z);
                    break g;
                  }
                  e(G, W);
                  break;
                } else I(G, W);
                W = W.sibling;
              }
              B.type === KC
                ? ((Z = dC(B.props.children, G.mode, y, B.key)),
                  (Z.return = G),
                  (G = Z))
                : ((y = Ln(B.type, B.key, B.props, null, G.mode, y)),
                  (y.ref = wl(G, Z, B)),
                  (y.return = G),
                  (G = y));
            }
            return n(G);
          case NC:
            g: {
              for (W = B.key; Z !== null; ) {
                if (Z.key === W)
                  if (
                    Z.tag === 4 &&
                    Z.stateNode.containerInfo === B.containerInfo &&
                    Z.stateNode.implementation === B.implementation
                  ) {
                    e(G, Z.sibling),
                      (Z = l(Z, B.children || [])),
                      (Z.return = G),
                      (G = Z);
                    break g;
                  } else {
                    e(G, Z);
                    break;
                  }
                else I(G, Z);
                Z = Z.sibling;
              }
              (Z = qA(B, G.mode, y)), (Z.return = G), (G = Z);
            }
            return n(G);
          case pe:
            return (W = B._init), p(G, Z, W(B._payload), y);
        }
        if (El(B)) return b(G, Z, B, y);
        if (vl(B)) return m(G, Z, B, y);
        Gn(G, B);
      }
      return (typeof B == "string" && B !== "") || typeof B == "number"
        ? ((B = "" + B),
          Z !== null && Z.tag === 6
            ? (e(G, Z.sibling), (Z = l(Z, B)), (Z.return = G), (G = Z))
            : (e(G, Z), (Z = _A(B, G.mode, y)), (Z.return = G), (G = Z)),
          n(G))
        : e(G, Z);
    }
    return p;
  }
  var cl = Lu(!0),
    Du = Lu(!1),
    co = $e(null),
    io = null,
    LC = null,
    ri = null;
  function si() {
    ri = LC = io = null;
  }
  function ui(g) {
    var I = co.current;
    Zg(co), (g._currentValue = I);
  }
  function jc(g, I, e) {
    for (; g !== null; ) {
      var C = g.alternate;
      if (
        ((g.childLanes & I) !== I
          ? ((g.childLanes |= I), C !== null && (C.childLanes |= I))
          : C !== null && (C.childLanes & I) !== I && (C.childLanes |= I),
        g === e)
      )
        break;
      g = g.return;
    }
  }
  function gl(g, I) {
    (io = g),
      (ri = LC = null),
      (g = g.dependencies),
      g !== null &&
        g.firstContext !== null &&
        (g.lanes & I && (II = !0), (g.firstContext = null));
  }
  function VI(g) {
    var I = g._currentValue;
    if (ri !== g)
      if (((g = { context: g, memoizedValue: I, next: null }), LC === null)) {
        if (io === null) throw Error(J(308));
        (LC = g), (io.dependencies = { lanes: 0, firstContext: g });
      } else LC = LC.next = g;
    return I;
  }
  var oC = null;
  function mi(g) {
    oC === null ? (oC = [g]) : oC.push(g);
  }
  function Tu(g, I, e, C) {
    var l = I.interleaved;
    return (
      l === null ? ((e.next = e), mi(I)) : ((e.next = l.next), (l.next = e)),
      (I.interleaved = e),
      ie(g, C)
    );
  }
  function ie(g, I) {
    g.lanes |= I;
    var e = g.alternate;
    for (e !== null && (e.lanes |= I), e = g, g = g.return; g !== null; )
      (g.childLanes |= I),
        (e = g.alternate),
        e !== null && (e.childLanes |= I),
        (e = g),
        (g = g.return);
    return e.tag === 3 ? e.stateNode : null;
  }
  var ye = !1;
  function Zi(g) {
    g.updateQueue = {
      baseState: g.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function ju(g, I) {
    (g = g.updateQueue),
      I.updateQueue === g &&
        (I.updateQueue = {
          baseState: g.baseState,
          firstBaseUpdate: g.firstBaseUpdate,
          lastBaseUpdate: g.lastBaseUpdate,
          shared: g.shared,
          effects: g.effects,
        });
  }
  function Ae(g, I) {
    return {
      eventTime: g,
      lane: I,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function He(g, I, e) {
    var C = g.updateQueue;
    if (C === null) return null;
    if (((C = C.shared), lg & 2)) {
      var l = C.pending;
      return (
        l === null ? (I.next = I) : ((I.next = l.next), (l.next = I)),
        (C.pending = I),
        ie(g, e)
      );
    }
    return (
      (l = C.interleaved),
      l === null ? ((I.next = I), mi(C)) : ((I.next = l.next), (l.next = I)),
      (C.interleaved = I),
      ie(g, e)
    );
  }
  function xn(g, I, e) {
    if (
      ((I = I.updateQueue), I !== null && ((I = I.shared), (e & 4194240) !== 0))
    ) {
      var C = I.lanes;
      (C &= g.pendingLanes), (e |= C), (I.lanes = e), ei(g, e);
    }
  }
  function ur(g, I) {
    var e = g.updateQueue,
      C = g.alternate;
    if (C !== null && ((C = C.updateQueue), e === C)) {
      var l = null,
        t = null;
      if (((e = e.firstBaseUpdate), e !== null)) {
        do {
          var n = {
            eventTime: e.eventTime,
            lane: e.lane,
            tag: e.tag,
            payload: e.payload,
            callback: e.callback,
            next: null,
          };
          t === null ? (l = t = n) : (t = t.next = n), (e = e.next);
        } while (e !== null);
        t === null ? (l = t = I) : (t = t.next = I);
      } else l = t = I;
      (e = {
        baseState: C.baseState,
        firstBaseUpdate: l,
        lastBaseUpdate: t,
        shared: C.shared,
        effects: C.effects,
      }),
        (g.updateQueue = e);
      return;
    }
    (g = e.lastBaseUpdate),
      g === null ? (e.firstBaseUpdate = I) : (g.next = I),
      (e.lastBaseUpdate = I);
  }
  function ao(g, I, e, C) {
    var l = g.updateQueue;
    ye = !1;
    var t = l.firstBaseUpdate,
      n = l.lastBaseUpdate,
      o = l.shared.pending;
    if (o !== null) {
      l.shared.pending = null;
      var A = o,
        c = A.next;
      (A.next = null), n === null ? (t = c) : (n.next = c), (n = A);
      var d = g.alternate;
      d !== null &&
        ((d = d.updateQueue),
        (o = d.lastBaseUpdate),
        o !== n &&
          (o === null ? (d.firstBaseUpdate = c) : (o.next = c),
          (d.lastBaseUpdate = A)));
    }
    if (t !== null) {
      var i = l.baseState;
      (n = 0), (d = c = A = null), (o = t);
      do {
        var r = o.lane,
          u = o.eventTime;
        if ((C & r) === r) {
          d !== null &&
            (d = d.next =
              {
                eventTime: u,
                lane: 0,
                tag: o.tag,
                payload: o.payload,
                callback: o.callback,
                next: null,
              });
          g: {
            var b = g,
              m = o;
            switch (((r = I), (u = e), m.tag)) {
              case 1:
                if (((b = m.payload), typeof b == "function")) {
                  i = b.call(u, i, r);
                  break g;
                }
                i = b;
                break g;
              case 3:
                b.flags = (b.flags & -65537) | 128;
              case 0:
                if (
                  ((b = m.payload),
                  (r = typeof b == "function" ? b.call(u, i, r) : b),
                  r == null)
                )
                  break g;
                i = hg({}, i, r);
                break g;
              case 2:
                ye = !0;
            }
          }
          o.callback !== null &&
            o.lane !== 0 &&
            ((g.flags |= 64),
            (r = l.effects),
            r === null ? (l.effects = [o]) : r.push(o));
        } else
          (u = {
            eventTime: u,
            lane: r,
            tag: o.tag,
            payload: o.payload,
            callback: o.callback,
            next: null,
          }),
            d === null ? ((c = d = u), (A = i)) : (d = d.next = u),
            (n |= r);
        if (((o = o.next), o === null)) {
          if (((o = l.shared.pending), o === null)) break;
          (r = o),
            (o = r.next),
            (r.next = null),
            (l.lastBaseUpdate = r),
            (l.shared.pending = null);
        }
      } while (!0);
      if (
        (d === null && (A = i),
        (l.baseState = A),
        (l.firstBaseUpdate = c),
        (l.lastBaseUpdate = d),
        (I = l.shared.interleaved),
        I !== null)
      ) {
        l = I;
        do (n |= l.lane), (l = l.next);
        while (l !== I);
      } else t === null && (l.shared.lanes = 0);
      (uC |= n), (g.lanes = n), (g.memoizedState = i);
    }
  }
  function mr(g, I, e) {
    if (((g = I.effects), (I.effects = null), g !== null))
      for (I = 0; I < g.length; I++) {
        var C = g[I],
          l = C.callback;
        if (l !== null) {
          if (((C.callback = null), (C = e), typeof l != "function"))
            throw Error(J(191, l));
          l.call(C);
        }
      }
  }
  var Tt = {},
    jI = $e(Tt),
    mt = $e(Tt),
    Zt = $e(Tt);
  function AC(g) {
    if (g === Tt) throw Error(J(174));
    return g;
  }
  function Gi(g, I) {
    switch ((sg(Zt, I), sg(mt, g), sg(jI, Tt), (g = I.nodeType), g)) {
      case 9:
      case 11:
        I = (I = I.documentElement) ? I.namespaceURI : Xc(null, "");
        break;
      default:
        (g = g === 8 ? I.parentNode : I),
          (I = g.namespaceURI || null),
          (g = g.tagName),
          (I = Xc(I, g));
    }
    Zg(jI), sg(jI, I);
  }
  function dl() {
    Zg(jI), Zg(mt), Zg(Zt);
  }
  function Pu(g) {
    AC(Zt.current);
    var I = AC(jI.current),
      e = Xc(I, g.type);
    I !== e && (sg(mt, g), sg(jI, e));
  }
  function bi(g) {
    mt.current === g && (Zg(jI), Zg(mt));
  }
  var pg = $e(0);
  function ro(g) {
    for (var I = g; I !== null; ) {
      if (I.tag === 13) {
        var e = I.memoizedState;
        if (
          e !== null &&
          ((e = e.dehydrated), e === null || e.data === "$?" || e.data === "$!")
        )
          return I;
      } else if (I.tag === 19 && I.memoizedProps.revealOrder !== void 0) {
        if (I.flags & 128) return I;
      } else if (I.child !== null) {
        (I.child.return = I), (I = I.child);
        continue;
      }
      if (I === g) break;
      for (; I.sibling === null; ) {
        if (I.return === null || I.return === g) return null;
        I = I.return;
      }
      (I.sibling.return = I.return), (I = I.sibling);
    }
    return null;
  }
  var LA = [];
  function Bi() {
    for (var g = 0; g < LA.length; g++)
      LA[g]._workInProgressVersionPrimary = null;
    LA.length = 0;
  }
  var Mn = me.ReactCurrentDispatcher,
    DA = me.ReactCurrentBatchConfig,
    sC = 0,
    yg = null,
    vg = null,
    Yg = null,
    so = !1,
    gt = !1,
    Gt = 0,
    kp = 0;
  function zg() {
    throw Error(J(321));
  }
  function pi(g, I) {
    if (I === null) return !1;
    for (var e = 0; e < I.length && e < g.length; e++)
      if (!FI(g[e], I[e])) return !1;
    return !0;
  }
  function yi(g, I, e, C, l, t) {
    if (
      ((sC = t),
      (yg = I),
      (I.memoizedState = null),
      (I.updateQueue = null),
      (I.lanes = 0),
      (Mn.current = g === null || g.memoizedState === null ? wp : Np),
      (g = e(C, l)),
      gt)
    ) {
      t = 0;
      do {
        if (((gt = !1), (Gt = 0), 25 <= t)) throw Error(J(301));
        (t += 1),
          (Yg = vg = null),
          (I.updateQueue = null),
          (Mn.current = Kp),
          (g = e(C, l));
      } while (gt);
    }
    if (
      ((Mn.current = uo),
      (I = vg !== null && vg.next !== null),
      (sC = 0),
      (Yg = vg = yg = null),
      (so = !1),
      I)
    )
      throw Error(J(300));
    return g;
  }
  function hi() {
    var g = Gt !== 0;
    return (Gt = 0), g;
  }
  function QI() {
    var g = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Yg === null ? (yg.memoizedState = Yg = g) : (Yg = Yg.next = g), Yg;
  }
  function WI() {
    if (vg === null) {
      var g = yg.alternate;
      g = g !== null ? g.memoizedState : null;
    } else g = vg.next;
    var I = Yg === null ? yg.memoizedState : Yg.next;
    if (I !== null) (Yg = I), (vg = g);
    else {
      if (g === null) throw Error(J(310));
      (vg = g),
        (g = {
          memoizedState: vg.memoizedState,
          baseState: vg.baseState,
          baseQueue: vg.baseQueue,
          queue: vg.queue,
          next: null,
        }),
        Yg === null ? (yg.memoizedState = Yg = g) : (Yg = Yg.next = g);
    }
    return Yg;
  }
  function bt(g, I) {
    return typeof I == "function" ? I(g) : I;
  }
  function TA(g) {
    var I = WI(),
      e = I.queue;
    if (e === null) throw Error(J(311));
    e.lastRenderedReducer = g;
    var C = vg,
      l = C.baseQueue,
      t = e.pending;
    if (t !== null) {
      if (l !== null) {
        var n = l.next;
        (l.next = t.next), (t.next = n);
      }
      (C.baseQueue = l = t), (e.pending = null);
    }
    if (l !== null) {
      (t = l.next), (C = C.baseState);
      var o = (n = null),
        A = null,
        c = t;
      do {
        var d = c.lane;
        if ((sC & d) === d)
          A !== null &&
            (A = A.next =
              {
                lane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null,
              }),
            (C = c.hasEagerState ? c.eagerState : g(C, c.action));
        else {
          var i = {
            lane: d,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null,
          };
          A === null ? ((o = A = i), (n = C)) : (A = A.next = i),
            (yg.lanes |= d),
            (uC |= d);
        }
        c = c.next;
      } while (c !== null && c !== t);
      A === null ? (n = C) : (A.next = o),
        FI(C, I.memoizedState) || (II = !0),
        (I.memoizedState = C),
        (I.baseState = n),
        (I.baseQueue = A),
        (e.lastRenderedState = C);
    }
    if (((g = e.interleaved), g !== null)) {
      l = g;
      do (t = l.lane), (yg.lanes |= t), (uC |= t), (l = l.next);
      while (l !== g);
    } else l === null && (e.lanes = 0);
    return [I.memoizedState, e.dispatch];
  }
  function jA(g) {
    var I = WI(),
      e = I.queue;
    if (e === null) throw Error(J(311));
    e.lastRenderedReducer = g;
    var C = e.dispatch,
      l = e.pending,
      t = I.memoizedState;
    if (l !== null) {
      e.pending = null;
      var n = (l = l.next);
      do (t = g(t, n.action)), (n = n.next);
      while (n !== l);
      FI(t, I.memoizedState) || (II = !0),
        (I.memoizedState = t),
        I.baseQueue === null && (I.baseState = t),
        (e.lastRenderedState = t);
    }
    return [t, C];
  }
  function Ou() {}
  function _u(g, I) {
    var e = yg,
      C = WI(),
      l = I(),
      t = !FI(C.memoizedState, l);
    if (
      (t && ((C.memoizedState = l), (II = !0)),
      (C = C.queue),
      Si(gm.bind(null, e, C, g), [g]),
      C.getSnapshot !== I || t || (Yg !== null && Yg.memoizedState.tag & 1))
    ) {
      if (
        ((e.flags |= 2048),
        Bt(9, $u.bind(null, e, C, l, I), void 0, null),
        Hg === null)
      )
        throw Error(J(349));
      sC & 30 || qu(e, I, l);
    }
    return l;
  }
  function qu(g, I, e) {
    (g.flags |= 16384),
      (g = { getSnapshot: I, value: e }),
      (I = yg.updateQueue),
      I === null
        ? ((I = { lastEffect: null, stores: null }),
          (yg.updateQueue = I),
          (I.stores = [g]))
        : ((e = I.stores), e === null ? (I.stores = [g]) : e.push(g));
  }
  function $u(g, I, e, C) {
    (I.value = e), (I.getSnapshot = C), Im(I) && em(g);
  }
  function gm(g, I, e) {
    return e(function () {
      Im(I) && em(g);
    });
  }
  function Im(g) {
    var I = g.getSnapshot;
    g = g.value;
    try {
      var e = I();
      return !FI(g, e);
    } catch {
      return !0;
    }
  }
  function em(g) {
    var I = ie(g, 1);
    I !== null && wI(I, g, 1, -1);
  }
  function Zr(g) {
    var I = QI();
    return (
      typeof g == "function" && (g = g()),
      (I.memoizedState = I.baseState = g),
      (g = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: bt,
        lastRenderedState: g,
      }),
      (I.queue = g),
      (g = g.dispatch = Hp.bind(null, yg, g)),
      [I.memoizedState, g]
    );
  }
  function Bt(g, I, e, C) {
    return (
      (g = { tag: g, create: I, destroy: e, deps: C, next: null }),
      (I = yg.updateQueue),
      I === null
        ? ((I = { lastEffect: null, stores: null }),
          (yg.updateQueue = I),
          (I.lastEffect = g.next = g))
        : ((e = I.lastEffect),
          e === null
            ? (I.lastEffect = g.next = g)
            : ((C = e.next), (e.next = g), (g.next = C), (I.lastEffect = g))),
      g
    );
  }
  function Cm() {
    return WI().memoizedState;
  }
  function zn(g, I, e, C) {
    var l = QI();
    (yg.flags |= g),
      (l.memoizedState = Bt(1 | I, e, void 0, C === void 0 ? null : C));
  }
  function Do(g, I, e, C) {
    var l = WI();
    C = C === void 0 ? null : C;
    var t = void 0;
    if (vg !== null) {
      var n = vg.memoizedState;
      if (((t = n.destroy), C !== null && pi(C, n.deps))) {
        l.memoizedState = Bt(I, e, t, C);
        return;
      }
    }
    (yg.flags |= g), (l.memoizedState = Bt(1 | I, e, t, C));
  }
  function Gr(g, I) {
    return zn(8390656, 8, g, I);
  }
  function Si(g, I) {
    return Do(2048, 8, g, I);
  }
  function lm(g, I) {
    return Do(4, 2, g, I);
  }
  function tm(g, I) {
    return Do(4, 4, g, I);
  }
  function nm(g, I) {
    if (typeof I == "function")
      return (
        (g = g()),
        I(g),
        function () {
          I(null);
        }
      );
    if (I != null)
      return (
        (g = g()),
        (I.current = g),
        function () {
          I.current = null;
        }
      );
  }
  function om(g, I, e) {
    return (
      (e = e != null ? e.concat([g]) : null), Do(4, 4, nm.bind(null, I, g), e)
    );
  }
  function Vi() {}
  function Am(g, I) {
    var e = WI();
    I = I === void 0 ? null : I;
    var C = e.memoizedState;
    return C !== null && I !== null && pi(I, C[1])
      ? C[0]
      : ((e.memoizedState = [g, I]), g);
  }
  function cm(g, I) {
    var e = WI();
    I = I === void 0 ? null : I;
    var C = e.memoizedState;
    return C !== null && I !== null && pi(I, C[1])
      ? C[0]
      : ((g = g()), (e.memoizedState = [g, I]), g);
  }
  function dm(g, I, e) {
    return sC & 21
      ? (FI(e, I) ||
          ((e = uu()), (yg.lanes |= e), (uC |= e), (g.baseState = !0)),
        I)
      : (g.baseState && ((g.baseState = !1), (II = !0)), (g.memoizedState = e));
  }
  function fp(g, I) {
    var e = Ag;
    (Ag = e !== 0 && 4 > e ? e : 4), g(!0);
    var C = DA.transition;
    DA.transition = {};
    try {
      g(!1), I();
    } finally {
      (Ag = e), (DA.transition = C);
    }
  }
  function im() {
    return WI().memoizedState;
  }
  function Yp(g, I, e) {
    var C = Ne(g);
    if (
      ((e = {
        lane: C,
        action: e,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      am(g))
    )
      rm(I, e);
    else if (((e = Tu(g, I, e, C)), e !== null)) {
      var l = Pg();
      wI(e, g, C, l), sm(e, I, C);
    }
  }
  function Hp(g, I, e) {
    var C = Ne(g),
      l = {
        lane: C,
        action: e,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (am(g)) rm(I, l);
    else {
      var t = g.alternate;
      if (
        g.lanes === 0 &&
        (t === null || t.lanes === 0) &&
        ((t = I.lastRenderedReducer), t !== null)
      )
        try {
          var n = I.lastRenderedState,
            o = t(n, e);
          if (((l.hasEagerState = !0), (l.eagerState = o), FI(o, n))) {
            var A = I.interleaved;
            A === null
              ? ((l.next = l), mi(I))
              : ((l.next = A.next), (A.next = l)),
              (I.interleaved = l);
            return;
          }
        } catch {
        } finally {
        }
      (e = Tu(g, I, l, C)),
        e !== null && ((l = Pg()), wI(e, g, C, l), sm(e, I, C));
    }
  }
  function am(g) {
    var I = g.alternate;
    return g === yg || (I !== null && I === yg);
  }
  function rm(g, I) {
    gt = so = !0;
    var e = g.pending;
    e === null ? (I.next = I) : ((I.next = e.next), (e.next = I)),
      (g.pending = I);
  }
  function sm(g, I, e) {
    if (e & 4194240) {
      var C = I.lanes;
      (C &= g.pendingLanes), (e |= C), (I.lanes = e), ei(g, e);
    }
  }
  var uo = {
      readContext: VI,
      useCallback: zg,
      useContext: zg,
      useEffect: zg,
      useImperativeHandle: zg,
      useInsertionEffect: zg,
      useLayoutEffect: zg,
      useMemo: zg,
      useReducer: zg,
      useRef: zg,
      useState: zg,
      useDebugValue: zg,
      useDeferredValue: zg,
      useTransition: zg,
      useMutableSource: zg,
      useSyncExternalStore: zg,
      useId: zg,
      unstable_isNewReconciler: !1,
    },
    wp = {
      readContext: VI,
      useCallback: function (g, I) {
        return (QI().memoizedState = [g, I === void 0 ? null : I]), g;
      },
      useContext: VI,
      useEffect: Gr,
      useImperativeHandle: function (g, I, e) {
        return (
          (e = e != null ? e.concat([g]) : null),
          zn(4194308, 4, nm.bind(null, I, g), e)
        );
      },
      useLayoutEffect: function (g, I) {
        return zn(4194308, 4, g, I);
      },
      useInsertionEffect: function (g, I) {
        return zn(4, 2, g, I);
      },
      useMemo: function (g, I) {
        var e = QI();
        return (
          (I = I === void 0 ? null : I),
          (g = g()),
          (e.memoizedState = [g, I]),
          g
        );
      },
      useReducer: function (g, I, e) {
        var C = QI();
        return (
          (I = e !== void 0 ? e(I) : I),
          (C.memoizedState = C.baseState = I),
          (g = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: g,
            lastRenderedState: I,
          }),
          (C.queue = g),
          (g = g.dispatch = Yp.bind(null, yg, g)),
          [C.memoizedState, g]
        );
      },
      useRef: function (g) {
        var I = QI();
        return (g = { current: g }), (I.memoizedState = g);
      },
      useState: Zr,
      useDebugValue: Vi,
      useDeferredValue: function (g) {
        return (QI().memoizedState = g);
      },
      useTransition: function () {
        var g = Zr(!1),
          I = g[0];
        return (g = fp.bind(null, g[1])), (QI().memoizedState = g), [I, g];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (g, I, e) {
        var C = yg,
          l = QI();
        if (bg) {
          if (e === void 0) throw Error(J(407));
          e = e();
        } else {
          if (((e = I()), Hg === null)) throw Error(J(349));
          sC & 30 || qu(C, I, e);
        }
        l.memoizedState = e;
        var t = { value: e, getSnapshot: I };
        return (
          (l.queue = t),
          Gr(gm.bind(null, C, t, g), [g]),
          (C.flags |= 2048),
          Bt(9, $u.bind(null, C, t, e, I), void 0, null),
          e
        );
      },
      useId: function () {
        var g = QI(),
          I = Hg.identifierPrefix;
        if (bg) {
          var e = oe,
            C = ne;
          (e = (C & ~(1 << (32 - HI(C) - 1))).toString(32) + e),
            (I = ":" + I + "R" + e),
            (e = Gt++),
            0 < e && (I += "H" + e.toString(32)),
            (I += ":");
        } else (e = kp++), (I = ":" + I + "r" + e.toString(32) + ":");
        return (g.memoizedState = I);
      },
      unstable_isNewReconciler: !1,
    },
    Np = {
      readContext: VI,
      useCallback: Am,
      useContext: VI,
      useEffect: Si,
      useImperativeHandle: om,
      useInsertionEffect: lm,
      useLayoutEffect: tm,
      useMemo: cm,
      useReducer: TA,
      useRef: Cm,
      useState: function () {
        return TA(bt);
      },
      useDebugValue: Vi,
      useDeferredValue: function (g) {
        var I = WI();
        return dm(I, vg.memoizedState, g);
      },
      useTransition: function () {
        var g = TA(bt)[0],
          I = WI().memoizedState;
        return [g, I];
      },
      useMutableSource: Ou,
      useSyncExternalStore: _u,
      useId: im,
      unstable_isNewReconciler: !1,
    },
    Kp = {
      readContext: VI,
      useCallback: Am,
      useContext: VI,
      useEffect: Si,
      useImperativeHandle: om,
      useInsertionEffect: lm,
      useLayoutEffect: tm,
      useMemo: cm,
      useReducer: jA,
      useRef: Cm,
      useState: function () {
        return jA(bt);
      },
      useDebugValue: Vi,
      useDeferredValue: function (g) {
        var I = WI();
        return vg === null ? (I.memoizedState = g) : dm(I, vg.memoizedState, g);
      },
      useTransition: function () {
        var g = jA(bt)[0],
          I = WI().memoizedState;
        return [g, I];
      },
      useMutableSource: Ou,
      useSyncExternalStore: _u,
      useId: im,
      unstable_isNewReconciler: !1,
    };
  function vI(g, I) {
    if (g && g.defaultProps) {
      (I = hg({}, I)), (g = g.defaultProps);
      for (var e in g) I[e] === void 0 && (I[e] = g[e]);
      return I;
    }
    return I;
  }
  function Pc(g, I, e, C) {
    (I = g.memoizedState),
      (e = e(C, I)),
      (e = e == null ? I : hg({}, I, e)),
      (g.memoizedState = e),
      g.lanes === 0 && (g.updateQueue.baseState = e);
  }
  var To = {
    isMounted: function (g) {
      return (g = g._reactInternals) ? SC(g) === g : !1;
    },
    enqueueSetState: function (g, I, e) {
      g = g._reactInternals;
      var C = Pg(),
        l = Ne(g),
        t = Ae(C, l);
      (t.payload = I),
        e != null && (t.callback = e),
        (I = He(g, t, l)),
        I !== null && (wI(I, g, l, C), xn(I, g, l));
    },
    enqueueReplaceState: function (g, I, e) {
      g = g._reactInternals;
      var C = Pg(),
        l = Ne(g),
        t = Ae(C, l);
      (t.tag = 1),
        (t.payload = I),
        e != null && (t.callback = e),
        (I = He(g, t, l)),
        I !== null && (wI(I, g, l, C), xn(I, g, l));
    },
    enqueueForceUpdate: function (g, I) {
      g = g._reactInternals;
      var e = Pg(),
        C = Ne(g),
        l = Ae(e, C);
      (l.tag = 2),
        I != null && (l.callback = I),
        (I = He(g, l, C)),
        I !== null && (wI(I, g, C, e), xn(I, g, C));
    },
  };
  function br(g, I, e, C, l, t, n) {
    return (
      (g = g.stateNode),
      typeof g.shouldComponentUpdate == "function"
        ? g.shouldComponentUpdate(C, t, n)
        : I.prototype && I.prototype.isPureReactComponent
        ? !at(e, C) || !at(l, t)
        : !0
    );
  }
  function um(g, I, e) {
    var C = !1,
      l = ze,
      t = I.contextType;
    return (
      typeof t == "object" && t !== null
        ? (t = VI(t))
        : ((l = CI(I) ? aC : Lg.current),
          (C = I.contextTypes),
          (t = (C = C != null) ? ol(g, l) : ze)),
      (I = new I(e, t)),
      (g.memoizedState =
        I.state !== null && I.state !== void 0 ? I.state : null),
      (I.updater = To),
      (g.stateNode = I),
      (I._reactInternals = g),
      C &&
        ((g = g.stateNode),
        (g.__reactInternalMemoizedUnmaskedChildContext = l),
        (g.__reactInternalMemoizedMaskedChildContext = t)),
      I
    );
  }
  function Br(g, I, e, C) {
    (g = I.state),
      typeof I.componentWillReceiveProps == "function" &&
        I.componentWillReceiveProps(e, C),
      typeof I.UNSAFE_componentWillReceiveProps == "function" &&
        I.UNSAFE_componentWillReceiveProps(e, C),
      I.state !== g && To.enqueueReplaceState(I, I.state, null);
  }
  function Oc(g, I, e, C) {
    var l = g.stateNode;
    (l.props = e), (l.state = g.memoizedState), (l.refs = {}), Zi(g);
    var t = I.contextType;
    typeof t == "object" && t !== null
      ? (l.context = VI(t))
      : ((t = CI(I) ? aC : Lg.current), (l.context = ol(g, t))),
      (l.state = g.memoizedState),
      (t = I.getDerivedStateFromProps),
      typeof t == "function" && (Pc(g, I, t, e), (l.state = g.memoizedState)),
      typeof I.getDerivedStateFromProps == "function" ||
        typeof l.getSnapshotBeforeUpdate == "function" ||
        (typeof l.UNSAFE_componentWillMount != "function" &&
          typeof l.componentWillMount != "function") ||
        ((I = l.state),
        typeof l.componentWillMount == "function" && l.componentWillMount(),
        typeof l.UNSAFE_componentWillMount == "function" &&
          l.UNSAFE_componentWillMount(),
        I !== l.state && To.enqueueReplaceState(l, l.state, null),
        ao(g, e, l, C),
        (l.state = g.memoizedState)),
      typeof l.componentDidMount == "function" && (g.flags |= 4194308);
  }
  function il(g, I) {
    try {
      var e = "",
        C = I;
      do (e += iB(C)), (C = C.return);
      while (C);
      var l = e;
    } catch (t) {
      l =
        `
Error generating stack: ` +
        t.message +
        `
` +
        t.stack;
    }
    return { value: g, source: I, stack: l, digest: null };
  }
  function PA(g, I, e) {
    return { value: g, source: null, stack: e ?? null, digest: I ?? null };
  }
  function _c(g, I) {
    try {
      console.error(I.value);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }
  var Fp = typeof WeakMap == "function" ? WeakMap : Map;
  function mm(g, I, e) {
    (e = Ae(-1, e)), (e.tag = 3), (e.payload = { element: null });
    var C = I.value;
    return (
      (e.callback = function () {
        Zo || ((Zo = !0), (od = C)), _c(g, I);
      }),
      e
    );
  }
  function Zm(g, I, e) {
    (e = Ae(-1, e)), (e.tag = 3);
    var C = g.type.getDerivedStateFromError;
    if (typeof C == "function") {
      var l = I.value;
      (e.payload = function () {
        return C(l);
      }),
        (e.callback = function () {
          _c(g, I);
        });
    }
    var t = g.stateNode;
    return (
      t !== null &&
        typeof t.componentDidCatch == "function" &&
        (e.callback = function () {
          _c(g, I),
            typeof C != "function" &&
              (we === null ? (we = new Set([this])) : we.add(this));
          var n = I.stack;
          this.componentDidCatch(I.value, {
            componentStack: n !== null ? n : "",
          });
        }),
      e
    );
  }
  function pr(g, I, e) {
    var C = g.pingCache;
    if (C === null) {
      C = g.pingCache = new Fp();
      var l = new Set();
      C.set(I, l);
    } else (l = C.get(I)), l === void 0 && ((l = new Set()), C.set(I, l));
    l.has(e) || (l.add(e), (g = qp.bind(null, g, I, e)), I.then(g, g));
  }
  function yr(g) {
    do {
      var I;
      if (
        ((I = g.tag === 13) &&
          ((I = g.memoizedState),
          (I = I !== null ? I.dehydrated !== null : !0)),
        I)
      )
        return g;
      g = g.return;
    } while (g !== null);
    return null;
  }
  function hr(g, I, e, C, l) {
    return g.mode & 1
      ? ((g.flags |= 65536), (g.lanes = l), g)
      : (g === I
          ? (g.flags |= 65536)
          : ((g.flags |= 128),
            (e.flags |= 131072),
            (e.flags &= -52805),
            e.tag === 1 &&
              (e.alternate === null
                ? (e.tag = 17)
                : ((I = Ae(-1, 1)), (I.tag = 2), He(e, I, 1))),
            (e.lanes |= 1)),
        g);
  }
  var xp = me.ReactCurrentOwner,
    II = !1;
  function jg(g, I, e, C) {
    I.child = g === null ? Du(I, null, e, C) : cl(I, g.child, e, C);
  }
  function Sr(g, I, e, C, l) {
    e = e.render;
    var t = I.ref;
    return (
      gl(I, l),
      (C = yi(g, I, e, C, t, l)),
      (e = hi()),
      g !== null && !II
        ? ((I.updateQueue = g.updateQueue),
          (I.flags &= -2053),
          (g.lanes &= ~l),
          ae(g, I, l))
        : (bg && e && di(I), (I.flags |= 1), jg(g, I, C, l), I.child)
    );
  }
  function Vr(g, I, e, C, l) {
    if (g === null) {
      var t = e.type;
      return typeof t == "function" &&
        !Yi(t) &&
        t.defaultProps === void 0 &&
        e.compare === null &&
        e.defaultProps === void 0
        ? ((I.tag = 15), (I.type = t), Gm(g, I, t, C, l))
        : ((g = Ln(e.type, null, C, I, I.mode, l)),
          (g.ref = I.ref),
          (g.return = I),
          (I.child = g));
    }
    if (((t = g.child), !(g.lanes & l))) {
      var n = t.memoizedProps;
      if (
        ((e = e.compare), (e = e !== null ? e : at), e(n, C) && g.ref === I.ref)
      )
        return ae(g, I, l);
    }
    return (
      (I.flags |= 1),
      (g = Ke(t, C)),
      (g.ref = I.ref),
      (g.return = I),
      (I.child = g)
    );
  }
  function Gm(g, I, e, C, l) {
    if (g !== null) {
      var t = g.memoizedProps;
      if (at(t, C) && g.ref === I.ref)
        if (((II = !1), (I.pendingProps = C = t), (g.lanes & l) !== 0))
          g.flags & 131072 && (II = !0);
        else return (I.lanes = g.lanes), ae(g, I, l);
    }
    return qc(g, I, e, C, l);
  }
  function bm(g, I, e) {
    var C = I.pendingProps,
      l = C.children,
      t = g !== null ? g.memoizedState : null;
    if (C.mode === "hidden")
      if (!(I.mode & 1))
        (I.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          sg(TC, AI),
          (AI |= e);
      else {
        if (!(e & 1073741824))
          return (
            (g = t !== null ? t.baseLanes | e : e),
            (I.lanes = I.childLanes = 1073741824),
            (I.memoizedState = {
              baseLanes: g,
              cachePool: null,
              transitions: null,
            }),
            (I.updateQueue = null),
            sg(TC, AI),
            (AI |= g),
            null
          );
        (I.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (C = t !== null ? t.baseLanes : e),
          sg(TC, AI),
          (AI |= C);
      }
    else
      t !== null ? ((C = t.baseLanes | e), (I.memoizedState = null)) : (C = e),
        sg(TC, AI),
        (AI |= C);
    return jg(g, I, l, e), I.child;
  }
  function Bm(g, I) {
    var e = I.ref;
    ((g === null && e !== null) || (g !== null && g.ref !== e)) &&
      ((I.flags |= 512), (I.flags |= 2097152));
  }
  function qc(g, I, e, C, l) {
    var t = CI(e) ? aC : Lg.current;
    return (
      (t = ol(I, t)),
      gl(I, l),
      (e = yi(g, I, e, C, t, l)),
      (C = hi()),
      g !== null && !II
        ? ((I.updateQueue = g.updateQueue),
          (I.flags &= -2053),
          (g.lanes &= ~l),
          ae(g, I, l))
        : (bg && C && di(I), (I.flags |= 1), jg(g, I, e, l), I.child)
    );
  }
  function Wr(g, I, e, C, l) {
    if (CI(e)) {
      var t = !0;
      no(I);
    } else t = !1;
    if ((gl(I, l), I.stateNode === null))
      En(g, I), um(I, e, C), Oc(I, e, C, l), (C = !0);
    else if (g === null) {
      var n = I.stateNode,
        o = I.memoizedProps;
      n.props = o;
      var A = n.context,
        c = e.contextType;
      typeof c == "object" && c !== null
        ? (c = VI(c))
        : ((c = CI(e) ? aC : Lg.current), (c = ol(I, c)));
      var d = e.getDerivedStateFromProps,
        i =
          typeof d == "function" ||
          typeof n.getSnapshotBeforeUpdate == "function";
      i ||
        (typeof n.UNSAFE_componentWillReceiveProps != "function" &&
          typeof n.componentWillReceiveProps != "function") ||
        ((o !== C || A !== c) && Br(I, n, C, c)),
        (ye = !1);
      var r = I.memoizedState;
      (n.state = r),
        ao(I, C, n, l),
        (A = I.memoizedState),
        o !== C || r !== A || eI.current || ye
          ? (typeof d == "function" && (Pc(I, e, d, C), (A = I.memoizedState)),
            (o = ye || br(I, e, o, C, r, A, c))
              ? (i ||
                  (typeof n.UNSAFE_componentWillMount != "function" &&
                    typeof n.componentWillMount != "function") ||
                  (typeof n.componentWillMount == "function" &&
                    n.componentWillMount(),
                  typeof n.UNSAFE_componentWillMount == "function" &&
                    n.UNSAFE_componentWillMount()),
                typeof n.componentDidMount == "function" &&
                  (I.flags |= 4194308))
              : (typeof n.componentDidMount == "function" &&
                  (I.flags |= 4194308),
                (I.memoizedProps = C),
                (I.memoizedState = A)),
            (n.props = C),
            (n.state = A),
            (n.context = c),
            (C = o))
          : (typeof n.componentDidMount == "function" && (I.flags |= 4194308),
            (C = !1));
    } else {
      (n = I.stateNode),
        ju(g, I),
        (o = I.memoizedProps),
        (c = I.type === I.elementType ? o : vI(I.type, o)),
        (n.props = c),
        (i = I.pendingProps),
        (r = n.context),
        (A = e.contextType),
        typeof A == "object" && A !== null
          ? (A = VI(A))
          : ((A = CI(e) ? aC : Lg.current), (A = ol(I, A)));
      var u = e.getDerivedStateFromProps;
      (d =
        typeof u == "function" ||
        typeof n.getSnapshotBeforeUpdate == "function") ||
        (typeof n.UNSAFE_componentWillReceiveProps != "function" &&
          typeof n.componentWillReceiveProps != "function") ||
        ((o !== i || r !== A) && Br(I, n, C, A)),
        (ye = !1),
        (r = I.memoizedState),
        (n.state = r),
        ao(I, C, n, l);
      var b = I.memoizedState;
      o !== i || r !== b || eI.current || ye
        ? (typeof u == "function" && (Pc(I, e, u, C), (b = I.memoizedState)),
          (c = ye || br(I, e, c, C, r, b, A) || !1)
            ? (d ||
                (typeof n.UNSAFE_componentWillUpdate != "function" &&
                  typeof n.componentWillUpdate != "function") ||
                (typeof n.componentWillUpdate == "function" &&
                  n.componentWillUpdate(C, b, A),
                typeof n.UNSAFE_componentWillUpdate == "function" &&
                  n.UNSAFE_componentWillUpdate(C, b, A)),
              typeof n.componentDidUpdate == "function" && (I.flags |= 4),
              typeof n.getSnapshotBeforeUpdate == "function" &&
                (I.flags |= 1024))
            : (typeof n.componentDidUpdate != "function" ||
                (o === g.memoizedProps && r === g.memoizedState) ||
                (I.flags |= 4),
              typeof n.getSnapshotBeforeUpdate != "function" ||
                (o === g.memoizedProps && r === g.memoizedState) ||
                (I.flags |= 1024),
              (I.memoizedProps = C),
              (I.memoizedState = b)),
          (n.props = C),
          (n.state = b),
          (n.context = A),
          (C = c))
        : (typeof n.componentDidUpdate != "function" ||
            (o === g.memoizedProps && r === g.memoizedState) ||
            (I.flags |= 4),
          typeof n.getSnapshotBeforeUpdate != "function" ||
            (o === g.memoizedProps && r === g.memoizedState) ||
            (I.flags |= 1024),
          (C = !1));
    }
    return $c(g, I, e, C, t, l);
  }
  function $c(g, I, e, C, l, t) {
    Bm(g, I);
    var n = (I.flags & 128) !== 0;
    if (!C && !n) return l && ir(I, e, !1), ae(g, I, t);
    (C = I.stateNode), (xp.current = I);
    var o =
      n && typeof e.getDerivedStateFromError != "function" ? null : C.render();
    return (
      (I.flags |= 1),
      g !== null && n
        ? ((I.child = cl(I, g.child, null, t)), (I.child = cl(I, null, o, t)))
        : jg(g, I, o, t),
      (I.memoizedState = C.state),
      l && ir(I, e, !0),
      I.child
    );
  }
  function pm(g) {
    var I = g.stateNode;
    I.pendingContext
      ? dr(g, I.pendingContext, I.pendingContext !== I.context)
      : I.context && dr(g, I.context, !1),
      Gi(g, I.containerInfo);
  }
  function Rr(g, I, e, C, l) {
    return Al(), ai(l), (I.flags |= 256), jg(g, I, e, C), I.child;
  }
  var gd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Id(g) {
    return { baseLanes: g, cachePool: null, transitions: null };
  }
  function ym(g, I, e) {
    var C = I.pendingProps,
      l = pg.current,
      t = !1,
      n = (I.flags & 128) !== 0,
      o;
    if (
      ((o = n) ||
        (o = g !== null && g.memoizedState === null ? !1 : (l & 2) !== 0),
      o
        ? ((t = !0), (I.flags &= -129))
        : (g === null || g.memoizedState !== null) && (l |= 1),
      sg(pg, l & 1),
      g === null)
    )
      return (
        Tc(I),
        (g = I.memoizedState),
        g !== null && ((g = g.dehydrated), g !== null)
          ? (I.mode & 1
              ? g.data === "$!"
                ? (I.lanes = 8)
                : (I.lanes = 1073741824)
              : (I.lanes = 1),
            null)
          : ((n = C.children),
            (g = C.fallback),
            t
              ? ((C = I.mode),
                (t = I.child),
                (n = { mode: "hidden", children: n }),
                !(C & 1) && t !== null
                  ? ((t.childLanes = 0), (t.pendingProps = n))
                  : (t = Oo(n, C, 0, null)),
                (g = dC(g, C, e, null)),
                (t.return = I),
                (g.return = I),
                (t.sibling = g),
                (I.child = t),
                (I.child.memoizedState = Id(e)),
                (I.memoizedState = gd),
                g)
              : Wi(I, n))
      );
    if (((l = g.memoizedState), l !== null && ((o = l.dehydrated), o !== null)))
      return Mp(g, I, n, C, o, l, e);
    if (t) {
      (t = C.fallback), (n = I.mode), (l = g.child), (o = l.sibling);
      var A = { mode: "hidden", children: C.children };
      return (
        !(n & 1) && I.child !== l
          ? ((C = I.child),
            (C.childLanes = 0),
            (C.pendingProps = A),
            (I.deletions = null))
          : ((C = Ke(l, A)), (C.subtreeFlags = l.subtreeFlags & 14680064)),
        o !== null ? (t = Ke(o, t)) : ((t = dC(t, n, e, null)), (t.flags |= 2)),
        (t.return = I),
        (C.return = I),
        (C.sibling = t),
        (I.child = C),
        (C = t),
        (t = I.child),
        (n = g.child.memoizedState),
        (n =
          n === null
            ? Id(e)
            : {
                baseLanes: n.baseLanes | e,
                cachePool: null,
                transitions: n.transitions,
              }),
        (t.memoizedState = n),
        (t.childLanes = g.childLanes & ~e),
        (I.memoizedState = gd),
        C
      );
    }
    return (
      (t = g.child),
      (g = t.sibling),
      (C = Ke(t, { mode: "visible", children: C.children })),
      !(I.mode & 1) && (C.lanes = e),
      (C.return = I),
      (C.sibling = null),
      g !== null &&
        ((e = I.deletions),
        e === null ? ((I.deletions = [g]), (I.flags |= 16)) : e.push(g)),
      (I.child = C),
      (I.memoizedState = null),
      C
    );
  }
  function Wi(g, I) {
    return (
      (I = Oo({ mode: "visible", children: I }, g.mode, 0, null)),
      (I.return = g),
      (g.child = I)
    );
  }
  function bn(g, I, e, C) {
    return (
      C !== null && ai(C),
      cl(I, g.child, null, e),
      (g = Wi(I, I.pendingProps.children)),
      (g.flags |= 2),
      (I.memoizedState = null),
      g
    );
  }
  function Mp(g, I, e, C, l, t, n) {
    if (e)
      return I.flags & 256
        ? ((I.flags &= -257), (C = PA(Error(J(422)))), bn(g, I, n, C))
        : I.memoizedState !== null
        ? ((I.child = g.child), (I.flags |= 128), null)
        : ((t = C.fallback),
          (l = I.mode),
          (C = Oo({ mode: "visible", children: C.children }, l, 0, null)),
          (t = dC(t, l, n, null)),
          (t.flags |= 2),
          (C.return = I),
          (t.return = I),
          (C.sibling = t),
          (I.child = C),
          I.mode & 1 && cl(I, g.child, null, n),
          (I.child.memoizedState = Id(n)),
          (I.memoizedState = gd),
          t);
    if (!(I.mode & 1)) return bn(g, I, n, null);
    if (l.data === "$!") {
      if (((C = l.nextSibling && l.nextSibling.dataset), C)) var o = C.dgst;
      return (
        (C = o), (t = Error(J(419))), (C = PA(t, C, void 0)), bn(g, I, n, C)
      );
    }
    if (((o = (n & g.childLanes) !== 0), II || o)) {
      if (((C = Hg), C !== null)) {
        switch (n & -n) {
          case 4:
            l = 2;
            break;
          case 16:
            l = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            l = 32;
            break;
          case 536870912:
            l = 268435456;
            break;
          default:
            l = 0;
        }
        (l = l & (C.suspendedLanes | n) ? 0 : l),
          l !== 0 &&
            l !== t.retryLane &&
            ((t.retryLane = l), ie(g, l), wI(C, g, l, -1));
      }
      return fi(), (C = PA(Error(J(421)))), bn(g, I, n, C);
    }
    return l.data === "$?"
      ? ((I.flags |= 128),
        (I.child = g.child),
        (I = $p.bind(null, g)),
        (l._reactRetry = I),
        null)
      : ((g = t.treeContext),
        (iI = Ye(l.nextSibling)),
        (aI = I),
        (bg = !0),
        (fI = null),
        g !== null &&
          ((BI[pI++] = ne),
          (BI[pI++] = oe),
          (BI[pI++] = rC),
          (ne = g.id),
          (oe = g.overflow),
          (rC = I)),
        (I = Wi(I, C.children)),
        (I.flags |= 4096),
        I);
  }
  function Xr(g, I, e) {
    g.lanes |= I;
    var C = g.alternate;
    C !== null && (C.lanes |= I), jc(g.return, I, e);
  }
  function OA(g, I, e, C, l) {
    var t = g.memoizedState;
    t === null
      ? (g.memoizedState = {
          isBackwards: I,
          rendering: null,
          renderingStartTime: 0,
          last: C,
          tail: e,
          tailMode: l,
        })
      : ((t.isBackwards = I),
        (t.rendering = null),
        (t.renderingStartTime = 0),
        (t.last = C),
        (t.tail = e),
        (t.tailMode = l));
  }
  function hm(g, I, e) {
    var C = I.pendingProps,
      l = C.revealOrder,
      t = C.tail;
    if ((jg(g, I, C.children, e), (C = pg.current), C & 2))
      (C = (C & 1) | 2), (I.flags |= 128);
    else {
      if (g !== null && g.flags & 128)
        g: for (g = I.child; g !== null; ) {
          if (g.tag === 13) g.memoizedState !== null && Xr(g, e, I);
          else if (g.tag === 19) Xr(g, e, I);
          else if (g.child !== null) {
            (g.child.return = g), (g = g.child);
            continue;
          }
          if (g === I) break g;
          for (; g.sibling === null; ) {
            if (g.return === null || g.return === I) break g;
            g = g.return;
          }
          (g.sibling.return = g.return), (g = g.sibling);
        }
      C &= 1;
    }
    if ((sg(pg, C), !(I.mode & 1))) I.memoizedState = null;
    else
      switch (l) {
        case "forwards":
          for (e = I.child, l = null; e !== null; )
            (g = e.alternate),
              g !== null && ro(g) === null && (l = e),
              (e = e.sibling);
          (e = l),
            e === null
              ? ((l = I.child), (I.child = null))
              : ((l = e.sibling), (e.sibling = null)),
            OA(I, !1, l, e, t);
          break;
        case "backwards":
          for (e = null, l = I.child, I.child = null; l !== null; ) {
            if (((g = l.alternate), g !== null && ro(g) === null)) {
              I.child = l;
              break;
            }
            (g = l.sibling), (l.sibling = e), (e = l), (l = g);
          }
          OA(I, !0, e, null, t);
          break;
        case "together":
          OA(I, !1, null, null, void 0);
          break;
        default:
          I.memoizedState = null;
      }
    return I.child;
  }
  function En(g, I) {
    !(I.mode & 1) &&
      g !== null &&
      ((g.alternate = null), (I.alternate = null), (I.flags |= 2));
  }
  function ae(g, I, e) {
    if (
      (g !== null && (I.dependencies = g.dependencies),
      (uC |= I.lanes),
      !(e & I.childLanes))
    )
      return null;
    if (g !== null && I.child !== g.child) throw Error(J(153));
    if (I.child !== null) {
      for (
        g = I.child, e = Ke(g, g.pendingProps), I.child = e, e.return = I;
        g.sibling !== null;

      )
        (g = g.sibling),
          (e = e.sibling = Ke(g, g.pendingProps)),
          (e.return = I);
      e.sibling = null;
    }
    return I.child;
  }
  function zp(g, I, e) {
    switch (I.tag) {
      case 3:
        pm(I), Al();
        break;
      case 5:
        Pu(I);
        break;
      case 1:
        CI(I.type) && no(I);
        break;
      case 4:
        Gi(I, I.stateNode.containerInfo);
        break;
      case 10:
        var C = I.type._context,
          l = I.memoizedProps.value;
        sg(co, C._currentValue), (C._currentValue = l);
        break;
      case 13:
        if (((C = I.memoizedState), C !== null))
          return C.dehydrated !== null
            ? (sg(pg, pg.current & 1), (I.flags |= 128), null)
            : e & I.child.childLanes
            ? ym(g, I, e)
            : (sg(pg, pg.current & 1),
              (g = ae(g, I, e)),
              g !== null ? g.sibling : null);
        sg(pg, pg.current & 1);
        break;
      case 19:
        if (((C = (e & I.childLanes) !== 0), g.flags & 128)) {
          if (C) return hm(g, I, e);
          I.flags |= 128;
        }
        if (
          ((l = I.memoizedState),
          l !== null &&
            ((l.rendering = null), (l.tail = null), (l.lastEffect = null)),
          sg(pg, pg.current),
          C)
        )
          break;
        return null;
      case 22:
      case 23:
        return (I.lanes = 0), bm(g, I, e);
    }
    return ae(g, I, e);
  }
  var Sm, ed, Vm, Wm;
  Sm = function (g, I) {
    for (var e = I.child; e !== null; ) {
      if (e.tag === 5 || e.tag === 6) g.appendChild(e.stateNode);
      else if (e.tag !== 4 && e.child !== null) {
        (e.child.return = e), (e = e.child);
        continue;
      }
      if (e === I) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === I) return;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  };
  ed = function () {};
  Vm = function (g, I, e, C) {
    var l = g.memoizedProps;
    if (l !== C) {
      (g = I.stateNode), AC(jI.current);
      var t = null;
      switch (e) {
        case "input":
          (l = Sc(g, l)), (C = Sc(g, C)), (t = []);
          break;
        case "select":
          (l = hg({}, l, { value: void 0 })),
            (C = hg({}, C, { value: void 0 })),
            (t = []);
          break;
        case "textarea":
          (l = Rc(g, l)), (C = Rc(g, C)), (t = []);
          break;
        default:
          typeof l.onClick != "function" &&
            typeof C.onClick == "function" &&
            (g.onclick = lo);
      }
      Jc(e, C);
      var n;
      e = null;
      for (c in l)
        if (!C.hasOwnProperty(c) && l.hasOwnProperty(c) && l[c] != null)
          if (c === "style") {
            var o = l[c];
            for (n in o) o.hasOwnProperty(n) && (e || (e = {}), (e[n] = ""));
          } else
            c !== "dangerouslySetInnerHTML" &&
              c !== "children" &&
              c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              c !== "autoFocus" &&
              (tt.hasOwnProperty(c)
                ? t || (t = [])
                : (t = t || []).push(c, null));
      for (c in C) {
        var A = C[c];
        if (
          ((o = l != null ? l[c] : void 0),
          C.hasOwnProperty(c) && A !== o && (A != null || o != null))
        )
          if (c === "style")
            if (o) {
              for (n in o)
                !o.hasOwnProperty(n) ||
                  (A && A.hasOwnProperty(n)) ||
                  (e || (e = {}), (e[n] = ""));
              for (n in A)
                A.hasOwnProperty(n) &&
                  o[n] !== A[n] &&
                  (e || (e = {}), (e[n] = A[n]));
            } else e || (t || (t = []), t.push(c, e)), (e = A);
          else
            c === "dangerouslySetInnerHTML"
              ? ((A = A ? A.__html : void 0),
                (o = o ? o.__html : void 0),
                A != null && o !== A && (t = t || []).push(c, A))
              : c === "children"
              ? (typeof A != "string" && typeof A != "number") ||
                (t = t || []).push(c, "" + A)
              : c !== "suppressContentEditableWarning" &&
                c !== "suppressHydrationWarning" &&
                (tt.hasOwnProperty(c)
                  ? (A != null && c === "onScroll" && mg("scroll", g),
                    t || o === A || (t = []))
                  : (t = t || []).push(c, A));
      }
      e && (t = t || []).push("style", e);
      var c = t;
      (I.updateQueue = c) && (I.flags |= 4);
    }
  };
  Wm = function (g, I, e, C) {
    e !== C && (I.flags |= 4);
  };
  function Nl(g, I) {
    if (!bg)
      switch (g.tailMode) {
        case "hidden":
          I = g.tail;
          for (var e = null; I !== null; )
            I.alternate !== null && (e = I), (I = I.sibling);
          e === null ? (g.tail = null) : (e.sibling = null);
          break;
        case "collapsed":
          e = g.tail;
          for (var C = null; e !== null; )
            e.alternate !== null && (C = e), (e = e.sibling);
          C === null
            ? I || g.tail === null
              ? (g.tail = null)
              : (g.tail.sibling = null)
            : (C.sibling = null);
      }
  }
  function Eg(g) {
    var I = g.alternate !== null && g.alternate.child === g.child,
      e = 0,
      C = 0;
    if (I)
      for (var l = g.child; l !== null; )
        (e |= l.lanes | l.childLanes),
          (C |= l.subtreeFlags & 14680064),
          (C |= l.flags & 14680064),
          (l.return = g),
          (l = l.sibling);
    else
      for (l = g.child; l !== null; )
        (e |= l.lanes | l.childLanes),
          (C |= l.subtreeFlags),
          (C |= l.flags),
          (l.return = g),
          (l = l.sibling);
    return (g.subtreeFlags |= C), (g.childLanes = e), I;
  }
  function Ep(g, I, e) {
    var C = I.pendingProps;
    switch ((ii(I), I.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Eg(I), null;
      case 1:
        return CI(I.type) && to(), Eg(I), null;
      case 3:
        return (
          (C = I.stateNode),
          dl(),
          Zg(eI),
          Zg(Lg),
          Bi(),
          C.pendingContext &&
            ((C.context = C.pendingContext), (C.pendingContext = null)),
          (g === null || g.child === null) &&
            (Zn(I)
              ? (I.flags |= 4)
              : g === null ||
                (g.memoizedState.isDehydrated && !(I.flags & 256)) ||
                ((I.flags |= 1024), fI !== null && (dd(fI), (fI = null)))),
          ed(g, I),
          Eg(I),
          null
        );
      case 5:
        bi(I);
        var l = AC(Zt.current);
        if (((e = I.type), g !== null && I.stateNode != null))
          Vm(g, I, e, C, l),
            g.ref !== I.ref && ((I.flags |= 512), (I.flags |= 2097152));
        else {
          if (!C) {
            if (I.stateNode === null) throw Error(J(166));
            return Eg(I), null;
          }
          if (((g = AC(jI.current)), Zn(I))) {
            (C = I.stateNode), (e = I.type);
            var t = I.memoizedProps;
            switch (((C[LI] = I), (C[ut] = t), (g = (I.mode & 1) !== 0), e)) {
              case "dialog":
                mg("cancel", C), mg("close", C);
                break;
              case "iframe":
              case "object":
              case "embed":
                mg("load", C);
                break;
              case "video":
              case "audio":
                for (l = 0; l < Ql.length; l++) mg(Ql[l], C);
                break;
              case "source":
                mg("error", C);
                break;
              case "img":
              case "image":
              case "link":
                mg("error", C), mg("load", C);
                break;
              case "details":
                mg("toggle", C);
                break;
              case "input":
                Ka(C, t), mg("invalid", C);
                break;
              case "select":
                (C._wrapperState = { wasMultiple: !!t.multiple }),
                  mg("invalid", C);
                break;
              case "textarea":
                xa(C, t), mg("invalid", C);
            }
            Jc(e, t), (l = null);
            for (var n in t)
              if (t.hasOwnProperty(n)) {
                var o = t[n];
                n === "children"
                  ? typeof o == "string"
                    ? C.textContent !== o &&
                      (t.suppressHydrationWarning !== !0 &&
                        mn(C.textContent, o, g),
                      (l = ["children", o]))
                    : typeof o == "number" &&
                      C.textContent !== "" + o &&
                      (t.suppressHydrationWarning !== !0 &&
                        mn(C.textContent, o, g),
                      (l = ["children", "" + o]))
                  : tt.hasOwnProperty(n) &&
                    o != null &&
                    n === "onScroll" &&
                    mg("scroll", C);
              }
            switch (e) {
              case "input":
                on(C), Fa(C, t, !0);
                break;
              case "textarea":
                on(C), Ma(C);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof t.onClick == "function" && (C.onclick = lo);
            }
            (C = l), (I.updateQueue = C), C !== null && (I.flags |= 4);
          } else {
            (n = l.nodeType === 9 ? l : l.ownerDocument),
              g === "http://www.w3.org/1999/xhtml" && (g = gu(e)),
              g === "http://www.w3.org/1999/xhtml"
                ? e === "script"
                  ? ((g = n.createElement("div")),
                    (g.innerHTML = "<script><\/script>"),
                    (g = g.removeChild(g.firstChild)))
                  : typeof C.is == "string"
                  ? (g = n.createElement(e, { is: C.is }))
                  : ((g = n.createElement(e)),
                    e === "select" &&
                      ((n = g),
                      C.multiple
                        ? (n.multiple = !0)
                        : C.size && (n.size = C.size)))
                : (g = n.createElementNS(g, e)),
              (g[LI] = I),
              (g[ut] = C),
              Sm(g, I, !1, !1),
              (I.stateNode = g);
            g: {
              switch (((n = vc(e, C)), e)) {
                case "dialog":
                  mg("cancel", g), mg("close", g), (l = C);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  mg("load", g), (l = C);
                  break;
                case "video":
                case "audio":
                  for (l = 0; l < Ql.length; l++) mg(Ql[l], g);
                  l = C;
                  break;
                case "source":
                  mg("error", g), (l = C);
                  break;
                case "img":
                case "image":
                case "link":
                  mg("error", g), mg("load", g), (l = C);
                  break;
                case "details":
                  mg("toggle", g), (l = C);
                  break;
                case "input":
                  Ka(g, C), (l = Sc(g, C)), mg("invalid", g);
                  break;
                case "option":
                  l = C;
                  break;
                case "select":
                  (g._wrapperState = { wasMultiple: !!C.multiple }),
                    (l = hg({}, C, { value: void 0 })),
                    mg("invalid", g);
                  break;
                case "textarea":
                  xa(g, C), (l = Rc(g, C)), mg("invalid", g);
                  break;
                default:
                  l = C;
              }
              Jc(e, l), (o = l);
              for (t in o)
                if (o.hasOwnProperty(t)) {
                  var A = o[t];
                  t === "style"
                    ? Cu(g, A)
                    : t === "dangerouslySetInnerHTML"
                    ? ((A = A ? A.__html : void 0), A != null && Iu(g, A))
                    : t === "children"
                    ? typeof A == "string"
                      ? (e !== "textarea" || A !== "") && nt(g, A)
                      : typeof A == "number" && nt(g, "" + A)
                    : t !== "suppressContentEditableWarning" &&
                      t !== "suppressHydrationWarning" &&
                      t !== "autoFocus" &&
                      (tt.hasOwnProperty(t)
                        ? A != null && t === "onScroll" && mg("scroll", g)
                        : A != null && Od(g, t, A, n));
                }
              switch (e) {
                case "input":
                  on(g), Fa(g, C, !1);
                  break;
                case "textarea":
                  on(g), Ma(g);
                  break;
                case "option":
                  C.value != null && g.setAttribute("value", "" + Me(C.value));
                  break;
                case "select":
                  (g.multiple = !!C.multiple),
                    (t = C.value),
                    t != null
                      ? OC(g, !!C.multiple, t, !1)
                      : C.defaultValue != null &&
                        OC(g, !!C.multiple, C.defaultValue, !0);
                  break;
                default:
                  typeof l.onClick == "function" && (g.onclick = lo);
              }
              switch (e) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  C = !!C.autoFocus;
                  break g;
                case "img":
                  C = !0;
                  break g;
                default:
                  C = !1;
              }
            }
            C && (I.flags |= 4);
          }
          I.ref !== null && ((I.flags |= 512), (I.flags |= 2097152));
        }
        return Eg(I), null;
      case 6:
        if (g && I.stateNode != null) Wm(g, I, g.memoizedProps, C);
        else {
          if (typeof C != "string" && I.stateNode === null) throw Error(J(166));
          if (((e = AC(Zt.current)), AC(jI.current), Zn(I))) {
            if (
              ((C = I.stateNode),
              (e = I.memoizedProps),
              (C[LI] = I),
              (t = C.nodeValue !== e) && ((g = aI), g !== null))
            )
              switch (g.tag) {
                case 3:
                  mn(C.nodeValue, e, (g.mode & 1) !== 0);
                  break;
                case 5:
                  g.memoizedProps.suppressHydrationWarning !== !0 &&
                    mn(C.nodeValue, e, (g.mode & 1) !== 0);
              }
            t && (I.flags |= 4);
          } else
            (C = (e.nodeType === 9 ? e : e.ownerDocument).createTextNode(C)),
              (C[LI] = I),
              (I.stateNode = C);
        }
        return Eg(I), null;
      case 13:
        if (
          (Zg(pg),
          (C = I.memoizedState),
          g === null ||
            (g.memoizedState !== null && g.memoizedState.dehydrated !== null))
        ) {
          if (bg && iI !== null && I.mode & 1 && !(I.flags & 128))
            Qu(), Al(), (I.flags |= 98560), (t = !1);
          else if (((t = Zn(I)), C !== null && C.dehydrated !== null)) {
            if (g === null) {
              if (!t) throw Error(J(318));
              if (
                ((t = I.memoizedState),
                (t = t !== null ? t.dehydrated : null),
                !t)
              )
                throw Error(J(317));
              t[LI] = I;
            } else
              Al(),
                !(I.flags & 128) && (I.memoizedState = null),
                (I.flags |= 4);
            Eg(I), (t = !1);
          } else fI !== null && (dd(fI), (fI = null)), (t = !0);
          if (!t) return I.flags & 65536 ? I : null;
        }
        return I.flags & 128
          ? ((I.lanes = e), I)
          : ((C = C !== null),
            C !== (g !== null && g.memoizedState !== null) &&
              C &&
              ((I.child.flags |= 8192),
              I.mode & 1 &&
                (g === null || pg.current & 1 ? kg === 0 && (kg = 3) : fi())),
            I.updateQueue !== null && (I.flags |= 4),
            Eg(I),
            null);
      case 4:
        return (
          dl(),
          ed(g, I),
          g === null && rt(I.stateNode.containerInfo),
          Eg(I),
          null
        );
      case 10:
        return ui(I.type._context), Eg(I), null;
      case 17:
        return CI(I.type) && to(), Eg(I), null;
      case 19:
        if ((Zg(pg), (t = I.memoizedState), t === null)) return Eg(I), null;
        if (((C = (I.flags & 128) !== 0), (n = t.rendering), n === null))
          if (C) Nl(t, !1);
          else {
            if (kg !== 0 || (g !== null && g.flags & 128))
              for (g = I.child; g !== null; ) {
                if (((n = ro(g)), n !== null)) {
                  for (
                    I.flags |= 128,
                      Nl(t, !1),
                      C = n.updateQueue,
                      C !== null && ((I.updateQueue = C), (I.flags |= 4)),
                      I.subtreeFlags = 0,
                      C = e,
                      e = I.child;
                    e !== null;

                  )
                    (t = e),
                      (g = C),
                      (t.flags &= 14680066),
                      (n = t.alternate),
                      n === null
                        ? ((t.childLanes = 0),
                          (t.lanes = g),
                          (t.child = null),
                          (t.subtreeFlags = 0),
                          (t.memoizedProps = null),
                          (t.memoizedState = null),
                          (t.updateQueue = null),
                          (t.dependencies = null),
                          (t.stateNode = null))
                        : ((t.childLanes = n.childLanes),
                          (t.lanes = n.lanes),
                          (t.child = n.child),
                          (t.subtreeFlags = 0),
                          (t.deletions = null),
                          (t.memoizedProps = n.memoizedProps),
                          (t.memoizedState = n.memoizedState),
                          (t.updateQueue = n.updateQueue),
                          (t.type = n.type),
                          (g = n.dependencies),
                          (t.dependencies =
                            g === null
                              ? null
                              : {
                                  lanes: g.lanes,
                                  firstContext: g.firstContext,
                                })),
                      (e = e.sibling);
                  return sg(pg, (pg.current & 1) | 2), I.child;
                }
                g = g.sibling;
              }
            t.tail !== null &&
              Wg() > al &&
              ((I.flags |= 128), (C = !0), Nl(t, !1), (I.lanes = 4194304));
          }
        else {
          if (!C)
            if (((g = ro(n)), g !== null)) {
              if (
                ((I.flags |= 128),
                (C = !0),
                (e = g.updateQueue),
                e !== null && ((I.updateQueue = e), (I.flags |= 4)),
                Nl(t, !0),
                t.tail === null &&
                  t.tailMode === "hidden" &&
                  !n.alternate &&
                  !bg)
              )
                return Eg(I), null;
            } else
              2 * Wg() - t.renderingStartTime > al &&
                e !== 1073741824 &&
                ((I.flags |= 128), (C = !0), Nl(t, !1), (I.lanes = 4194304));
          t.isBackwards
            ? ((n.sibling = I.child), (I.child = n))
            : ((e = t.last),
              e !== null ? (e.sibling = n) : (I.child = n),
              (t.last = n));
        }
        return t.tail !== null
          ? ((I = t.tail),
            (t.rendering = I),
            (t.tail = I.sibling),
            (t.renderingStartTime = Wg()),
            (I.sibling = null),
            (e = pg.current),
            sg(pg, C ? (e & 1) | 2 : e & 1),
            I)
          : (Eg(I), null);
      case 22:
      case 23:
        return (
          ki(),
          (C = I.memoizedState !== null),
          g !== null && (g.memoizedState !== null) !== C && (I.flags |= 8192),
          C && I.mode & 1
            ? AI & 1073741824 &&
              (Eg(I), I.subtreeFlags & 6 && (I.flags |= 8192))
            : Eg(I),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(J(156, I.tag));
  }
  function Up(g, I) {
    switch ((ii(I), I.tag)) {
      case 1:
        return (
          CI(I.type) && to(),
          (g = I.flags),
          g & 65536 ? ((I.flags = (g & -65537) | 128), I) : null
        );
      case 3:
        return (
          dl(),
          Zg(eI),
          Zg(Lg),
          Bi(),
          (g = I.flags),
          g & 65536 && !(g & 128) ? ((I.flags = (g & -65537) | 128), I) : null
        );
      case 5:
        return bi(I), null;
      case 13:
        if (
          (Zg(pg), (g = I.memoizedState), g !== null && g.dehydrated !== null)
        ) {
          if (I.alternate === null) throw Error(J(340));
          Al();
        }
        return (
          (g = I.flags), g & 65536 ? ((I.flags = (g & -65537) | 128), I) : null
        );
      case 19:
        return Zg(pg), null;
      case 4:
        return dl(), null;
      case 10:
        return ui(I.type._context), null;
      case 22:
      case 23:
        return ki(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Bn = !1,
    Qg = !1,
    Qp = typeof WeakSet == "function" ? WeakSet : Set,
    N = null;
  function DC(g, I) {
    var e = g.ref;
    if (e !== null)
      if (typeof e == "function")
        try {
          e(null);
        } catch (C) {
          Sg(g, I, C);
        }
      else e.current = null;
  }
  function Cd(g, I, e) {
    try {
      e();
    } catch (C) {
      Sg(g, I, C);
    }
  }
  var Jr = !1;
  function Lp(g, I) {
    if (((Mc = Io), (g = ku()), ci(g))) {
      if ("selectionStart" in g)
        var e = { start: g.selectionStart, end: g.selectionEnd };
      else
        g: {
          e = ((e = g.ownerDocument) && e.defaultView) || window;
          var C = e.getSelection && e.getSelection();
          if (C && C.rangeCount !== 0) {
            e = C.anchorNode;
            var l = C.anchorOffset,
              t = C.focusNode;
            C = C.focusOffset;
            try {
              e.nodeType, t.nodeType;
            } catch {
              e = null;
              break g;
            }
            var n = 0,
              o = -1,
              A = -1,
              c = 0,
              d = 0,
              i = g,
              r = null;
            I: for (;;) {
              for (
                var u;
                i !== e || (l !== 0 && i.nodeType !== 3) || (o = n + l),
                  i !== t || (C !== 0 && i.nodeType !== 3) || (A = n + C),
                  i.nodeType === 3 && (n += i.nodeValue.length),
                  (u = i.firstChild) !== null;

              )
                (r = i), (i = u);
              for (;;) {
                if (i === g) break I;
                if (
                  (r === e && ++c === l && (o = n),
                  r === t && ++d === C && (A = n),
                  (u = i.nextSibling) !== null)
                )
                  break;
                (i = r), (r = i.parentNode);
              }
              i = u;
            }
            e = o === -1 || A === -1 ? null : { start: o, end: A };
          } else e = null;
        }
      e = e || { start: 0, end: 0 };
    } else e = null;
    for (
      zc = { focusedElem: g, selectionRange: e }, Io = !1, N = I;
      N !== null;

    )
      if (((I = N), (g = I.child), (I.subtreeFlags & 1028) !== 0 && g !== null))
        (g.return = I), (N = g);
      else
        for (; N !== null; ) {
          I = N;
          try {
            var b = I.alternate;
            if (I.flags & 1024)
              switch (I.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (b !== null) {
                    var m = b.memoizedProps,
                      p = b.memoizedState,
                      G = I.stateNode,
                      Z = G.getSnapshotBeforeUpdate(
                        I.elementType === I.type ? m : vI(I.type, m),
                        p
                      );
                    G.__reactInternalSnapshotBeforeUpdate = Z;
                  }
                  break;
                case 3:
                  var B = I.stateNode.containerInfo;
                  B.nodeType === 1
                    ? (B.textContent = "")
                    : B.nodeType === 9 &&
                      B.documentElement &&
                      B.removeChild(B.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(J(163));
              }
          } catch (y) {
            Sg(I, I.return, y);
          }
          if (((g = I.sibling), g !== null)) {
            (g.return = I.return), (N = g);
            break;
          }
          N = I.return;
        }
    return (b = Jr), (Jr = !1), b;
  }
  function It(g, I, e) {
    var C = I.updateQueue;
    if (((C = C !== null ? C.lastEffect : null), C !== null)) {
      var l = (C = C.next);
      do {
        if ((l.tag & g) === g) {
          var t = l.destroy;
          (l.destroy = void 0), t !== void 0 && Cd(I, e, t);
        }
        l = l.next;
      } while (l !== C);
    }
  }
  function jo(g, I) {
    if (
      ((I = I.updateQueue), (I = I !== null ? I.lastEffect : null), I !== null)
    ) {
      var e = (I = I.next);
      do {
        if ((e.tag & g) === g) {
          var C = e.create;
          e.destroy = C();
        }
        e = e.next;
      } while (e !== I);
    }
  }
  function ld(g) {
    var I = g.ref;
    if (I !== null) {
      var e = g.stateNode;
      switch (g.tag) {
        case 5:
          g = e;
          break;
        default:
          g = e;
      }
      typeof I == "function" ? I(g) : (I.current = g);
    }
  }
  function Rm(g) {
    var I = g.alternate;
    I !== null && ((g.alternate = null), Rm(I)),
      (g.child = null),
      (g.deletions = null),
      (g.sibling = null),
      g.tag === 5 &&
        ((I = g.stateNode),
        I !== null &&
          (delete I[LI],
          delete I[ut],
          delete I[Qc],
          delete I[Rp],
          delete I[Xp])),
      (g.stateNode = null),
      (g.return = null),
      (g.dependencies = null),
      (g.memoizedProps = null),
      (g.memoizedState = null),
      (g.pendingProps = null),
      (g.stateNode = null),
      (g.updateQueue = null);
  }
  function Xm(g) {
    return g.tag === 5 || g.tag === 3 || g.tag === 4;
  }
  function vr(g) {
    g: for (;;) {
      for (; g.sibling === null; ) {
        if (g.return === null || Xm(g.return)) return null;
        g = g.return;
      }
      for (
        g.sibling.return = g.return, g = g.sibling;
        g.tag !== 5 && g.tag !== 6 && g.tag !== 18;

      ) {
        if (g.flags & 2 || g.child === null || g.tag === 4) continue g;
        (g.child.return = g), (g = g.child);
      }
      if (!(g.flags & 2)) return g.stateNode;
    }
  }
  function td(g, I, e) {
    var C = g.tag;
    if (C === 5 || C === 6)
      (g = g.stateNode),
        I
          ? e.nodeType === 8
            ? e.parentNode.insertBefore(g, I)
            : e.insertBefore(g, I)
          : (e.nodeType === 8
              ? ((I = e.parentNode), I.insertBefore(g, e))
              : ((I = e), I.appendChild(g)),
            (e = e._reactRootContainer),
            e != null || I.onclick !== null || (I.onclick = lo));
    else if (C !== 4 && ((g = g.child), g !== null))
      for (td(g, I, e), g = g.sibling; g !== null; )
        td(g, I, e), (g = g.sibling);
  }
  function nd(g, I, e) {
    var C = g.tag;
    if (C === 5 || C === 6)
      (g = g.stateNode), I ? e.insertBefore(g, I) : e.appendChild(g);
    else if (C !== 4 && ((g = g.child), g !== null))
      for (nd(g, I, e), g = g.sibling; g !== null; )
        nd(g, I, e), (g = g.sibling);
  }
  var Ng = null,
    kI = !1;
  function Ze(g, I, e) {
    for (e = e.child; e !== null; ) Jm(g, I, e), (e = e.sibling);
  }
  function Jm(g, I, e) {
    if (TI && typeof TI.onCommitFiberUnmount == "function")
      try {
        TI.onCommitFiberUnmount(Mo, e);
      } catch {}
    switch (e.tag) {
      case 5:
        Qg || DC(e, I);
      case 6:
        var C = Ng,
          l = kI;
        (Ng = null),
          Ze(g, I, e),
          (Ng = C),
          (kI = l),
          Ng !== null &&
            (kI
              ? ((g = Ng),
                (e = e.stateNode),
                g.nodeType === 8
                  ? g.parentNode.removeChild(e)
                  : g.removeChild(e))
              : Ng.removeChild(e.stateNode));
        break;
      case 18:
        Ng !== null &&
          (kI
            ? ((g = Ng),
              (e = e.stateNode),
              g.nodeType === 8
                ? UA(g.parentNode, e)
                : g.nodeType === 1 && UA(g, e),
              dt(g))
            : UA(Ng, e.stateNode));
        break;
      case 4:
        (C = Ng),
          (l = kI),
          (Ng = e.stateNode.containerInfo),
          (kI = !0),
          Ze(g, I, e),
          (Ng = C),
          (kI = l);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !Qg &&
          ((C = e.updateQueue), C !== null && ((C = C.lastEffect), C !== null))
        ) {
          l = C = C.next;
          do {
            var t = l,
              n = t.destroy;
            (t = t.tag),
              n !== void 0 && (t & 2 || t & 4) && Cd(e, I, n),
              (l = l.next);
          } while (l !== C);
        }
        Ze(g, I, e);
        break;
      case 1:
        if (
          !Qg &&
          (DC(e, I),
          (C = e.stateNode),
          typeof C.componentWillUnmount == "function")
        )
          try {
            (C.props = e.memoizedProps),
              (C.state = e.memoizedState),
              C.componentWillUnmount();
          } catch (o) {
            Sg(e, I, o);
          }
        Ze(g, I, e);
        break;
      case 21:
        Ze(g, I, e);
        break;
      case 22:
        e.mode & 1
          ? ((Qg = (C = Qg) || e.memoizedState !== null), Ze(g, I, e), (Qg = C))
          : Ze(g, I, e);
        break;
      default:
        Ze(g, I, e);
    }
  }
  function kr(g) {
    var I = g.updateQueue;
    if (I !== null) {
      g.updateQueue = null;
      var e = g.stateNode;
      e === null && (e = g.stateNode = new Qp()),
        I.forEach(function (C) {
          var l = gy.bind(null, g, C);
          e.has(C) || (e.add(C), C.then(l, l));
        });
    }
  }
  function XI(g, I) {
    var e = I.deletions;
    if (e !== null)
      for (var C = 0; C < e.length; C++) {
        var l = e[C];
        try {
          var t = g,
            n = I,
            o = n;
          g: for (; o !== null; ) {
            switch (o.tag) {
              case 5:
                (Ng = o.stateNode), (kI = !1);
                break g;
              case 3:
                (Ng = o.stateNode.containerInfo), (kI = !0);
                break g;
              case 4:
                (Ng = o.stateNode.containerInfo), (kI = !0);
                break g;
            }
            o = o.return;
          }
          if (Ng === null) throw Error(J(160));
          Jm(t, n, l), (Ng = null), (kI = !1);
          var A = l.alternate;
          A !== null && (A.return = null), (l.return = null);
        } catch (c) {
          Sg(l, I, c);
        }
      }
    if (I.subtreeFlags & 12854)
      for (I = I.child; I !== null; ) vm(I, g), (I = I.sibling);
  }
  function vm(g, I) {
    var e = g.alternate,
      C = g.flags;
    switch (g.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((XI(I, g), UI(g), C & 4)) {
          try {
            It(3, g, g.return), jo(3, g);
          } catch (m) {
            Sg(g, g.return, m);
          }
          try {
            It(5, g, g.return);
          } catch (m) {
            Sg(g, g.return, m);
          }
        }
        break;
      case 1:
        XI(I, g), UI(g), C & 512 && e !== null && DC(e, e.return);
        break;
      case 5:
        if (
          (XI(I, g),
          UI(g),
          C & 512 && e !== null && DC(e, e.return),
          g.flags & 32)
        ) {
          var l = g.stateNode;
          try {
            nt(l, "");
          } catch (m) {
            Sg(g, g.return, m);
          }
        }
        if (C & 4 && ((l = g.stateNode), l != null)) {
          var t = g.memoizedProps,
            n = e !== null ? e.memoizedProps : t,
            o = g.type,
            A = g.updateQueue;
          if (((g.updateQueue = null), A !== null))
            try {
              o === "input" && t.type === "radio" && t.name != null && qs(l, t),
                vc(o, n);
              var c = vc(o, t);
              for (n = 0; n < A.length; n += 2) {
                var d = A[n],
                  i = A[n + 1];
                d === "style"
                  ? Cu(l, i)
                  : d === "dangerouslySetInnerHTML"
                  ? Iu(l, i)
                  : d === "children"
                  ? nt(l, i)
                  : Od(l, d, i, c);
              }
              switch (o) {
                case "input":
                  Vc(l, t);
                  break;
                case "textarea":
                  $s(l, t);
                  break;
                case "select":
                  var r = l._wrapperState.wasMultiple;
                  l._wrapperState.wasMultiple = !!t.multiple;
                  var u = t.value;
                  u != null
                    ? OC(l, !!t.multiple, u, !1)
                    : r !== !!t.multiple &&
                      (t.defaultValue != null
                        ? OC(l, !!t.multiple, t.defaultValue, !0)
                        : OC(l, !!t.multiple, t.multiple ? [] : "", !1));
              }
              l[ut] = t;
            } catch (m) {
              Sg(g, g.return, m);
            }
        }
        break;
      case 6:
        if ((XI(I, g), UI(g), C & 4)) {
          if (g.stateNode === null) throw Error(J(162));
          (l = g.stateNode), (t = g.memoizedProps);
          try {
            l.nodeValue = t;
          } catch (m) {
            Sg(g, g.return, m);
          }
        }
        break;
      case 3:
        if (
          (XI(I, g), UI(g), C & 4 && e !== null && e.memoizedState.isDehydrated)
        )
          try {
            dt(I.containerInfo);
          } catch (m) {
            Sg(g, g.return, m);
          }
        break;
      case 4:
        XI(I, g), UI(g);
        break;
      case 13:
        XI(I, g),
          UI(g),
          (l = g.child),
          l.flags & 8192 &&
            ((t = l.memoizedState !== null),
            (l.stateNode.isHidden = t),
            !t ||
              (l.alternate !== null && l.alternate.memoizedState !== null) ||
              (Ji = Wg())),
          C & 4 && kr(g);
        break;
      case 22:
        if (
          ((d = e !== null && e.memoizedState !== null),
          g.mode & 1 ? ((Qg = (c = Qg) || d), XI(I, g), (Qg = c)) : XI(I, g),
          UI(g),
          C & 8192)
        ) {
          if (
            ((c = g.memoizedState !== null),
            (g.stateNode.isHidden = c) && !d && g.mode & 1)
          )
            for (N = g, d = g.child; d !== null; ) {
              for (i = N = d; N !== null; ) {
                switch (((r = N), (u = r.child), r.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    It(4, r, r.return);
                    break;
                  case 1:
                    DC(r, r.return);
                    var b = r.stateNode;
                    if (typeof b.componentWillUnmount == "function") {
                      (C = r), (e = r.return);
                      try {
                        (I = C),
                          (b.props = I.memoizedProps),
                          (b.state = I.memoizedState),
                          b.componentWillUnmount();
                      } catch (m) {
                        Sg(C, e, m);
                      }
                    }
                    break;
                  case 5:
                    DC(r, r.return);
                    break;
                  case 22:
                    if (r.memoizedState !== null) {
                      Yr(i);
                      continue;
                    }
                }
                u !== null ? ((u.return = r), (N = u)) : Yr(i);
              }
              d = d.sibling;
            }
          g: for (d = null, i = g; ; ) {
            if (i.tag === 5) {
              if (d === null) {
                d = i;
                try {
                  (l = i.stateNode),
                    c
                      ? ((t = l.style),
                        typeof t.setProperty == "function"
                          ? t.setProperty("display", "none", "important")
                          : (t.display = "none"))
                      : ((o = i.stateNode),
                        (A = i.memoizedProps.style),
                        (n =
                          A != null && A.hasOwnProperty("display")
                            ? A.display
                            : null),
                        (o.style.display = eu("display", n)));
                } catch (m) {
                  Sg(g, g.return, m);
                }
              }
            } else if (i.tag === 6) {
              if (d === null)
                try {
                  i.stateNode.nodeValue = c ? "" : i.memoizedProps;
                } catch (m) {
                  Sg(g, g.return, m);
                }
            } else if (
              ((i.tag !== 22 && i.tag !== 23) ||
                i.memoizedState === null ||
                i === g) &&
              i.child !== null
            ) {
              (i.child.return = i), (i = i.child);
              continue;
            }
            if (i === g) break g;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === g) break g;
              d === i && (d = null), (i = i.return);
            }
            d === i && (d = null),
              (i.sibling.return = i.return),
              (i = i.sibling);
          }
        }
        break;
      case 19:
        XI(I, g), UI(g), C & 4 && kr(g);
        break;
      case 21:
        break;
      default:
        XI(I, g), UI(g);
    }
  }
  function UI(g) {
    var I = g.flags;
    if (I & 2) {
      try {
        g: {
          for (var e = g.return; e !== null; ) {
            if (Xm(e)) {
              var C = e;
              break g;
            }
            e = e.return;
          }
          throw Error(J(160));
        }
        switch (C.tag) {
          case 5:
            var l = C.stateNode;
            C.flags & 32 && (nt(l, ""), (C.flags &= -33));
            var t = vr(g);
            nd(g, t, l);
            break;
          case 3:
          case 4:
            var n = C.stateNode.containerInfo,
              o = vr(g);
            td(g, o, n);
            break;
          default:
            throw Error(J(161));
        }
      } catch (A) {
        Sg(g, g.return, A);
      }
      g.flags &= -3;
    }
    I & 4096 && (g.flags &= -4097);
  }
  function Dp(g, I, e) {
    (N = g), km(g);
  }
  function km(g, I, e) {
    for (var C = (g.mode & 1) !== 0; N !== null; ) {
      var l = N,
        t = l.child;
      if (l.tag === 22 && C) {
        var n = l.memoizedState !== null || Bn;
        if (!n) {
          var o = l.alternate,
            A = (o !== null && o.memoizedState !== null) || Qg;
          o = Bn;
          var c = Qg;
          if (((Bn = n), (Qg = A) && !c))
            for (N = l; N !== null; )
              (n = N),
                (A = n.child),
                n.tag === 22 && n.memoizedState !== null
                  ? Hr(l)
                  : A !== null
                  ? ((A.return = n), (N = A))
                  : Hr(l);
          for (; t !== null; ) (N = t), km(t), (t = t.sibling);
          (N = l), (Bn = o), (Qg = c);
        }
        fr(g);
      } else
        l.subtreeFlags & 8772 && t !== null ? ((t.return = l), (N = t)) : fr(g);
    }
  }
  function fr(g) {
    for (; N !== null; ) {
      var I = N;
      if (I.flags & 8772) {
        var e = I.alternate;
        try {
          if (I.flags & 8772)
            switch (I.tag) {
              case 0:
              case 11:
              case 15:
                Qg || jo(5, I);
                break;
              case 1:
                var C = I.stateNode;
                if (I.flags & 4 && !Qg)
                  if (e === null) C.componentDidMount();
                  else {
                    var l =
                      I.elementType === I.type
                        ? e.memoizedProps
                        : vI(I.type, e.memoizedProps);
                    C.componentDidUpdate(
                      l,
                      e.memoizedState,
                      C.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var t = I.updateQueue;
                t !== null && mr(I, t, C);
                break;
              case 3:
                var n = I.updateQueue;
                if (n !== null) {
                  if (((e = null), I.child !== null))
                    switch (I.child.tag) {
                      case 5:
                        e = I.child.stateNode;
                        break;
                      case 1:
                        e = I.child.stateNode;
                    }
                  mr(I, n, e);
                }
                break;
              case 5:
                var o = I.stateNode;
                if (e === null && I.flags & 4) {
                  e = o;
                  var A = I.memoizedProps;
                  switch (I.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      A.autoFocus && e.focus();
                      break;
                    case "img":
                      A.src && (e.src = A.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (I.memoizedState === null) {
                  var c = I.alternate;
                  if (c !== null) {
                    var d = c.memoizedState;
                    if (d !== null) {
                      var i = d.dehydrated;
                      i !== null && dt(i);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(J(163));
            }
          Qg || (I.flags & 512 && ld(I));
        } catch (r) {
          Sg(I, I.return, r);
        }
      }
      if (I === g) {
        N = null;
        break;
      }
      if (((e = I.sibling), e !== null)) {
        (e.return = I.return), (N = e);
        break;
      }
      N = I.return;
    }
  }
  function Yr(g) {
    for (; N !== null; ) {
      var I = N;
      if (I === g) {
        N = null;
        break;
      }
      var e = I.sibling;
      if (e !== null) {
        (e.return = I.return), (N = e);
        break;
      }
      N = I.return;
    }
  }
  function Hr(g) {
    for (; N !== null; ) {
      var I = N;
      try {
        switch (I.tag) {
          case 0:
          case 11:
          case 15:
            var e = I.return;
            try {
              jo(4, I);
            } catch (A) {
              Sg(I, e, A);
            }
            break;
          case 1:
            var C = I.stateNode;
            if (typeof C.componentDidMount == "function") {
              var l = I.return;
              try {
                C.componentDidMount();
              } catch (A) {
                Sg(I, l, A);
              }
            }
            var t = I.return;
            try {
              ld(I);
            } catch (A) {
              Sg(I, t, A);
            }
            break;
          case 5:
            var n = I.return;
            try {
              ld(I);
            } catch (A) {
              Sg(I, n, A);
            }
        }
      } catch (A) {
        Sg(I, I.return, A);
      }
      if (I === g) {
        N = null;
        break;
      }
      var o = I.sibling;
      if (o !== null) {
        (o.return = I.return), (N = o);
        break;
      }
      N = I.return;
    }
  }
  var Tp = Math.ceil,
    mo = me.ReactCurrentDispatcher,
    Ri = me.ReactCurrentOwner,
    hI = me.ReactCurrentBatchConfig,
    lg = 0,
    Hg = null,
    Xg = null,
    Kg = 0,
    AI = 0,
    TC = $e(0),
    kg = 0,
    pt = null,
    uC = 0,
    Po = 0,
    Xi = 0,
    et = null,
    gI = null,
    Ji = 0,
    al = 1 / 0,
    Ce = null,
    Zo = !1,
    od = null,
    we = null,
    pn = !1,
    Re = null,
    Go = 0,
    Ct = 0,
    Ad = null,
    Un = -1,
    Qn = 0;
  function Pg() {
    return lg & 6 ? Wg() : Un !== -1 ? Un : (Un = Wg());
  }
  function Ne(g) {
    return g.mode & 1
      ? lg & 2 && Kg !== 0
        ? Kg & -Kg
        : vp.transition !== null
        ? (Qn === 0 && (Qn = uu()), Qn)
        : ((g = Ag),
          g !== 0 || ((g = window.event), (g = g === void 0 ? 16 : yu(g.type))),
          g)
      : 1;
  }
  function wI(g, I, e, C) {
    if (50 < Ct) throw ((Ct = 0), (Ad = null), Error(J(185)));
    Qt(g, e, C),
      (!(lg & 2) || g !== Hg) &&
        (g === Hg && (!(lg & 2) && (Po |= e), kg === 4 && Se(g, Kg)),
        lI(g, C),
        e === 1 &&
          lg === 0 &&
          !(I.mode & 1) &&
          ((al = Wg() + 500), Lo && gC()));
  }
  function lI(g, I) {
    var e = g.callbackNode;
    vB(g, I);
    var C = go(g, g === Hg ? Kg : 0);
    if (C === 0)
      e !== null && Ua(e), (g.callbackNode = null), (g.callbackPriority = 0);
    else if (((I = C & -C), g.callbackPriority !== I)) {
      if ((e != null && Ua(e), I === 1))
        g.tag === 0 ? Jp(wr.bind(null, g)) : zu(wr.bind(null, g)),
          Vp(function () {
            !(lg & 6) && gC();
          }),
          (e = null);
      else {
        switch (mu(C)) {
          case 1:
            e = Ii;
            break;
          case 4:
            e = ru;
            break;
          case 16:
            e = $n;
            break;
          case 536870912:
            e = su;
            break;
          default:
            e = $n;
        }
        e = xm(e, fm.bind(null, g));
      }
      (g.callbackPriority = I), (g.callbackNode = e);
    }
  }
  function fm(g, I) {
    if (((Un = -1), (Qn = 0), lg & 6)) throw Error(J(327));
    var e = g.callbackNode;
    if (Il() && g.callbackNode !== e) return null;
    var C = go(g, g === Hg ? Kg : 0);
    if (C === 0) return null;
    if (C & 30 || C & g.expiredLanes || I) I = bo(g, C);
    else {
      I = C;
      var l = lg;
      lg |= 2;
      var t = Hm();
      (Hg !== g || Kg !== I) && ((Ce = null), (al = Wg() + 500), cC(g, I));
      do
        try {
          Op();
          break;
        } catch (o) {
          Ym(g, o);
        }
      while (!0);
      si(),
        (mo.current = t),
        (lg = l),
        Xg !== null ? (I = 0) : ((Hg = null), (Kg = 0), (I = kg));
    }
    if (I !== 0) {
      if (
        (I === 2 && ((l = wc(g)), l !== 0 && ((C = l), (I = cd(g, l)))),
        I === 1)
      )
        throw ((e = pt), cC(g, 0), Se(g, C), lI(g, Wg()), e);
      if (I === 6) Se(g, C);
      else {
        if (
          ((l = g.current.alternate),
          !(C & 30) &&
            !jp(l) &&
            ((I = bo(g, C)),
            I === 2 && ((t = wc(g)), t !== 0 && ((C = t), (I = cd(g, t)))),
            I === 1))
        )
          throw ((e = pt), cC(g, 0), Se(g, C), lI(g, Wg()), e);
        switch (((g.finishedWork = l), (g.finishedLanes = C), I)) {
          case 0:
          case 1:
            throw Error(J(345));
          case 2:
            tC(g, gI, Ce);
            break;
          case 3:
            if (
              (Se(g, C),
              (C & 130023424) === C && ((I = Ji + 500 - Wg()), 10 < I))
            ) {
              if (go(g, 0) !== 0) break;
              if (((l = g.suspendedLanes), (l & C) !== C)) {
                Pg(), (g.pingedLanes |= g.suspendedLanes & l);
                break;
              }
              g.timeoutHandle = Uc(tC.bind(null, g, gI, Ce), I);
              break;
            }
            tC(g, gI, Ce);
            break;
          case 4:
            if ((Se(g, C), (C & 4194240) === C)) break;
            for (I = g.eventTimes, l = -1; 0 < C; ) {
              var n = 31 - HI(C);
              (t = 1 << n), (n = I[n]), n > l && (l = n), (C &= ~t);
            }
            if (
              ((C = l),
              (C = Wg() - C),
              (C =
                (120 > C
                  ? 120
                  : 480 > C
                  ? 480
                  : 1080 > C
                  ? 1080
                  : 1920 > C
                  ? 1920
                  : 3e3 > C
                  ? 3e3
                  : 4320 > C
                  ? 4320
                  : 1960 * Tp(C / 1960)) - C),
              10 < C)
            ) {
              g.timeoutHandle = Uc(tC.bind(null, g, gI, Ce), C);
              break;
            }
            tC(g, gI, Ce);
            break;
          case 5:
            tC(g, gI, Ce);
            break;
          default:
            throw Error(J(329));
        }
      }
    }
    return lI(g, Wg()), g.callbackNode === e ? fm.bind(null, g) : null;
  }
  function cd(g, I) {
    var e = et;
    return (
      g.current.memoizedState.isDehydrated && (cC(g, I).flags |= 256),
      (g = bo(g, I)),
      g !== 2 && ((I = gI), (gI = e), I !== null && dd(I)),
      g
    );
  }
  function dd(g) {
    gI === null ? (gI = g) : gI.push.apply(gI, g);
  }
  function jp(g) {
    for (var I = g; ; ) {
      if (I.flags & 16384) {
        var e = I.updateQueue;
        if (e !== null && ((e = e.stores), e !== null))
          for (var C = 0; C < e.length; C++) {
            var l = e[C],
              t = l.getSnapshot;
            l = l.value;
            try {
              if (!FI(t(), l)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((e = I.child), I.subtreeFlags & 16384 && e !== null))
        (e.return = I), (I = e);
      else {
        if (I === g) break;
        for (; I.sibling === null; ) {
          if (I.return === null || I.return === g) return !0;
          I = I.return;
        }
        (I.sibling.return = I.return), (I = I.sibling);
      }
    }
    return !0;
  }
  function Se(g, I) {
    for (
      I &= ~Xi,
        I &= ~Po,
        g.suspendedLanes |= I,
        g.pingedLanes &= ~I,
        g = g.expirationTimes;
      0 < I;

    ) {
      var e = 31 - HI(I),
        C = 1 << e;
      (g[e] = -1), (I &= ~C);
    }
  }
  function wr(g) {
    if (lg & 6) throw Error(J(327));
    Il();
    var I = go(g, 0);
    if (!(I & 1)) return lI(g, Wg()), null;
    var e = bo(g, I);
    if (g.tag !== 0 && e === 2) {
      var C = wc(g);
      C !== 0 && ((I = C), (e = cd(g, C)));
    }
    if (e === 1) throw ((e = pt), cC(g, 0), Se(g, I), lI(g, Wg()), e);
    if (e === 6) throw Error(J(345));
    return (
      (g.finishedWork = g.current.alternate),
      (g.finishedLanes = I),
      tC(g, gI, Ce),
      lI(g, Wg()),
      null
    );
  }
  function vi(g, I) {
    var e = lg;
    lg |= 1;
    try {
      return g(I);
    } finally {
      (lg = e), lg === 0 && ((al = Wg() + 500), Lo && gC());
    }
  }
  function mC(g) {
    Re !== null && Re.tag === 0 && !(lg & 6) && Il();
    var I = lg;
    lg |= 1;
    var e = hI.transition,
      C = Ag;
    try {
      if (((hI.transition = null), (Ag = 1), g)) return g();
    } finally {
      (Ag = C), (hI.transition = e), (lg = I), !(lg & 6) && gC();
    }
  }
  function ki() {
    (AI = TC.current), Zg(TC);
  }
  function cC(g, I) {
    (g.finishedWork = null), (g.finishedLanes = 0);
    var e = g.timeoutHandle;
    if ((e !== -1 && ((g.timeoutHandle = -1), Sp(e)), Xg !== null))
      for (e = Xg.return; e !== null; ) {
        var C = e;
        switch ((ii(C), C.tag)) {
          case 1:
            (C = C.type.childContextTypes), C != null && to();
            break;
          case 3:
            dl(), Zg(eI), Zg(Lg), Bi();
            break;
          case 5:
            bi(C);
            break;
          case 4:
            dl();
            break;
          case 13:
            Zg(pg);
            break;
          case 19:
            Zg(pg);
            break;
          case 10:
            ui(C.type._context);
            break;
          case 22:
          case 23:
            ki();
        }
        e = e.return;
      }
    if (
      ((Hg = g),
      (Xg = g = Ke(g.current, null)),
      (Kg = AI = I),
      (kg = 0),
      (pt = null),
      (Xi = Po = uC = 0),
      (gI = et = null),
      oC !== null)
    ) {
      for (I = 0; I < oC.length; I++)
        if (((e = oC[I]), (C = e.interleaved), C !== null)) {
          e.interleaved = null;
          var l = C.next,
            t = e.pending;
          if (t !== null) {
            var n = t.next;
            (t.next = l), (C.next = n);
          }
          e.pending = C;
        }
      oC = null;
    }
    return g;
  }
  function Ym(g, I) {
    do {
      var e = Xg;
      try {
        if ((si(), (Mn.current = uo), so)) {
          for (var C = yg.memoizedState; C !== null; ) {
            var l = C.queue;
            l !== null && (l.pending = null), (C = C.next);
          }
          so = !1;
        }
        if (
          ((sC = 0),
          (Yg = vg = yg = null),
          (gt = !1),
          (Gt = 0),
          (Ri.current = null),
          e === null || e.return === null)
        ) {
          (kg = 1), (pt = I), (Xg = null);
          break;
        }
        g: {
          var t = g,
            n = e.return,
            o = e,
            A = I;
          if (
            ((I = Kg),
            (o.flags |= 32768),
            A !== null && typeof A == "object" && typeof A.then == "function")
          ) {
            var c = A,
              d = o,
              i = d.tag;
            if (!(d.mode & 1) && (i === 0 || i === 11 || i === 15)) {
              var r = d.alternate;
              r
                ? ((d.updateQueue = r.updateQueue),
                  (d.memoizedState = r.memoizedState),
                  (d.lanes = r.lanes))
                : ((d.updateQueue = null), (d.memoizedState = null));
            }
            var u = yr(n);
            if (u !== null) {
              (u.flags &= -257),
                hr(u, n, o, t, I),
                u.mode & 1 && pr(t, c, I),
                (I = u),
                (A = c);
              var b = I.updateQueue;
              if (b === null) {
                var m = new Set();
                m.add(A), (I.updateQueue = m);
              } else b.add(A);
              break g;
            } else {
              if (!(I & 1)) {
                pr(t, c, I), fi();
                break g;
              }
              A = Error(J(426));
            }
          } else if (bg && o.mode & 1) {
            var p = yr(n);
            if (p !== null) {
              !(p.flags & 65536) && (p.flags |= 256),
                hr(p, n, o, t, I),
                ai(il(A, o));
              break g;
            }
          }
          (t = A = il(A, o)),
            kg !== 4 && (kg = 2),
            et === null ? (et = [t]) : et.push(t),
            (t = n);
          do {
            switch (t.tag) {
              case 3:
                (t.flags |= 65536), (I &= -I), (t.lanes |= I);
                var G = mm(t, A, I);
                ur(t, G);
                break g;
              case 1:
                o = A;
                var Z = t.type,
                  B = t.stateNode;
                if (
                  !(t.flags & 128) &&
                  (typeof Z.getDerivedStateFromError == "function" ||
                    (B !== null &&
                      typeof B.componentDidCatch == "function" &&
                      (we === null || !we.has(B))))
                ) {
                  (t.flags |= 65536), (I &= -I), (t.lanes |= I);
                  var y = Zm(t, o, I);
                  ur(t, y);
                  break g;
                }
            }
            t = t.return;
          } while (t !== null);
        }
        Nm(e);
      } catch (h) {
        (I = h), Xg === e && e !== null && (Xg = e = e.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Hm() {
    var g = mo.current;
    return (mo.current = uo), g === null ? uo : g;
  }
  function fi() {
    (kg === 0 || kg === 3 || kg === 2) && (kg = 4),
      Hg === null || (!(uC & 268435455) && !(Po & 268435455)) || Se(Hg, Kg);
  }
  function bo(g, I) {
    var e = lg;
    lg |= 2;
    var C = Hm();
    (Hg !== g || Kg !== I) && ((Ce = null), cC(g, I));
    do
      try {
        Pp();
        break;
      } catch (l) {
        Ym(g, l);
      }
    while (!0);
    if ((si(), (lg = e), (mo.current = C), Xg !== null)) throw Error(J(261));
    return (Hg = null), (Kg = 0), kg;
  }
  function Pp() {
    for (; Xg !== null; ) wm(Xg);
  }
  function Op() {
    for (; Xg !== null && !pB(); ) wm(Xg);
  }
  function wm(g) {
    var I = Fm(g.alternate, g, AI);
    (g.memoizedProps = g.pendingProps),
      I === null ? Nm(g) : (Xg = I),
      (Ri.current = null);
  }
  function Nm(g) {
    var I = g;
    do {
      var e = I.alternate;
      if (((g = I.return), I.flags & 32768)) {
        if (((e = Up(e, I)), e !== null)) {
          (e.flags &= 32767), (Xg = e);
          return;
        }
        if (g !== null)
          (g.flags |= 32768), (g.subtreeFlags = 0), (g.deletions = null);
        else {
          (kg = 6), (Xg = null);
          return;
        }
      } else if (((e = Ep(e, I, AI)), e !== null)) {
        Xg = e;
        return;
      }
      if (((I = I.sibling), I !== null)) {
        Xg = I;
        return;
      }
      Xg = I = g;
    } while (I !== null);
    kg === 0 && (kg = 5);
  }
  function tC(g, I, e) {
    var C = Ag,
      l = hI.transition;
    try {
      (hI.transition = null), (Ag = 1), _p(g, I, e, C);
    } finally {
      (hI.transition = l), (Ag = C);
    }
    return null;
  }
  function _p(g, I, e, C) {
    do Il();
    while (Re !== null);
    if (lg & 6) throw Error(J(327));
    e = g.finishedWork;
    var l = g.finishedLanes;
    if (e === null) return null;
    if (((g.finishedWork = null), (g.finishedLanes = 0), e === g.current))
      throw Error(J(177));
    (g.callbackNode = null), (g.callbackPriority = 0);
    var t = e.lanes | e.childLanes;
    if (
      (kB(g, t),
      g === Hg && ((Xg = Hg = null), (Kg = 0)),
      (!(e.subtreeFlags & 2064) && !(e.flags & 2064)) ||
        pn ||
        ((pn = !0),
        xm($n, function () {
          return Il(), null;
        })),
      (t = (e.flags & 15990) !== 0),
      e.subtreeFlags & 15990 || t)
    ) {
      (t = hI.transition), (hI.transition = null);
      var n = Ag;
      Ag = 1;
      var o = lg;
      (lg |= 4),
        (Ri.current = null),
        Lp(g, e),
        vm(e, g),
        Zp(zc),
        (Io = !!Mc),
        (zc = Mc = null),
        (g.current = e),
        Dp(e),
        yB(),
        (lg = o),
        (Ag = n),
        (hI.transition = t);
    } else g.current = e;
    if (
      (pn && ((pn = !1), (Re = g), (Go = l)),
      (t = g.pendingLanes),
      t === 0 && (we = null),
      VB(e.stateNode),
      lI(g, Wg()),
      I !== null)
    )
      for (C = g.onRecoverableError, e = 0; e < I.length; e++)
        (l = I[e]), C(l.value, { componentStack: l.stack, digest: l.digest });
    if (Zo) throw ((Zo = !1), (g = od), (od = null), g);
    return (
      Go & 1 && g.tag !== 0 && Il(),
      (t = g.pendingLanes),
      t & 1 ? (g === Ad ? Ct++ : ((Ct = 0), (Ad = g))) : (Ct = 0),
      gC(),
      null
    );
  }
  function Il() {
    if (Re !== null) {
      var g = mu(Go),
        I = hI.transition,
        e = Ag;
      try {
        if (((hI.transition = null), (Ag = 16 > g ? 16 : g), Re === null))
          var C = !1;
        else {
          if (((g = Re), (Re = null), (Go = 0), lg & 6)) throw Error(J(331));
          var l = lg;
          for (lg |= 4, N = g.current; N !== null; ) {
            var t = N,
              n = t.child;
            if (N.flags & 16) {
              var o = t.deletions;
              if (o !== null) {
                for (var A = 0; A < o.length; A++) {
                  var c = o[A];
                  for (N = c; N !== null; ) {
                    var d = N;
                    switch (d.tag) {
                      case 0:
                      case 11:
                      case 15:
                        It(8, d, t);
                    }
                    var i = d.child;
                    if (i !== null) (i.return = d), (N = i);
                    else
                      for (; N !== null; ) {
                        d = N;
                        var r = d.sibling,
                          u = d.return;
                        if ((Rm(d), d === c)) {
                          N = null;
                          break;
                        }
                        if (r !== null) {
                          (r.return = u), (N = r);
                          break;
                        }
                        N = u;
                      }
                  }
                }
                var b = t.alternate;
                if (b !== null) {
                  var m = b.child;
                  if (m !== null) {
                    b.child = null;
                    do {
                      var p = m.sibling;
                      (m.sibling = null), (m = p);
                    } while (m !== null);
                  }
                }
                N = t;
              }
            }
            if (t.subtreeFlags & 2064 && n !== null) (n.return = t), (N = n);
            else
              g: for (; N !== null; ) {
                if (((t = N), t.flags & 2048))
                  switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                      It(9, t, t.return);
                  }
                var G = t.sibling;
                if (G !== null) {
                  (G.return = t.return), (N = G);
                  break g;
                }
                N = t.return;
              }
          }
          var Z = g.current;
          for (N = Z; N !== null; ) {
            n = N;
            var B = n.child;
            if (n.subtreeFlags & 2064 && B !== null) (B.return = n), (N = B);
            else
              g: for (n = Z; N !== null; ) {
                if (((o = N), o.flags & 2048))
                  try {
                    switch (o.tag) {
                      case 0:
                      case 11:
                      case 15:
                        jo(9, o);
                    }
                  } catch (h) {
                    Sg(o, o.return, h);
                  }
                if (o === n) {
                  N = null;
                  break g;
                }
                var y = o.sibling;
                if (y !== null) {
                  (y.return = o.return), (N = y);
                  break g;
                }
                N = o.return;
              }
          }
          if (
            ((lg = l),
            gC(),
            TI && typeof TI.onPostCommitFiberRoot == "function")
          )
            try {
              TI.onPostCommitFiberRoot(Mo, g);
            } catch {}
          C = !0;
        }
        return C;
      } finally {
        (Ag = e), (hI.transition = I);
      }
    }
    return !1;
  }
  function Nr(g, I, e) {
    (I = il(e, I)),
      (I = mm(g, I, 1)),
      (g = He(g, I, 1)),
      (I = Pg()),
      g !== null && (Qt(g, 1, I), lI(g, I));
  }
  function Sg(g, I, e) {
    if (g.tag === 3) Nr(g, g, e);
    else
      for (; I !== null; ) {
        if (I.tag === 3) {
          Nr(I, g, e);
          break;
        } else if (I.tag === 1) {
          var C = I.stateNode;
          if (
            typeof I.type.getDerivedStateFromError == "function" ||
            (typeof C.componentDidCatch == "function" &&
              (we === null || !we.has(C)))
          ) {
            (g = il(e, g)),
              (g = Zm(I, g, 1)),
              (I = He(I, g, 1)),
              (g = Pg()),
              I !== null && (Qt(I, 1, g), lI(I, g));
            break;
          }
        }
        I = I.return;
      }
  }
  function qp(g, I, e) {
    var C = g.pingCache;
    C !== null && C.delete(I),
      (I = Pg()),
      (g.pingedLanes |= g.suspendedLanes & e),
      Hg === g &&
        (Kg & e) === e &&
        (kg === 4 || (kg === 3 && (Kg & 130023424) === Kg && 500 > Wg() - Ji)
          ? cC(g, 0)
          : (Xi |= e)),
      lI(g, I);
  }
  function Km(g, I) {
    I === 0 &&
      (g.mode & 1
        ? ((I = dn), (dn <<= 1), !(dn & 130023424) && (dn = 4194304))
        : (I = 1));
    var e = Pg();
    (g = ie(g, I)), g !== null && (Qt(g, I, e), lI(g, e));
  }
  function $p(g) {
    var I = g.memoizedState,
      e = 0;
    I !== null && (e = I.retryLane), Km(g, e);
  }
  function gy(g, I) {
    var e = 0;
    switch (g.tag) {
      case 13:
        var C = g.stateNode,
          l = g.memoizedState;
        l !== null && (e = l.retryLane);
        break;
      case 19:
        C = g.stateNode;
        break;
      default:
        throw Error(J(314));
    }
    C !== null && C.delete(I), Km(g, e);
  }
  var Fm;
  Fm = function (g, I, e) {
    if (g !== null)
      if (g.memoizedProps !== I.pendingProps || eI.current) II = !0;
      else {
        if (!(g.lanes & e) && !(I.flags & 128)) return (II = !1), zp(g, I, e);
        II = !!(g.flags & 131072);
      }
    else (II = !1), bg && I.flags & 1048576 && Eu(I, Ao, I.index);
    switch (((I.lanes = 0), I.tag)) {
      case 2:
        var C = I.type;
        En(g, I), (g = I.pendingProps);
        var l = ol(I, Lg.current);
        gl(I, e), (l = yi(null, I, C, g, l, e));
        var t = hi();
        return (
          (I.flags |= 1),
          typeof l == "object" &&
          l !== null &&
          typeof l.render == "function" &&
          l.$$typeof === void 0
            ? ((I.tag = 1),
              (I.memoizedState = null),
              (I.updateQueue = null),
              CI(C) ? ((t = !0), no(I)) : (t = !1),
              (I.memoizedState =
                l.state !== null && l.state !== void 0 ? l.state : null),
              Zi(I),
              (l.updater = To),
              (I.stateNode = l),
              (l._reactInternals = I),
              Oc(I, C, g, e),
              (I = $c(null, I, C, !0, t, e)))
            : ((I.tag = 0), bg && t && di(I), jg(null, I, l, e), (I = I.child)),
          I
        );
      case 16:
        C = I.elementType;
        g: {
          switch (
            (En(g, I),
            (g = I.pendingProps),
            (l = C._init),
            (C = l(C._payload)),
            (I.type = C),
            (l = I.tag = ey(C)),
            (g = vI(C, g)),
            l)
          ) {
            case 0:
              I = qc(null, I, C, g, e);
              break g;
            case 1:
              I = Wr(null, I, C, g, e);
              break g;
            case 11:
              I = Sr(null, I, C, g, e);
              break g;
            case 14:
              I = Vr(null, I, C, vI(C.type, g), e);
              break g;
          }
          throw Error(J(306, C, ""));
        }
        return I;
      case 0:
        return (
          (C = I.type),
          (l = I.pendingProps),
          (l = I.elementType === C ? l : vI(C, l)),
          qc(g, I, C, l, e)
        );
      case 1:
        return (
          (C = I.type),
          (l = I.pendingProps),
          (l = I.elementType === C ? l : vI(C, l)),
          Wr(g, I, C, l, e)
        );
      case 3:
        g: {
          if ((pm(I), g === null)) throw Error(J(387));
          (C = I.pendingProps),
            (t = I.memoizedState),
            (l = t.element),
            ju(g, I),
            ao(I, C, null, e);
          var n = I.memoizedState;
          if (((C = n.element), t.isDehydrated))
            if (
              ((t = {
                element: C,
                isDehydrated: !1,
                cache: n.cache,
                pendingSuspenseBoundaries: n.pendingSuspenseBoundaries,
                transitions: n.transitions,
              }),
              (I.updateQueue.baseState = t),
              (I.memoizedState = t),
              I.flags & 256)
            ) {
              (l = il(Error(J(423)), I)), (I = Rr(g, I, C, e, l));
              break g;
            } else if (C !== l) {
              (l = il(Error(J(424)), I)), (I = Rr(g, I, C, e, l));
              break g;
            } else
              for (
                iI = Ye(I.stateNode.containerInfo.firstChild),
                  aI = I,
                  bg = !0,
                  fI = null,
                  e = Du(I, null, C, e),
                  I.child = e;
                e;

              )
                (e.flags = (e.flags & -3) | 4096), (e = e.sibling);
          else {
            if ((Al(), C === l)) {
              I = ae(g, I, e);
              break g;
            }
            jg(g, I, C, e);
          }
          I = I.child;
        }
        return I;
      case 5:
        return (
          Pu(I),
          g === null && Tc(I),
          (C = I.type),
          (l = I.pendingProps),
          (t = g !== null ? g.memoizedProps : null),
          (n = l.children),
          Ec(C, l) ? (n = null) : t !== null && Ec(C, t) && (I.flags |= 32),
          Bm(g, I),
          jg(g, I, n, e),
          I.child
        );
      case 6:
        return g === null && Tc(I), null;
      case 13:
        return ym(g, I, e);
      case 4:
        return (
          Gi(I, I.stateNode.containerInfo),
          (C = I.pendingProps),
          g === null ? (I.child = cl(I, null, C, e)) : jg(g, I, C, e),
          I.child
        );
      case 11:
        return (
          (C = I.type),
          (l = I.pendingProps),
          (l = I.elementType === C ? l : vI(C, l)),
          Sr(g, I, C, l, e)
        );
      case 7:
        return jg(g, I, I.pendingProps, e), I.child;
      case 8:
        return jg(g, I, I.pendingProps.children, e), I.child;
      case 12:
        return jg(g, I, I.pendingProps.children, e), I.child;
      case 10:
        g: {
          if (
            ((C = I.type._context),
            (l = I.pendingProps),
            (t = I.memoizedProps),
            (n = l.value),
            sg(co, C._currentValue),
            (C._currentValue = n),
            t !== null)
          )
            if (FI(t.value, n)) {
              if (t.children === l.children && !eI.current) {
                I = ae(g, I, e);
                break g;
              }
            } else
              for (t = I.child, t !== null && (t.return = I); t !== null; ) {
                var o = t.dependencies;
                if (o !== null) {
                  n = t.child;
                  for (var A = o.firstContext; A !== null; ) {
                    if (A.context === C) {
                      if (t.tag === 1) {
                        (A = Ae(-1, e & -e)), (A.tag = 2);
                        var c = t.updateQueue;
                        if (c !== null) {
                          c = c.shared;
                          var d = c.pending;
                          d === null
                            ? (A.next = A)
                            : ((A.next = d.next), (d.next = A)),
                            (c.pending = A);
                        }
                      }
                      (t.lanes |= e),
                        (A = t.alternate),
                        A !== null && (A.lanes |= e),
                        jc(t.return, e, I),
                        (o.lanes |= e);
                      break;
                    }
                    A = A.next;
                  }
                } else if (t.tag === 10) n = t.type === I.type ? null : t.child;
                else if (t.tag === 18) {
                  if (((n = t.return), n === null)) throw Error(J(341));
                  (n.lanes |= e),
                    (o = n.alternate),
                    o !== null && (o.lanes |= e),
                    jc(n, e, I),
                    (n = t.sibling);
                } else n = t.child;
                if (n !== null) n.return = t;
                else
                  for (n = t; n !== null; ) {
                    if (n === I) {
                      n = null;
                      break;
                    }
                    if (((t = n.sibling), t !== null)) {
                      (t.return = n.return), (n = t);
                      break;
                    }
                    n = n.return;
                  }
                t = n;
              }
          jg(g, I, l.children, e), (I = I.child);
        }
        return I;
      case 9:
        return (
          (l = I.type),
          (C = I.pendingProps.children),
          gl(I, e),
          (l = VI(l)),
          (C = C(l)),
          (I.flags |= 1),
          jg(g, I, C, e),
          I.child
        );
      case 14:
        return (
          (C = I.type),
          (l = vI(C, I.pendingProps)),
          (l = vI(C.type, l)),
          Vr(g, I, C, l, e)
        );
      case 15:
        return Gm(g, I, I.type, I.pendingProps, e);
      case 17:
        return (
          (C = I.type),
          (l = I.pendingProps),
          (l = I.elementType === C ? l : vI(C, l)),
          En(g, I),
          (I.tag = 1),
          CI(C) ? ((g = !0), no(I)) : (g = !1),
          gl(I, e),
          um(I, C, l),
          Oc(I, C, l, e),
          $c(null, I, C, !0, g, e)
        );
      case 19:
        return hm(g, I, e);
      case 22:
        return bm(g, I, e);
    }
    throw Error(J(156, I.tag));
  };
  function xm(g, I) {
    return au(g, I);
  }
  function Iy(g, I, e, C) {
    (this.tag = g),
      (this.key = e),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = I),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = C),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function yI(g, I, e, C) {
    return new Iy(g, I, e, C);
  }
  function Yi(g) {
    return (g = g.prototype), !(!g || !g.isReactComponent);
  }
  function ey(g) {
    if (typeof g == "function") return Yi(g) ? 1 : 0;
    if (g != null) {
      if (((g = g.$$typeof), g === qd)) return 11;
      if (g === $d) return 14;
    }
    return 2;
  }
  function Ke(g, I) {
    var e = g.alternate;
    return (
      e === null
        ? ((e = yI(g.tag, I, g.key, g.mode)),
          (e.elementType = g.elementType),
          (e.type = g.type),
          (e.stateNode = g.stateNode),
          (e.alternate = g),
          (g.alternate = e))
        : ((e.pendingProps = I),
          (e.type = g.type),
          (e.flags = 0),
          (e.subtreeFlags = 0),
          (e.deletions = null)),
      (e.flags = g.flags & 14680064),
      (e.childLanes = g.childLanes),
      (e.lanes = g.lanes),
      (e.child = g.child),
      (e.memoizedProps = g.memoizedProps),
      (e.memoizedState = g.memoizedState),
      (e.updateQueue = g.updateQueue),
      (I = g.dependencies),
      (e.dependencies =
        I === null ? null : { lanes: I.lanes, firstContext: I.firstContext }),
      (e.sibling = g.sibling),
      (e.index = g.index),
      (e.ref = g.ref),
      e
    );
  }
  function Ln(g, I, e, C, l, t) {
    var n = 2;
    if (((C = g), typeof g == "function")) Yi(g) && (n = 1);
    else if (typeof g == "string") n = 5;
    else
      g: switch (g) {
        case KC:
          return dC(e.children, l, t, I);
        case _d:
          (n = 8), (l |= 8);
          break;
        case Bc:
          return (
            (g = yI(12, e, I, l | 2)), (g.elementType = Bc), (g.lanes = t), g
          );
        case pc:
          return (g = yI(13, e, I, l)), (g.elementType = pc), (g.lanes = t), g;
        case yc:
          return (g = yI(19, e, I, l)), (g.elementType = yc), (g.lanes = t), g;
        case Ps:
          return Oo(e, l, t, I);
        default:
          if (typeof g == "object" && g !== null)
            switch (g.$$typeof) {
              case Ts:
                n = 10;
                break g;
              case js:
                n = 9;
                break g;
              case qd:
                n = 11;
                break g;
              case $d:
                n = 14;
                break g;
              case pe:
                (n = 16), (C = null);
                break g;
            }
          throw Error(J(130, g == null ? g : typeof g, ""));
      }
    return (
      (I = yI(n, e, I, l)), (I.elementType = g), (I.type = C), (I.lanes = t), I
    );
  }
  function dC(g, I, e, C) {
    return (g = yI(7, g, C, I)), (g.lanes = e), g;
  }
  function Oo(g, I, e, C) {
    return (
      (g = yI(22, g, C, I)),
      (g.elementType = Ps),
      (g.lanes = e),
      (g.stateNode = { isHidden: !1 }),
      g
    );
  }
  function _A(g, I, e) {
    return (g = yI(6, g, null, I)), (g.lanes = e), g;
  }
  function qA(g, I, e) {
    return (
      (I = yI(4, g.children !== null ? g.children : [], g.key, I)),
      (I.lanes = e),
      (I.stateNode = {
        containerInfo: g.containerInfo,
        pendingChildren: null,
        implementation: g.implementation,
      }),
      I
    );
  }
  function Cy(g, I, e, C, l) {
    (this.tag = I),
      (this.containerInfo = g),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = fA(0)),
      (this.expirationTimes = fA(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = fA(0)),
      (this.identifierPrefix = C),
      (this.onRecoverableError = l),
      (this.mutableSourceEagerHydrationData = null);
  }
  function Hi(g, I, e, C, l, t, n, o, A) {
    return (
      (g = new Cy(g, I, e, o, A)),
      I === 1 ? ((I = 1), t === !0 && (I |= 8)) : (I = 0),
      (t = yI(3, null, null, I)),
      (g.current = t),
      (t.stateNode = g),
      (t.memoizedState = {
        element: C,
        isDehydrated: e,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      Zi(t),
      g
    );
  }
  function ly(g, I, e) {
    var C =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: NC,
      key: C == null ? null : "" + C,
      children: g,
      containerInfo: I,
      implementation: e,
    };
  }
  function Mm(g) {
    if (!g) return ze;
    g = g._reactInternals;
    g: {
      if (SC(g) !== g || g.tag !== 1) throw Error(J(170));
      var I = g;
      do {
        switch (I.tag) {
          case 3:
            I = I.stateNode.context;
            break g;
          case 1:
            if (CI(I.type)) {
              I = I.stateNode.__reactInternalMemoizedMergedChildContext;
              break g;
            }
        }
        I = I.return;
      } while (I !== null);
      throw Error(J(171));
    }
    if (g.tag === 1) {
      var e = g.type;
      if (CI(e)) return Mu(g, e, I);
    }
    return I;
  }
  function zm(g, I, e, C, l, t, n, o, A) {
    return (
      (g = Hi(e, C, !0, g, l, t, n, o, A)),
      (g.context = Mm(null)),
      (e = g.current),
      (C = Pg()),
      (l = Ne(e)),
      (t = Ae(C, l)),
      (t.callback = I ?? null),
      He(e, t, l),
      (g.current.lanes = l),
      Qt(g, l, C),
      lI(g, C),
      g
    );
  }
  function _o(g, I, e, C) {
    var l = I.current,
      t = Pg(),
      n = Ne(l);
    return (
      (e = Mm(e)),
      I.context === null ? (I.context = e) : (I.pendingContext = e),
      (I = Ae(t, n)),
      (I.payload = { element: g }),
      (C = C === void 0 ? null : C),
      C !== null && (I.callback = C),
      (g = He(l, I, n)),
      g !== null && (wI(g, l, n, t), xn(g, l, n)),
      n
    );
  }
  function Bo(g) {
    if (((g = g.current), !g.child)) return null;
    switch (g.child.tag) {
      case 5:
        return g.child.stateNode;
      default:
        return g.child.stateNode;
    }
  }
  function Kr(g, I) {
    if (((g = g.memoizedState), g !== null && g.dehydrated !== null)) {
      var e = g.retryLane;
      g.retryLane = e !== 0 && e < I ? e : I;
    }
  }
  function wi(g, I) {
    Kr(g, I), (g = g.alternate) && Kr(g, I);
  }
  function ty() {
    return null;
  }
  var Em =
    typeof reportError == "function"
      ? reportError
      : function (g) {
          console.error(g);
        };
  function Ni(g) {
    this._internalRoot = g;
  }
  qo.prototype.render = Ni.prototype.render = function (g) {
    var I = this._internalRoot;
    if (I === null) throw Error(J(409));
    _o(g, I, null, null);
  };
  qo.prototype.unmount = Ni.prototype.unmount = function () {
    var g = this._internalRoot;
    if (g !== null) {
      this._internalRoot = null;
      var I = g.containerInfo;
      mC(function () {
        _o(null, g, null, null);
      }),
        (I[de] = null);
    }
  };
  function qo(g) {
    this._internalRoot = g;
  }
  qo.prototype.unstable_scheduleHydration = function (g) {
    if (g) {
      var I = bu();
      g = { blockedOn: null, target: g, priority: I };
      for (var e = 0; e < he.length && I !== 0 && I < he[e].priority; e++);
      he.splice(e, 0, g), e === 0 && pu(g);
    }
  };
  function Ki(g) {
    return !(!g || (g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11));
  }
  function $o(g) {
    return !(
      !g ||
      (g.nodeType !== 1 &&
        g.nodeType !== 9 &&
        g.nodeType !== 11 &&
        (g.nodeType !== 8 || g.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function Fr() {}
  function ny(g, I, e, C, l) {
    if (l) {
      if (typeof C == "function") {
        var t = C;
        C = function () {
          var c = Bo(n);
          t.call(c);
        };
      }
      var n = zm(I, C, g, 0, null, !1, !1, "", Fr);
      return (
        (g._reactRootContainer = n),
        (g[de] = n.current),
        rt(g.nodeType === 8 ? g.parentNode : g),
        mC(),
        n
      );
    }
    for (; (l = g.lastChild); ) g.removeChild(l);
    if (typeof C == "function") {
      var o = C;
      C = function () {
        var c = Bo(A);
        o.call(c);
      };
    }
    var A = Hi(g, 0, !1, null, null, !1, !1, "", Fr);
    return (
      (g._reactRootContainer = A),
      (g[de] = A.current),
      rt(g.nodeType === 8 ? g.parentNode : g),
      mC(function () {
        _o(I, A, e, C);
      }),
      A
    );
  }
  function gA(g, I, e, C, l) {
    var t = e._reactRootContainer;
    if (t) {
      var n = t;
      if (typeof l == "function") {
        var o = l;
        l = function () {
          var A = Bo(n);
          o.call(A);
        };
      }
      _o(I, n, g, l);
    } else n = ny(e, I, g, l, C);
    return Bo(n);
  }
  Zu = function (g) {
    switch (g.tag) {
      case 3:
        var I = g.stateNode;
        if (I.current.memoizedState.isDehydrated) {
          var e = Ul(I.pendingLanes);
          e !== 0 &&
            (ei(I, e | 1), lI(I, Wg()), !(lg & 6) && ((al = Wg() + 500), gC()));
        }
        break;
      case 13:
        mC(function () {
          var C = ie(g, 1);
          if (C !== null) {
            var l = Pg();
            wI(C, g, 1, l);
          }
        }),
          wi(g, 1);
    }
  };
  Ci = function (g) {
    if (g.tag === 13) {
      var I = ie(g, 134217728);
      if (I !== null) {
        var e = Pg();
        wI(I, g, 134217728, e);
      }
      wi(g, 134217728);
    }
  };
  Gu = function (g) {
    if (g.tag === 13) {
      var I = Ne(g),
        e = ie(g, I);
      if (e !== null) {
        var C = Pg();
        wI(e, g, I, C);
      }
      wi(g, I);
    }
  };
  bu = function () {
    return Ag;
  };
  Bu = function (g, I) {
    var e = Ag;
    try {
      return (Ag = g), I();
    } finally {
      Ag = e;
    }
  };
  fc = function (g, I, e) {
    switch (I) {
      case "input":
        if ((Vc(g, e), (I = e.name), e.type === "radio" && I != null)) {
          for (e = g; e.parentNode; ) e = e.parentNode;
          for (
            e = e.querySelectorAll(
              "input[name=" + JSON.stringify("" + I) + '][type="radio"]'
            ),
              I = 0;
            I < e.length;
            I++
          ) {
            var C = e[I];
            if (C !== g && C.form === g.form) {
              var l = Qo(C);
              if (!l) throw Error(J(90));
              _s(C), Vc(C, l);
            }
          }
        }
        break;
      case "textarea":
        $s(g, e);
        break;
      case "select":
        (I = e.value), I != null && OC(g, !!e.multiple, I, !1);
    }
  };
  nu = vi;
  ou = mC;
  var oy = { usingClientEntryPoint: !1, Events: [Dt, zC, Qo, lu, tu, vi] },
    Kl = {
      findFiberByHostInstance: nC,
      bundleType: 0,
      version: "18.3.1",
      rendererPackageName: "react-dom",
    },
    Ay = {
      bundleType: Kl.bundleType,
      version: Kl.version,
      rendererPackageName: Kl.rendererPackageName,
      rendererConfig: Kl.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: me.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (g) {
        return (g = du(g)), g === null ? null : g.stateNode;
      },
      findFiberByHostInstance: Kl.findFiberByHostInstance || ty,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var yn = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!yn.isDisabled && yn.supportsFiber)
      try {
        (Mo = yn.inject(Ay)), (TI = yn);
      } catch {}
  }
  ZI.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oy;
  ZI.createPortal = function (g, I) {
    var e =
      2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Ki(I)) throw Error(J(200));
    return ly(g, I, null, e);
  };
  ZI.createRoot = function (g, I) {
    if (!Ki(g)) throw Error(J(299));
    var e = !1,
      C = "",
      l = Em;
    return (
      I != null &&
        (I.unstable_strictMode === !0 && (e = !0),
        I.identifierPrefix !== void 0 && (C = I.identifierPrefix),
        I.onRecoverableError !== void 0 && (l = I.onRecoverableError)),
      (I = Hi(g, 1, !1, null, null, e, !1, C, l)),
      (g[de] = I.current),
      rt(g.nodeType === 8 ? g.parentNode : g),
      new Ni(I)
    );
  };
  ZI.findDOMNode = function (g) {
    if (g == null) return null;
    if (g.nodeType === 1) return g;
    var I = g._reactInternals;
    if (I === void 0)
      throw typeof g.render == "function"
        ? Error(J(188))
        : ((g = Object.keys(g).join(",")), Error(J(268, g)));
    return (g = du(I)), (g = g === null ? null : g.stateNode), g;
  };
  ZI.flushSync = function (g) {
    return mC(g);
  };
  ZI.hydrate = function (g, I, e) {
    if (!$o(I)) throw Error(J(200));
    return gA(null, g, I, !0, e);
  };
  ZI.hydrateRoot = function (g, I, e) {
    if (!Ki(g)) throw Error(J(405));
    var C = (e != null && e.hydratedSources) || null,
      l = !1,
      t = "",
      n = Em;
    if (
      (e != null &&
        (e.unstable_strictMode === !0 && (l = !0),
        e.identifierPrefix !== void 0 && (t = e.identifierPrefix),
        e.onRecoverableError !== void 0 && (n = e.onRecoverableError)),
      (I = zm(I, null, g, 1, e ?? null, l, !1, t, n)),
      (g[de] = I.current),
      rt(g),
      C)
    )
      for (g = 0; g < C.length; g++)
        (e = C[g]),
          (l = e._getVersion),
          (l = l(e._source)),
          I.mutableSourceEagerHydrationData == null
            ? (I.mutableSourceEagerHydrationData = [e, l])
            : I.mutableSourceEagerHydrationData.push(e, l);
    return new qo(I);
  };
  ZI.render = function (g, I, e) {
    if (!$o(I)) throw Error(J(200));
    return gA(null, g, I, !1, e);
  };
  ZI.unmountComponentAtNode = function (g) {
    if (!$o(g)) throw Error(J(40));
    return g._reactRootContainer
      ? (mC(function () {
          gA(null, null, g, !1, function () {
            (g._reactRootContainer = null), (g[de] = null);
          });
        }),
        !0)
      : !1;
  };
  ZI.unstable_batchedUpdates = vi;
  ZI.unstable_renderSubtreeIntoContainer = function (g, I, e, C) {
    if (!$o(e)) throw Error(J(200));
    if (g == null || g._reactInternals === void 0) throw Error(J(38));
    return gA(g, I, e, !1, C);
  };
  ZI.version = "18.3.1-next-f1338f8080-20240426";
  function Um() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Um);
      } catch (g) {
        console.error(g);
      }
  }
  Um(), (Us.exports = ZI);
  var jt = Us.exports;
  const Qm = vs(jt);
  /**
   * @remix-run/router v1.20.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */ function yt() {
    return (
      (yt = Object.assign
        ? Object.assign.bind()
        : function (g) {
            for (var I = 1; I < arguments.length; I++) {
              var e = arguments[I];
              for (var C in e)
                Object.prototype.hasOwnProperty.call(e, C) && (g[C] = e[C]);
            }
            return g;
          }),
      yt.apply(this, arguments)
    );
  }
  var Xe;
  (function (g) {
    (g.Pop = "POP"), (g.Push = "PUSH"), (g.Replace = "REPLACE");
  })(Xe || (Xe = {}));
  const xr = "popstate";
  function cy(g) {
    g === void 0 && (g = {});
    function I(C, l) {
      let { pathname: t, search: n, hash: o } = C.location;
      return id(
        "",
        { pathname: t, search: n, hash: o },
        (l.state && l.state.usr) || null,
        (l.state && l.state.key) || "default"
      );
    }
    function e(C, l) {
      return typeof l == "string" ? l : po(l);
    }
    return iy(I, e, null, g);
  }
  function Jg(g, I) {
    if (g === !1 || g === null || typeof g > "u") throw new Error(I);
  }
  function Lm(g, I) {
    if (!g) {
      typeof console < "u" && console.warn(I);
      try {
        throw new Error(I);
      } catch {}
    }
  }
  function dy() {
    return Math.random().toString(36).substr(2, 8);
  }
  function Mr(g, I) {
    return { usr: g.state, key: g.key, idx: I };
  }
  function id(g, I, e, C) {
    return (
      e === void 0 && (e = null),
      yt(
        {
          pathname: typeof g == "string" ? g : g.pathname,
          search: "",
          hash: "",
        },
        typeof I == "string" ? pl(I) : I,
        { state: e, key: (I && I.key) || C || dy() }
      )
    );
  }
  function po(g) {
    let { pathname: I = "/", search: e = "", hash: C = "" } = g;
    return (
      e && e !== "?" && (I += e.charAt(0) === "?" ? e : "?" + e),
      C && C !== "#" && (I += C.charAt(0) === "#" ? C : "#" + C),
      I
    );
  }
  function pl(g) {
    let I = {};
    if (g) {
      let e = g.indexOf("#");
      e >= 0 && ((I.hash = g.substr(e)), (g = g.substr(0, e)));
      let C = g.indexOf("?");
      C >= 0 && ((I.search = g.substr(C)), (g = g.substr(0, C))),
        g && (I.pathname = g);
    }
    return I;
  }
  function iy(g, I, e, C) {
    C === void 0 && (C = {});
    let { window: l = document.defaultView, v5Compat: t = !1 } = C,
      n = l.history,
      o = Xe.Pop,
      A = null,
      c = d();
    c == null && ((c = 0), n.replaceState(yt({}, n.state, { idx: c }), ""));
    function d() {
      return (n.state || { idx: null }).idx;
    }
    function i() {
      o = Xe.Pop;
      let p = d(),
        G = p == null ? null : p - c;
      (c = p), A && A({ action: o, location: m.location, delta: G });
    }
    function r(p, G) {
      o = Xe.Push;
      let Z = id(m.location, p, G);
      c = d() + 1;
      let B = Mr(Z, c),
        y = m.createHref(Z);
      try {
        n.pushState(B, "", y);
      } catch (h) {
        if (h instanceof DOMException && h.name === "DataCloneError") throw h;
        l.location.assign(y);
      }
      t && A && A({ action: o, location: m.location, delta: 1 });
    }
    function u(p, G) {
      o = Xe.Replace;
      let Z = id(m.location, p, G);
      c = d();
      let B = Mr(Z, c),
        y = m.createHref(Z);
      n.replaceState(B, "", y),
        t && A && A({ action: o, location: m.location, delta: 0 });
    }
    function b(p) {
      let G =
          l.location.origin !== "null" ? l.location.origin : l.location.href,
        Z = typeof p == "string" ? p : po(p);
      return (
        (Z = Z.replace(/ $/, "%20")),
        Jg(
          G,
          "No window.location.(origin|href) available to create URL for href: " +
            Z
        ),
        new URL(Z, G)
      );
    }
    let m = {
      get action() {
        return o;
      },
      get location() {
        return g(l, n);
      },
      listen(p) {
        if (A) throw new Error("A history only accepts one active listener");
        return (
          l.addEventListener(xr, i),
          (A = p),
          () => {
            l.removeEventListener(xr, i), (A = null);
          }
        );
      },
      createHref(p) {
        return I(l, p);
      },
      createURL: b,
      encodeLocation(p) {
        let G = b(p);
        return { pathname: G.pathname, search: G.search, hash: G.hash };
      },
      push: r,
      replace: u,
      go(p) {
        return n.go(p);
      },
    };
    return m;
  }
  var zr;
  (function (g) {
    (g.data = "data"),
      (g.deferred = "deferred"),
      (g.redirect = "redirect"),
      (g.error = "error");
  })(zr || (zr = {}));
  function ay(g, I, e) {
    return e === void 0 && (e = "/"), ry(g, I, e, !1);
  }
  function ry(g, I, e, C) {
    let l = typeof I == "string" ? pl(I) : I,
      t = Fi(l.pathname || "/", e);
    if (t == null) return null;
    let n = Dm(g);
    sy(n);
    let o = null;
    for (let A = 0; o == null && A < n.length; ++A) {
      let c = Vy(t);
      o = hy(n[A], c, C);
    }
    return o;
  }
  function Dm(g, I, e, C) {
    I === void 0 && (I = []),
      e === void 0 && (e = []),
      C === void 0 && (C = "");
    let l = (t, n, o) => {
      let A = {
        relativePath: o === void 0 ? t.path || "" : o,
        caseSensitive: t.caseSensitive === !0,
        childrenIndex: n,
        route: t,
      };
      A.relativePath.startsWith("/") &&
        (Jg(
          A.relativePath.startsWith(C),
          'Absolute route path "' +
            A.relativePath +
            '" nested under path ' +
            ('"' + C + '" is not valid. An absolute child route path ') +
            "must start with the combined path of all its parent routes."
        ),
        (A.relativePath = A.relativePath.slice(C.length)));
      let c = Fe([C, A.relativePath]),
        d = e.concat(A);
      t.children &&
        t.children.length > 0 &&
        (Jg(
          t.index !== !0,
          "Index routes must not have child routes. Please remove " +
            ('all child routes from route path "' + c + '".')
        ),
        Dm(t.children, I, d, c)),
        !(t.path == null && !t.index) &&
          I.push({ path: c, score: py(c, t.index), routesMeta: d });
    };
    return (
      g.forEach((t, n) => {
        var o;
        if (t.path === "" || !((o = t.path) != null && o.includes("?")))
          l(t, n);
        else for (let A of Tm(t.path)) l(t, n, A);
      }),
      I
    );
  }
  function Tm(g) {
    let I = g.split("/");
    if (I.length === 0) return [];
    let [e, ...C] = I,
      l = e.endsWith("?"),
      t = e.replace(/\?$/, "");
    if (C.length === 0) return l ? [t, ""] : [t];
    let n = Tm(C.join("/")),
      o = [];
    return (
      o.push(...n.map((A) => (A === "" ? t : [t, A].join("/")))),
      l && o.push(...n),
      o.map((A) => (g.startsWith("/") && A === "" ? "/" : A))
    );
  }
  function sy(g) {
    g.sort((I, e) =>
      I.score !== e.score
        ? e.score - I.score
        : yy(
            I.routesMeta.map((C) => C.childrenIndex),
            e.routesMeta.map((C) => C.childrenIndex)
          )
    );
  }
  const uy = /^:[\w-]+$/,
    my = 3,
    Zy = 2,
    Gy = 1,
    by = 10,
    By = -2,
    Er = (g) => g === "*";
  function py(g, I) {
    let e = g.split("/"),
      C = e.length;
    return (
      e.some(Er) && (C += By),
      I && (C += Zy),
      e
        .filter((l) => !Er(l))
        .reduce((l, t) => l + (uy.test(t) ? my : t === "" ? Gy : by), C)
    );
  }
  function yy(g, I) {
    return g.length === I.length && g.slice(0, -1).every((C, l) => C === I[l])
      ? g[g.length - 1] - I[I.length - 1]
      : 0;
  }
  function hy(g, I, e) {
    let { routesMeta: C } = g,
      l = {},
      t = "/",
      n = [];
    for (let o = 0; o < C.length; ++o) {
      let A = C[o],
        c = o === C.length - 1,
        d = t === "/" ? I : I.slice(t.length) || "/",
        i = Ur(
          { path: A.relativePath, caseSensitive: A.caseSensitive, end: c },
          d
        ),
        r = A.route;
      if (
        (!i &&
          c &&
          e &&
          !C[C.length - 1].route.index &&
          (i = Ur(
            { path: A.relativePath, caseSensitive: A.caseSensitive, end: !1 },
            d
          )),
        !i)
      )
        return null;
      Object.assign(l, i.params),
        n.push({
          params: l,
          pathname: Fe([t, i.pathname]),
          pathnameBase: Jy(Fe([t, i.pathnameBase])),
          route: r,
        }),
        i.pathnameBase !== "/" && (t = Fe([t, i.pathnameBase]));
    }
    return n;
  }
  function Ur(g, I) {
    typeof g == "string" && (g = { path: g, caseSensitive: !1, end: !0 });
    let [e, C] = Sy(g.path, g.caseSensitive, g.end),
      l = I.match(e);
    if (!l) return null;
    let t = l[0],
      n = t.replace(/(.)\/+$/, "$1"),
      o = l.slice(1);
    return {
      params: C.reduce((c, d, i) => {
        let { paramName: r, isOptional: u } = d;
        if (r === "*") {
          let m = o[i] || "";
          n = t.slice(0, t.length - m.length).replace(/(.)\/+$/, "$1");
        }
        const b = o[i];
        return (
          u && !b ? (c[r] = void 0) : (c[r] = (b || "").replace(/%2F/g, "/")), c
        );
      }, {}),
      pathname: t,
      pathnameBase: n,
      pattern: g,
    };
  }
  function Sy(g, I, e) {
    I === void 0 && (I = !1),
      e === void 0 && (e = !0),
      Lm(
        g === "*" || !g.endsWith("*") || g.endsWith("/*"),
        'Route path "' +
          g +
          '" will be treated as if it were ' +
          ('"' + g.replace(/\*$/, "/*") + '" because the `*` character must ') +
          "always follow a `/` in the pattern. To get rid of this warning, " +
          ('please change the route path to "' + g.replace(/\*$/, "/*") + '".')
      );
    let C = [],
      l =
        "^" +
        g
          .replace(/\/*\*?$/, "")
          .replace(/^\/*/, "/")
          .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
          .replace(
            /\/:([\w-]+)(\?)?/g,
            (n, o, A) => (
              C.push({ paramName: o, isOptional: A != null }),
              A ? "/?([^\\/]+)?" : "/([^\\/]+)"
            )
          );
    return (
      g.endsWith("*")
        ? (C.push({ paramName: "*" }),
          (l += g === "*" || g === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
        : e
        ? (l += "\\/*$")
        : g !== "" && g !== "/" && (l += "(?:(?=\\/|$))"),
      [new RegExp(l, I ? void 0 : "i"), C]
    );
  }
  function Vy(g) {
    try {
      return g
        .split("/")
        .map((I) => decodeURIComponent(I).replace(/\//g, "%2F"))
        .join("/");
    } catch (I) {
      return (
        Lm(
          !1,
          'The URL path "' +
            g +
            '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
            ("encoding (" + I + ").")
        ),
        g
      );
    }
  }
  function Fi(g, I) {
    if (I === "/") return g;
    if (!g.toLowerCase().startsWith(I.toLowerCase())) return null;
    let e = I.endsWith("/") ? I.length - 1 : I.length,
      C = g.charAt(e);
    return C && C !== "/" ? null : g.slice(e) || "/";
  }
  function Wy(g, I) {
    I === void 0 && (I = "/");
    let {
      pathname: e,
      search: C = "",
      hash: l = "",
    } = typeof g == "string" ? pl(g) : g;
    return {
      pathname: e ? (e.startsWith("/") ? e : Ry(e, I)) : I,
      search: vy(C),
      hash: ky(l),
    };
  }
  function Ry(g, I) {
    let e = I.replace(/\/+$/, "").split("/");
    return (
      g.split("/").forEach((l) => {
        l === ".." ? e.length > 1 && e.pop() : l !== "." && e.push(l);
      }),
      e.length > 1 ? e.join("/") : "/"
    );
  }
  function $A(g, I, e, C) {
    return (
      "Cannot include a '" +
      g +
      "' character in a manually specified " +
      ("`to." +
        I +
        "` field [" +
        JSON.stringify(C) +
        "].  Please separate it out to the ") +
      ("`to." +
        e +
        "` field. Alternatively you may provide the full path as ") +
      'a string in <Link to="..."> and the router will parse it for you.'
    );
  }
  function Xy(g) {
    return g.filter(
      (I, e) => e === 0 || (I.route.path && I.route.path.length > 0)
    );
  }
  function jm(g, I) {
    let e = Xy(g);
    return I
      ? e.map((C, l) => (l === e.length - 1 ? C.pathname : C.pathnameBase))
      : e.map((C) => C.pathnameBase);
  }
  function Pm(g, I, e, C) {
    C === void 0 && (C = !1);
    let l;
    typeof g == "string"
      ? (l = pl(g))
      : ((l = yt({}, g)),
        Jg(
          !l.pathname || !l.pathname.includes("?"),
          $A("?", "pathname", "search", l)
        ),
        Jg(
          !l.pathname || !l.pathname.includes("#"),
          $A("#", "pathname", "hash", l)
        ),
        Jg(!l.search || !l.search.includes("#"), $A("#", "search", "hash", l)));
    let t = g === "" || l.pathname === "",
      n = t ? "/" : l.pathname,
      o;
    if (n == null) o = e;
    else {
      let i = I.length - 1;
      if (!C && n.startsWith("..")) {
        let r = n.split("/");
        for (; r[0] === ".."; ) r.shift(), (i -= 1);
        l.pathname = r.join("/");
      }
      o = i >= 0 ? I[i] : "/";
    }
    let A = Wy(l, o),
      c = n && n !== "/" && n.endsWith("/"),
      d = (t || n === ".") && e.endsWith("/");
    return !A.pathname.endsWith("/") && (c || d) && (A.pathname += "/"), A;
  }
  const Fe = (g) => g.join("/").replace(/\/\/+/g, "/"),
    Jy = (g) => g.replace(/\/+$/, "").replace(/^\/*/, "/"),
    vy = (g) => (!g || g === "?" ? "" : g.startsWith("?") ? g : "?" + g),
    ky = (g) => (!g || g === "#" ? "" : g.startsWith("#") ? g : "#" + g);
  function fy(g) {
    return (
      g != null &&
      typeof g.status == "number" &&
      typeof g.statusText == "string" &&
      typeof g.internal == "boolean" &&
      "data" in g
    );
  }
  const Om = ["post", "put", "patch", "delete"];
  new Set(Om);
  const Yy = ["get", ...Om];
  new Set(Yy);
  /**
   * React Router v6.27.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */ function ht() {
    return (
      (ht = Object.assign
        ? Object.assign.bind()
        : function (g) {
            for (var I = 1; I < arguments.length; I++) {
              var e = arguments[I];
              for (var C in e)
                Object.prototype.hasOwnProperty.call(e, C) && (g[C] = e[C]);
            }
            return g;
          }),
      ht.apply(this, arguments)
    );
  }
  const xi = a.createContext(null),
    Hy = a.createContext(null),
    VC = a.createContext(null),
    IA = a.createContext(null),
    WC = a.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
    _m = a.createContext(null);
  function wy(g, I) {
    let { relative: e } = I === void 0 ? {} : I;
    Pt() || Jg(!1);
    let { basename: C, navigator: l } = a.useContext(VC),
      { hash: t, pathname: n, search: o } = $m(g, { relative: e }),
      A = n;
    return (
      C !== "/" && (A = n === "/" ? C : Fe([C, n])),
      l.createHref({ pathname: A, search: o, hash: t })
    );
  }
  function Pt() {
    return a.useContext(IA) != null;
  }
  function RC() {
    return Pt() || Jg(!1), a.useContext(IA).location;
  }
  function qm(g) {
    a.useContext(VC).static || a.useLayoutEffect(g);
  }
  function eA() {
    let { isDataRoute: g } = a.useContext(WC);
    return g ? jy() : Ny();
  }
  function Ny() {
    Pt() || Jg(!1);
    let g = a.useContext(xi),
      { basename: I, future: e, navigator: C } = a.useContext(VC),
      { matches: l } = a.useContext(WC),
      { pathname: t } = RC(),
      n = JSON.stringify(jm(l, e.v7_relativeSplatPath)),
      o = a.useRef(!1);
    return (
      qm(() => {
        o.current = !0;
      }),
      a.useCallback(
        function (c, d) {
          if ((d === void 0 && (d = {}), !o.current)) return;
          if (typeof c == "number") {
            C.go(c);
            return;
          }
          let i = Pm(c, JSON.parse(n), t, d.relative === "path");
          g == null &&
            I !== "/" &&
            (i.pathname = i.pathname === "/" ? I : Fe([I, i.pathname])),
            (d.replace ? C.replace : C.push)(i, d.state, d);
        },
        [I, C, n, t, g]
      )
    );
  }
  function $m(g, I) {
    let { relative: e } = I === void 0 ? {} : I,
      { future: C } = a.useContext(VC),
      { matches: l } = a.useContext(WC),
      { pathname: t } = RC(),
      n = JSON.stringify(jm(l, C.v7_relativeSplatPath));
    return a.useMemo(() => Pm(g, JSON.parse(n), t, e === "path"), [g, n, t, e]);
  }
  function Ky(g, I) {
    return Fy(g, I);
  }
  function Fy(g, I, e, C) {
    Pt() || Jg(!1);
    let { navigator: l } = a.useContext(VC),
      { matches: t } = a.useContext(WC),
      n = t[t.length - 1],
      o = n ? n.params : {};
    n && n.pathname;
    let A = n ? n.pathnameBase : "/";
    n && n.route;
    let c = RC(),
      d;
    if (I) {
      var i;
      let p = typeof I == "string" ? pl(I) : I;
      A === "/" || ((i = p.pathname) != null && i.startsWith(A)) || Jg(!1),
        (d = p);
    } else d = c;
    let r = d.pathname || "/",
      u = r;
    if (A !== "/") {
      let p = A.replace(/^\//, "").split("/");
      u = "/" + r.replace(/^\//, "").split("/").slice(p.length).join("/");
    }
    let b = ay(g, { pathname: u }),
      m = Uy(
        b &&
          b.map((p) =>
            Object.assign({}, p, {
              params: Object.assign({}, o, p.params),
              pathname: Fe([
                A,
                l.encodeLocation
                  ? l.encodeLocation(p.pathname).pathname
                  : p.pathname,
              ]),
              pathnameBase:
                p.pathnameBase === "/"
                  ? A
                  : Fe([
                      A,
                      l.encodeLocation
                        ? l.encodeLocation(p.pathnameBase).pathname
                        : p.pathnameBase,
                    ]),
            })
          ),
        t,
        e,
        C
      );
    return I && m
      ? a.createElement(
          IA.Provider,
          {
            value: {
              location: ht(
                {
                  pathname: "/",
                  search: "",
                  hash: "",
                  state: null,
                  key: "default",
                },
                d
              ),
              navigationType: Xe.Pop,
            },
          },
          m
        )
      : m;
  }
  function xy() {
    let g = Ty(),
      I = fy(g)
        ? g.status + " " + g.statusText
        : g instanceof Error
        ? g.message
        : JSON.stringify(g),
      e = g instanceof Error ? g.stack : null,
      l = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
    return a.createElement(
      a.Fragment,
      null,
      a.createElement("h2", null, "Unexpected Application Error!"),
      a.createElement("h3", { style: { fontStyle: "italic" } }, I),
      e ? a.createElement("pre", { style: l }, e) : null,
      null
    );
  }
  const My = a.createElement(xy, null);
  class zy extends a.Component {
    constructor(I) {
      super(I),
        (this.state = {
          location: I.location,
          revalidation: I.revalidation,
          error: I.error,
        });
    }
    static getDerivedStateFromError(I) {
      return { error: I };
    }
    static getDerivedStateFromProps(I, e) {
      return e.location !== I.location ||
        (e.revalidation !== "idle" && I.revalidation === "idle")
        ? { error: I.error, location: I.location, revalidation: I.revalidation }
        : {
            error: I.error !== void 0 ? I.error : e.error,
            location: e.location,
            revalidation: I.revalidation || e.revalidation,
          };
    }
    componentDidCatch(I, e) {
      console.error(
        "React Router caught the following error during render",
        I,
        e
      );
    }
    render() {
      return this.state.error !== void 0
        ? a.createElement(
            WC.Provider,
            { value: this.props.routeContext },
            a.createElement(_m.Provider, {
              value: this.state.error,
              children: this.props.component,
            })
          )
        : this.props.children;
    }
  }
  function Ey(g) {
    let { routeContext: I, match: e, children: C } = g,
      l = a.useContext(xi);
    return (
      l &&
        l.static &&
        l.staticContext &&
        (e.route.errorElement || e.route.ErrorBoundary) &&
        (l.staticContext._deepestRenderedBoundaryId = e.route.id),
      a.createElement(WC.Provider, { value: I }, C)
    );
  }
  function Uy(g, I, e, C) {
    var l;
    if (
      (I === void 0 && (I = []),
      e === void 0 && (e = null),
      C === void 0 && (C = null),
      g == null)
    ) {
      var t;
      if (!e) return null;
      if (e.errors) g = e.matches;
      else if (
        (t = C) != null &&
        t.v7_partialHydration &&
        I.length === 0 &&
        !e.initialized &&
        e.matches.length > 0
      )
        g = e.matches;
      else return null;
    }
    let n = g,
      o = (l = e) == null ? void 0 : l.errors;
    if (o != null) {
      let d = n.findIndex(
        (i) => i.route.id && (o == null ? void 0 : o[i.route.id]) !== void 0
      );
      d >= 0 || Jg(!1), (n = n.slice(0, Math.min(n.length, d + 1)));
    }
    let A = !1,
      c = -1;
    if (e && C && C.v7_partialHydration)
      for (let d = 0; d < n.length; d++) {
        let i = n[d];
        if (
          ((i.route.HydrateFallback || i.route.hydrateFallbackElement) &&
            (c = d),
          i.route.id)
        ) {
          let { loaderData: r, errors: u } = e,
            b =
              i.route.loader &&
              r[i.route.id] === void 0 &&
              (!u || u[i.route.id] === void 0);
          if (i.route.lazy || b) {
            (A = !0), c >= 0 ? (n = n.slice(0, c + 1)) : (n = [n[0]]);
            break;
          }
        }
      }
    return n.reduceRight((d, i, r) => {
      let u,
        b = !1,
        m = null,
        p = null;
      e &&
        ((u = o && i.route.id ? o[i.route.id] : void 0),
        (m = i.route.errorElement || My),
        A &&
          (c < 0 && r === 0
            ? ((b = !0), (p = null))
            : c === r &&
              ((b = !0), (p = i.route.hydrateFallbackElement || null))));
      let G = I.concat(n.slice(0, r + 1)),
        Z = () => {
          let B;
          return (
            u
              ? (B = m)
              : b
              ? (B = p)
              : i.route.Component
              ? (B = a.createElement(i.route.Component, null))
              : i.route.element
              ? (B = i.route.element)
              : (B = d),
            a.createElement(Ey, {
              match: i,
              routeContext: { outlet: d, matches: G, isDataRoute: e != null },
              children: B,
            })
          );
        };
      return e && (i.route.ErrorBoundary || i.route.errorElement || r === 0)
        ? a.createElement(zy, {
            location: e.location,
            revalidation: e.revalidation,
            component: m,
            error: u,
            children: Z(),
            routeContext: { outlet: null, matches: G, isDataRoute: !0 },
          })
        : Z();
    }, null);
  }
  var gZ = (function (g) {
      return (
        (g.UseBlocker = "useBlocker"),
        (g.UseRevalidator = "useRevalidator"),
        (g.UseNavigateStable = "useNavigate"),
        g
      );
    })(gZ || {}),
    yo = (function (g) {
      return (
        (g.UseBlocker = "useBlocker"),
        (g.UseLoaderData = "useLoaderData"),
        (g.UseActionData = "useActionData"),
        (g.UseRouteError = "useRouteError"),
        (g.UseNavigation = "useNavigation"),
        (g.UseRouteLoaderData = "useRouteLoaderData"),
        (g.UseMatches = "useMatches"),
        (g.UseRevalidator = "useRevalidator"),
        (g.UseNavigateStable = "useNavigate"),
        (g.UseRouteId = "useRouteId"),
        g
      );
    })(yo || {});
  function Qy(g) {
    let I = a.useContext(xi);
    return I || Jg(!1), I;
  }
  function Ly(g) {
    let I = a.useContext(Hy);
    return I || Jg(!1), I;
  }
  function Dy(g) {
    let I = a.useContext(WC);
    return I || Jg(!1), I;
  }
  function IZ(g) {
    let I = Dy(),
      e = I.matches[I.matches.length - 1];
    return e.route.id || Jg(!1), e.route.id;
  }
  function Ty() {
    var g;
    let I = a.useContext(_m),
      e = Ly(yo.UseRouteError),
      C = IZ(yo.UseRouteError);
    return I !== void 0 ? I : (g = e.errors) == null ? void 0 : g[C];
  }
  function jy() {
    let { router: g } = Qy(gZ.UseNavigateStable),
      I = IZ(yo.UseNavigateStable),
      e = a.useRef(!1);
    return (
      qm(() => {
        e.current = !0;
      }),
      a.useCallback(
        function (l, t) {
          t === void 0 && (t = {}),
            e.current &&
              (typeof l == "number"
                ? g.navigate(l)
                : g.navigate(l, ht({ fromRouteId: I }, t)));
        },
        [g, I]
      )
    );
  }
  function eZ(g) {
    Jg(!1);
  }
  function Py(g) {
    let {
      basename: I = "/",
      children: e = null,
      location: C,
      navigationType: l = Xe.Pop,
      navigator: t,
      static: n = !1,
      future: o,
    } = g;
    Pt() && Jg(!1);
    let A = I.replace(/^\/*/, "/"),
      c = a.useMemo(
        () => ({
          basename: A,
          navigator: t,
          static: n,
          future: ht({ v7_relativeSplatPath: !1 }, o),
        }),
        [A, o, t, n]
      );
    typeof C == "string" && (C = pl(C));
    let {
        pathname: d = "/",
        search: i = "",
        hash: r = "",
        state: u = null,
        key: b = "default",
      } = C,
      m = a.useMemo(() => {
        let p = Fi(d, A);
        return p == null
          ? null
          : {
              location: { pathname: p, search: i, hash: r, state: u, key: b },
              navigationType: l,
            };
      }, [A, d, i, r, u, b, l]);
    return m == null
      ? null
      : a.createElement(
          VC.Provider,
          { value: c },
          a.createElement(IA.Provider, { children: e, value: m })
        );
  }
  function Oy(g) {
    let { children: I, location: e } = g;
    return Ky(ad(I), e);
  }
  new Promise(() => {});
  function ad(g, I) {
    I === void 0 && (I = []);
    let e = [];
    return (
      a.Children.forEach(g, (C, l) => {
        if (!a.isValidElement(C)) return;
        let t = [...I, l];
        if (C.type === a.Fragment) {
          e.push.apply(e, ad(C.props.children, t));
          return;
        }
        C.type !== eZ && Jg(!1), !C.props.index || !C.props.children || Jg(!1);
        let n = {
          id: C.props.id || t.join("-"),
          caseSensitive: C.props.caseSensitive,
          element: C.props.element,
          Component: C.props.Component,
          index: C.props.index,
          path: C.props.path,
          loader: C.props.loader,
          action: C.props.action,
          errorElement: C.props.errorElement,
          ErrorBoundary: C.props.ErrorBoundary,
          hasErrorBoundary:
            C.props.ErrorBoundary != null || C.props.errorElement != null,
          shouldRevalidate: C.props.shouldRevalidate,
          handle: C.props.handle,
          lazy: C.props.lazy,
        };
        C.props.children && (n.children = ad(C.props.children, t)), e.push(n);
      }),
      e
    );
  }
  /**
   * React Router DOM v6.27.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */ function rd() {
    return (
      (rd = Object.assign
        ? Object.assign.bind()
        : function (g) {
            for (var I = 1; I < arguments.length; I++) {
              var e = arguments[I];
              for (var C in e)
                Object.prototype.hasOwnProperty.call(e, C) && (g[C] = e[C]);
            }
            return g;
          }),
      rd.apply(this, arguments)
    );
  }
  function _y(g, I) {
    if (g == null) return {};
    var e = {},
      C = Object.keys(g),
      l,
      t;
    for (t = 0; t < C.length; t++)
      (l = C[t]), !(I.indexOf(l) >= 0) && (e[l] = g[l]);
    return e;
  }
  function qy(g) {
    return !!(g.metaKey || g.altKey || g.ctrlKey || g.shiftKey);
  }
  function $y(g, I) {
    return g.button === 0 && (!I || I === "_self") && !qy(g);
  }
  function sd(g) {
    return (
      g === void 0 && (g = ""),
      new URLSearchParams(
        typeof g == "string" || Array.isArray(g) || g instanceof URLSearchParams
          ? g
          : Object.keys(g).reduce((I, e) => {
              let C = g[e];
              return I.concat(
                Array.isArray(C) ? C.map((l) => [e, l]) : [[e, C]]
              );
            }, [])
      )
    );
  }
  function gh(g, I) {
    let e = sd(g);
    return (
      I &&
        I.forEach((C, l) => {
          e.has(l) ||
            I.getAll(l).forEach((t) => {
              e.append(l, t);
            });
        }),
      e
    );
  }
  const Ih = [
      "onClick",
      "relative",
      "reloadDocument",
      "replace",
      "state",
      "target",
      "to",
      "preventScrollReset",
      "viewTransition",
    ],
    eh = "6";
  try {
    window.__reactRouterVersion = eh;
  } catch {}
  const Ch = "startTransition",
    Qr = zs[Ch];
  function lh(g) {
    let { basename: I, children: e, future: C, window: l } = g,
      t = a.useRef();
    t.current == null && (t.current = cy({ window: l, v5Compat: !0 }));
    let n = t.current,
      [o, A] = a.useState({ action: n.action, location: n.location }),
      { v7_startTransition: c } = C || {},
      d = a.useCallback(
        (i) => {
          c && Qr ? Qr(() => A(i)) : A(i);
        },
        [A, c]
      );
    return (
      a.useLayoutEffect(() => n.listen(d), [n, d]),
      a.createElement(Py, {
        basename: I,
        children: e,
        location: o.location,
        navigationType: o.action,
        navigator: n,
        future: C,
      })
    );
  }
  const th =
      typeof window < "u" &&
      typeof window.document < "u" &&
      typeof window.document.createElement < "u",
    nh = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    ho = a.forwardRef(function (I, e) {
      let {
          onClick: C,
          relative: l,
          reloadDocument: t,
          replace: n,
          state: o,
          target: A,
          to: c,
          preventScrollReset: d,
          viewTransition: i,
        } = I,
        r = _y(I, Ih),
        { basename: u } = a.useContext(VC),
        b,
        m = !1;
      if (typeof c == "string" && nh.test(c) && ((b = c), th))
        try {
          let B = new URL(window.location.href),
            y = c.startsWith("//") ? new URL(B.protocol + c) : new URL(c),
            h = Fi(y.pathname, u);
          y.origin === B.origin && h != null
            ? (c = h + y.search + y.hash)
            : (m = !0);
        } catch {}
      let p = wy(c, { relative: l }),
        G = oh(c, {
          replace: n,
          state: o,
          target: A,
          preventScrollReset: d,
          relative: l,
          viewTransition: i,
        });
      function Z(B) {
        C && C(B), B.defaultPrevented || G(B);
      }
      return a.createElement(
        "a",
        rd({}, r, { href: b || p, onClick: m || t ? C : Z, ref: e, target: A })
      );
    });
  var Lr;
  (function (g) {
    (g.UseScrollRestoration = "useScrollRestoration"),
      (g.UseSubmit = "useSubmit"),
      (g.UseSubmitFetcher = "useSubmitFetcher"),
      (g.UseFetcher = "useFetcher"),
      (g.useViewTransitionState = "useViewTransitionState");
  })(Lr || (Lr = {}));
  var Dr;
  (function (g) {
    (g.UseFetcher = "useFetcher"),
      (g.UseFetchers = "useFetchers"),
      (g.UseScrollRestoration = "useScrollRestoration");
  })(Dr || (Dr = {}));
  function oh(g, I) {
    let {
        target: e,
        replace: C,
        state: l,
        preventScrollReset: t,
        relative: n,
        viewTransition: o,
      } = I === void 0 ? {} : I,
      A = eA(),
      c = RC(),
      d = $m(g, { relative: n });
    return a.useCallback(
      (i) => {
        if ($y(i, e)) {
          i.preventDefault();
          let r = C !== void 0 ? C : po(c) === po(d);
          A(g, {
            replace: r,
            state: l,
            preventScrollReset: t,
            relative: n,
            viewTransition: o,
          });
        }
      },
      [c, A, d, C, l, e, g, t, n, o]
    );
  }
  function Ah(g) {
    let I = a.useRef(sd(g)),
      e = a.useRef(!1),
      C = RC(),
      l = a.useMemo(
        () => gh(C.search, e.current ? null : I.current),
        [C.search]
      ),
      t = eA(),
      n = a.useCallback(
        (o, A) => {
          const c = sd(typeof o == "function" ? o(l) : o);
          (e.current = !0), t("?" + c, A);
        },
        [t, l]
      );
    return [l, n];
  }
  const ch = () => s.jsx("div", { children: "Profile Page" }),
    dh = () => s.jsx("div", { children: "Contact Page" });
  function CZ(g) {
    var I,
      e,
      C = "";
    if (typeof g == "string" || typeof g == "number") C += g;
    else if (typeof g == "object")
      if (Array.isArray(g))
        for (I = 0; I < g.length; I++)
          g[I] && (e = CZ(g[I])) && (C && (C += " "), (C += e));
      else for (I in g) g[I] && (C && (C += " "), (C += I));
    return C;
  }
  function ih() {
    for (var g, I, e = 0, C = ""; e < arguments.length; )
      (g = arguments[e++]) && (I = CZ(g)) && (C && (C += " "), (C += I));
    return C;
  }
  const Tr = (g) => (typeof g == "boolean" ? "".concat(g) : g === 0 ? "0" : g),
    jr = ih,
    Mi = (g, I) => (e) => {
      var C;
      if ((I == null ? void 0 : I.variants) == null)
        return jr(
          g,
          e == null ? void 0 : e.class,
          e == null ? void 0 : e.className
        );
      const { variants: l, defaultVariants: t } = I,
        n = Object.keys(l).map((c) => {
          const d = e == null ? void 0 : e[c],
            i = t == null ? void 0 : t[c];
          if (d === null) return null;
          const r = Tr(d) || Tr(i);
          return l[c][r];
        }),
        o =
          e &&
          Object.entries(e).reduce((c, d) => {
            let [i, r] = d;
            return r === void 0 || (c[i] = r), c;
          }, {}),
        A =
          I == null || (C = I.compoundVariants) === null || C === void 0
            ? void 0
            : C.reduce((c, d) => {
                let { class: i, className: r, ...u } = d;
                return Object.entries(u).every((b) => {
                  let [m, p] = b;
                  return Array.isArray(p)
                    ? p.includes({ ...t, ...o }[m])
                    : { ...t, ...o }[m] === p;
                })
                  ? [...c, i, r]
                  : c;
              }, []);
      return jr(
        g,
        n,
        A,
        e == null ? void 0 : e.class,
        e == null ? void 0 : e.className
      );
    };
  function lZ(g) {
    var I,
      e,
      C = "";
    if (typeof g == "string" || typeof g == "number") C += g;
    else if (typeof g == "object")
      if (Array.isArray(g)) {
        var l = g.length;
        for (I = 0; I < l; I++)
          g[I] && (e = lZ(g[I])) && (C && (C += " "), (C += e));
      } else for (e in g) g[e] && (C && (C += " "), (C += e));
    return C;
  }
  function ah() {
    for (var g, I, e = 0, C = "", l = arguments.length; e < l; e++)
      (g = arguments[e]) && (I = lZ(g)) && (C && (C += " "), (C += I));
    return C;
  }
  const zi = "-",
    rh = (g) => {
      const I = uh(g),
        { conflictingClassGroups: e, conflictingClassGroupModifiers: C } = g;
      return {
        getClassGroupId: (n) => {
          const o = n.split(zi);
          return o[0] === "" && o.length !== 1 && o.shift(), tZ(o, I) || sh(n);
        },
        getConflictingClassGroupIds: (n, o) => {
          const A = e[n] || [];
          return o && C[n] ? [...A, ...C[n]] : A;
        },
      };
    },
    tZ = (g, I) => {
      var n;
      if (g.length === 0) return I.classGroupId;
      const e = g[0],
        C = I.nextPart.get(e),
        l = C ? tZ(g.slice(1), C) : void 0;
      if (l) return l;
      if (I.validators.length === 0) return;
      const t = g.join(zi);
      return (n = I.validators.find(({ validator: o }) => o(t))) == null
        ? void 0
        : n.classGroupId;
    },
    Pr = /^\[(.+)\]$/,
    sh = (g) => {
      if (Pr.test(g)) {
        const I = Pr.exec(g)[1],
          e = I == null ? void 0 : I.substring(0, I.indexOf(":"));
        if (e) return "arbitrary.." + e;
      }
    },
    uh = (g) => {
      const { theme: I, prefix: e } = g,
        C = { nextPart: new Map(), validators: [] };
      return (
        Zh(Object.entries(g.classGroups), e).forEach(([t, n]) => {
          ud(n, C, t, I);
        }),
        C
      );
    },
    ud = (g, I, e, C) => {
      g.forEach((l) => {
        if (typeof l == "string") {
          const t = l === "" ? I : Or(I, l);
          t.classGroupId = e;
          return;
        }
        if (typeof l == "function") {
          if (mh(l)) {
            ud(l(C), I, e, C);
            return;
          }
          I.validators.push({ validator: l, classGroupId: e });
          return;
        }
        Object.entries(l).forEach(([t, n]) => {
          ud(n, Or(I, t), e, C);
        });
      });
    },
    Or = (g, I) => {
      let e = g;
      return (
        I.split(zi).forEach((C) => {
          e.nextPart.has(C) ||
            e.nextPart.set(C, { nextPart: new Map(), validators: [] }),
            (e = e.nextPart.get(C));
        }),
        e
      );
    },
    mh = (g) => g.isThemeGetter,
    Zh = (g, I) =>
      I
        ? g.map(([e, C]) => {
            const l = C.map((t) =>
              typeof t == "string"
                ? I + t
                : typeof t == "object"
                ? Object.fromEntries(
                    Object.entries(t).map(([n, o]) => [I + n, o])
                  )
                : t
            );
            return [e, l];
          })
        : g,
    Gh = (g) => {
      if (g < 1) return { get: () => {}, set: () => {} };
      let I = 0,
        e = new Map(),
        C = new Map();
      const l = (t, n) => {
        e.set(t, n), I++, I > g && ((I = 0), (C = e), (e = new Map()));
      };
      return {
        get(t) {
          let n = e.get(t);
          if (n !== void 0) return n;
          if ((n = C.get(t)) !== void 0) return l(t, n), n;
        },
        set(t, n) {
          e.has(t) ? e.set(t, n) : l(t, n);
        },
      };
    },
    nZ = "!",
    bh = (g) => {
      const { separator: I, experimentalParseClassName: e } = g,
        C = I.length === 1,
        l = I[0],
        t = I.length,
        n = (o) => {
          const A = [];
          let c = 0,
            d = 0,
            i;
          for (let p = 0; p < o.length; p++) {
            let G = o[p];
            if (c === 0) {
              if (G === l && (C || o.slice(p, p + t) === I)) {
                A.push(o.slice(d, p)), (d = p + t);
                continue;
              }
              if (G === "/") {
                i = p;
                continue;
              }
            }
            G === "[" ? c++ : G === "]" && c--;
          }
          const r = A.length === 0 ? o : o.substring(d),
            u = r.startsWith(nZ),
            b = u ? r.substring(1) : r,
            m = i && i > d ? i - d : void 0;
          return {
            modifiers: A,
            hasImportantModifier: u,
            baseClassName: b,
            maybePostfixModifierPosition: m,
          };
        };
      return e ? (o) => e({ className: o, parseClassName: n }) : n;
    },
    Bh = (g) => {
      if (g.length <= 1) return g;
      const I = [];
      let e = [];
      return (
        g.forEach((C) => {
          C[0] === "[" ? (I.push(...e.sort(), C), (e = [])) : e.push(C);
        }),
        I.push(...e.sort()),
        I
      );
    },
    ph = (g) => ({ cache: Gh(g.cacheSize), parseClassName: bh(g), ...rh(g) }),
    yh = /\s+/,
    hh = (g, I) => {
      const {
          parseClassName: e,
          getClassGroupId: C,
          getConflictingClassGroupIds: l,
        } = I,
        t = [],
        n = g.trim().split(yh);
      let o = "";
      for (let A = n.length - 1; A >= 0; A -= 1) {
        const c = n[A],
          {
            modifiers: d,
            hasImportantModifier: i,
            baseClassName: r,
            maybePostfixModifierPosition: u,
          } = e(c);
        let b = !!u,
          m = C(b ? r.substring(0, u) : r);
        if (!m) {
          if (!b) {
            o = c + (o.length > 0 ? " " + o : o);
            continue;
          }
          if (((m = C(r)), !m)) {
            o = c + (o.length > 0 ? " " + o : o);
            continue;
          }
          b = !1;
        }
        const p = Bh(d).join(":"),
          G = i ? p + nZ : p,
          Z = G + m;
        if (t.includes(Z)) continue;
        t.push(Z);
        const B = l(m, b);
        for (let y = 0; y < B.length; ++y) {
          const h = B[y];
          t.push(G + h);
        }
        o = c + (o.length > 0 ? " " + o : o);
      }
      return o;
    };
  function Sh() {
    let g = 0,
      I,
      e,
      C = "";
    for (; g < arguments.length; )
      (I = arguments[g++]) && (e = oZ(I)) && (C && (C += " "), (C += e));
    return C;
  }
  const oZ = (g) => {
    if (typeof g == "string") return g;
    let I,
      e = "";
    for (let C = 0; C < g.length; C++)
      g[C] && (I = oZ(g[C])) && (e && (e += " "), (e += I));
    return e;
  };
  function Vh(g, ...I) {
    let e,
      C,
      l,
      t = n;
    function n(A) {
      const c = I.reduce((d, i) => i(d), g());
      return (e = ph(c)), (C = e.cache.get), (l = e.cache.set), (t = o), o(A);
    }
    function o(A) {
      const c = C(A);
      if (c) return c;
      const d = hh(A, e);
      return l(A, d), d;
    }
    return function () {
      return t(Sh.apply(null, arguments));
    };
  }
  const ug = (g) => {
      const I = (e) => e[g] || [];
      return (I.isThemeGetter = !0), I;
    },
    AZ = /^\[(?:([a-z-]+):)?(.+)\]$/i,
    Wh = /^\d+\/\d+$/,
    Rh = new Set(["px", "full", "screen"]),
    Xh = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
    Jh =
      /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
    vh = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
    kh = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
    fh =
      /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
    ge = (g) => el(g) || Rh.has(g) || Wh.test(g),
    Ge = (g) => yl(g, "length", Mh),
    el = (g) => !!g && !Number.isNaN(Number(g)),
    gc = (g) => yl(g, "number", el),
    Fl = (g) => !!g && Number.isInteger(Number(g)),
    Yh = (g) => g.endsWith("%") && el(g.slice(0, -1)),
    q = (g) => AZ.test(g),
    be = (g) => Xh.test(g),
    Hh = new Set(["length", "size", "percentage"]),
    wh = (g) => yl(g, Hh, cZ),
    Nh = (g) => yl(g, "position", cZ),
    Kh = new Set(["image", "url"]),
    Fh = (g) => yl(g, Kh, Eh),
    xh = (g) => yl(g, "", zh),
    xl = () => !0,
    yl = (g, I, e) => {
      const C = AZ.exec(g);
      return C
        ? C[1]
          ? typeof I == "string"
            ? C[1] === I
            : I.has(C[1])
          : e(C[2])
        : !1;
    },
    Mh = (g) => Jh.test(g) && !vh.test(g),
    cZ = () => !1,
    zh = (g) => kh.test(g),
    Eh = (g) => fh.test(g),
    Uh = () => {
      const g = ug("colors"),
        I = ug("spacing"),
        e = ug("blur"),
        C = ug("brightness"),
        l = ug("borderColor"),
        t = ug("borderRadius"),
        n = ug("borderSpacing"),
        o = ug("borderWidth"),
        A = ug("contrast"),
        c = ug("grayscale"),
        d = ug("hueRotate"),
        i = ug("invert"),
        r = ug("gap"),
        u = ug("gradientColorStops"),
        b = ug("gradientColorStopPositions"),
        m = ug("inset"),
        p = ug("margin"),
        G = ug("opacity"),
        Z = ug("padding"),
        B = ug("saturate"),
        y = ug("scale"),
        h = ug("sepia"),
        W = ug("skew"),
        S = ug("space"),
        V = ug("translate"),
        f = () => ["auto", "contain", "none"],
        k = () => ["auto", "hidden", "clip", "visible", "scroll"],
        F = () => ["auto", q, I],
        K = () => [q, I],
        P = () => ["", ge, Ge],
        T = () => ["auto", el, q],
        ng = () => [
          "bottom",
          "center",
          "left",
          "left-bottom",
          "left-top",
          "right",
          "right-bottom",
          "right-top",
          "top",
        ],
        z = () => ["solid", "dashed", "dotted", "double", "none"],
        gg = () => [
          "normal",
          "multiply",
          "screen",
          "overlay",
          "darken",
          "lighten",
          "color-dodge",
          "color-burn",
          "hard-light",
          "soft-light",
          "difference",
          "exclusion",
          "hue",
          "saturation",
          "color",
          "luminosity",
        ],
        R = () => [
          "start",
          "end",
          "center",
          "between",
          "around",
          "evenly",
          "stretch",
        ],
        X = () => ["", "0", q],
        H = () => [
          "auto",
          "avoid",
          "all",
          "avoid-page",
          "page",
          "left",
          "right",
          "column",
        ],
        U = () => [el, q];
      return {
        cacheSize: 500,
        separator: ":",
        theme: {
          colors: [xl],
          spacing: [ge, Ge],
          blur: ["none", "", be, q],
          brightness: U(),
          borderColor: [g],
          borderRadius: ["none", "", "full", be, q],
          borderSpacing: K(),
          borderWidth: P(),
          contrast: U(),
          grayscale: X(),
          hueRotate: U(),
          invert: X(),
          gap: K(),
          gradientColorStops: [g],
          gradientColorStopPositions: [Yh, Ge],
          inset: F(),
          margin: F(),
          opacity: U(),
          padding: K(),
          saturate: U(),
          scale: U(),
          sepia: X(),
          skew: U(),
          space: K(),
          translate: K(),
        },
        classGroups: {
          aspect: [{ aspect: ["auto", "square", "video", q] }],
          container: ["container"],
          columns: [{ columns: [be] }],
          "break-after": [{ "break-after": H() }],
          "break-before": [{ "break-before": H() }],
          "break-inside": [
            { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] },
          ],
          "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
          box: [{ box: ["border", "content"] }],
          display: [
            "block",
            "inline-block",
            "inline",
            "flex",
            "inline-flex",
            "table",
            "inline-table",
            "table-caption",
            "table-cell",
            "table-column",
            "table-column-group",
            "table-footer-group",
            "table-header-group",
            "table-row-group",
            "table-row",
            "flow-root",
            "grid",
            "inline-grid",
            "contents",
            "list-item",
            "hidden",
          ],
          float: [{ float: ["right", "left", "none", "start", "end"] }],
          clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
          isolation: ["isolate", "isolation-auto"],
          "object-fit": [
            { object: ["contain", "cover", "fill", "none", "scale-down"] },
          ],
          "object-position": [{ object: [...ng(), q] }],
          overflow: [{ overflow: k() }],
          "overflow-x": [{ "overflow-x": k() }],
          "overflow-y": [{ "overflow-y": k() }],
          overscroll: [{ overscroll: f() }],
          "overscroll-x": [{ "overscroll-x": f() }],
          "overscroll-y": [{ "overscroll-y": f() }],
          position: ["static", "fixed", "absolute", "relative", "sticky"],
          inset: [{ inset: [m] }],
          "inset-x": [{ "inset-x": [m] }],
          "inset-y": [{ "inset-y": [m] }],
          start: [{ start: [m] }],
          end: [{ end: [m] }],
          top: [{ top: [m] }],
          right: [{ right: [m] }],
          bottom: [{ bottom: [m] }],
          left: [{ left: [m] }],
          visibility: ["visible", "invisible", "collapse"],
          z: [{ z: ["auto", Fl, q] }],
          basis: [{ basis: F() }],
          "flex-direction": [
            { flex: ["row", "row-reverse", "col", "col-reverse"] },
          ],
          "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
          flex: [{ flex: ["1", "auto", "initial", "none", q] }],
          grow: [{ grow: X() }],
          shrink: [{ shrink: X() }],
          order: [{ order: ["first", "last", "none", Fl, q] }],
          "grid-cols": [{ "grid-cols": [xl] }],
          "col-start-end": [{ col: ["auto", { span: ["full", Fl, q] }, q] }],
          "col-start": [{ "col-start": T() }],
          "col-end": [{ "col-end": T() }],
          "grid-rows": [{ "grid-rows": [xl] }],
          "row-start-end": [{ row: ["auto", { span: [Fl, q] }, q] }],
          "row-start": [{ "row-start": T() }],
          "row-end": [{ "row-end": T() }],
          "grid-flow": [
            { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] },
          ],
          "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", q] }],
          "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", q] }],
          gap: [{ gap: [r] }],
          "gap-x": [{ "gap-x": [r] }],
          "gap-y": [{ "gap-y": [r] }],
          "justify-content": [{ justify: ["normal", ...R()] }],
          "justify-items": [
            { "justify-items": ["start", "end", "center", "stretch"] },
          ],
          "justify-self": [
            { "justify-self": ["auto", "start", "end", "center", "stretch"] },
          ],
          "align-content": [{ content: ["normal", ...R(), "baseline"] }],
          "align-items": [
            { items: ["start", "end", "center", "baseline", "stretch"] },
          ],
          "align-self": [
            { self: ["auto", "start", "end", "center", "stretch", "baseline"] },
          ],
          "place-content": [{ "place-content": [...R(), "baseline"] }],
          "place-items": [
            {
              "place-items": ["start", "end", "center", "baseline", "stretch"],
            },
          ],
          "place-self": [
            { "place-self": ["auto", "start", "end", "center", "stretch"] },
          ],
          p: [{ p: [Z] }],
          px: [{ px: [Z] }],
          py: [{ py: [Z] }],
          ps: [{ ps: [Z] }],
          pe: [{ pe: [Z] }],
          pt: [{ pt: [Z] }],
          pr: [{ pr: [Z] }],
          pb: [{ pb: [Z] }],
          pl: [{ pl: [Z] }],
          m: [{ m: [p] }],
          mx: [{ mx: [p] }],
          my: [{ my: [p] }],
          ms: [{ ms: [p] }],
          me: [{ me: [p] }],
          mt: [{ mt: [p] }],
          mr: [{ mr: [p] }],
          mb: [{ mb: [p] }],
          ml: [{ ml: [p] }],
          "space-x": [{ "space-x": [S] }],
          "space-x-reverse": ["space-x-reverse"],
          "space-y": [{ "space-y": [S] }],
          "space-y-reverse": ["space-y-reverse"],
          w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", q, I] }],
          "min-w": [{ "min-w": [q, I, "min", "max", "fit"] }],
          "max-w": [
            {
              "max-w": [
                q,
                I,
                "none",
                "full",
                "min",
                "max",
                "fit",
                "prose",
                { screen: [be] },
                be,
              ],
            },
          ],
          h: [{ h: [q, I, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }],
          "min-h": [
            { "min-h": [q, I, "min", "max", "fit", "svh", "lvh", "dvh"] },
          ],
          "max-h": [
            { "max-h": [q, I, "min", "max", "fit", "svh", "lvh", "dvh"] },
          ],
          size: [{ size: [q, I, "auto", "min", "max", "fit"] }],
          "font-size": [{ text: ["base", be, Ge] }],
          "font-smoothing": ["antialiased", "subpixel-antialiased"],
          "font-style": ["italic", "not-italic"],
          "font-weight": [
            {
              font: [
                "thin",
                "extralight",
                "light",
                "normal",
                "medium",
                "semibold",
                "bold",
                "extrabold",
                "black",
                gc,
              ],
            },
          ],
          "font-family": [{ font: [xl] }],
          "fvn-normal": ["normal-nums"],
          "fvn-ordinal": ["ordinal"],
          "fvn-slashed-zero": ["slashed-zero"],
          "fvn-figure": ["lining-nums", "oldstyle-nums"],
          "fvn-spacing": ["proportional-nums", "tabular-nums"],
          "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
          tracking: [
            {
              tracking: [
                "tighter",
                "tight",
                "normal",
                "wide",
                "wider",
                "widest",
                q,
              ],
            },
          ],
          "line-clamp": [{ "line-clamp": ["none", el, gc] }],
          leading: [
            {
              leading: [
                "none",
                "tight",
                "snug",
                "normal",
                "relaxed",
                "loose",
                ge,
                q,
              ],
            },
          ],
          "list-image": [{ "list-image": ["none", q] }],
          "list-style-type": [{ list: ["none", "disc", "decimal", q] }],
          "list-style-position": [{ list: ["inside", "outside"] }],
          "placeholder-color": [{ placeholder: [g] }],
          "placeholder-opacity": [{ "placeholder-opacity": [G] }],
          "text-alignment": [
            { text: ["left", "center", "right", "justify", "start", "end"] },
          ],
          "text-color": [{ text: [g] }],
          "text-opacity": [{ "text-opacity": [G] }],
          "text-decoration": [
            "underline",
            "overline",
            "line-through",
            "no-underline",
          ],
          "text-decoration-style": [{ decoration: [...z(), "wavy"] }],
          "text-decoration-thickness": [
            { decoration: ["auto", "from-font", ge, Ge] },
          ],
          "underline-offset": [{ "underline-offset": ["auto", ge, q] }],
          "text-decoration-color": [{ decoration: [g] }],
          "text-transform": [
            "uppercase",
            "lowercase",
            "capitalize",
            "normal-case",
          ],
          "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
          "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
          indent: [{ indent: K() }],
          "vertical-align": [
            {
              align: [
                "baseline",
                "top",
                "middle",
                "bottom",
                "text-top",
                "text-bottom",
                "sub",
                "super",
                q,
              ],
            },
          ],
          whitespace: [
            {
              whitespace: [
                "normal",
                "nowrap",
                "pre",
                "pre-line",
                "pre-wrap",
                "break-spaces",
              ],
            },
          ],
          break: [{ break: ["normal", "words", "all", "keep"] }],
          hyphens: [{ hyphens: ["none", "manual", "auto"] }],
          content: [{ content: ["none", q] }],
          "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
          "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
          "bg-opacity": [{ "bg-opacity": [G] }],
          "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
          "bg-position": [{ bg: [...ng(), Nh] }],
          "bg-repeat": [
            { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] },
          ],
          "bg-size": [{ bg: ["auto", "cover", "contain", wh] }],
          "bg-image": [
            {
              bg: [
                "none",
                { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
                Fh,
              ],
            },
          ],
          "bg-color": [{ bg: [g] }],
          "gradient-from-pos": [{ from: [b] }],
          "gradient-via-pos": [{ via: [b] }],
          "gradient-to-pos": [{ to: [b] }],
          "gradient-from": [{ from: [u] }],
          "gradient-via": [{ via: [u] }],
          "gradient-to": [{ to: [u] }],
          rounded: [{ rounded: [t] }],
          "rounded-s": [{ "rounded-s": [t] }],
          "rounded-e": [{ "rounded-e": [t] }],
          "rounded-t": [{ "rounded-t": [t] }],
          "rounded-r": [{ "rounded-r": [t] }],
          "rounded-b": [{ "rounded-b": [t] }],
          "rounded-l": [{ "rounded-l": [t] }],
          "rounded-ss": [{ "rounded-ss": [t] }],
          "rounded-se": [{ "rounded-se": [t] }],
          "rounded-ee": [{ "rounded-ee": [t] }],
          "rounded-es": [{ "rounded-es": [t] }],
          "rounded-tl": [{ "rounded-tl": [t] }],
          "rounded-tr": [{ "rounded-tr": [t] }],
          "rounded-br": [{ "rounded-br": [t] }],
          "rounded-bl": [{ "rounded-bl": [t] }],
          "border-w": [{ border: [o] }],
          "border-w-x": [{ "border-x": [o] }],
          "border-w-y": [{ "border-y": [o] }],
          "border-w-s": [{ "border-s": [o] }],
          "border-w-e": [{ "border-e": [o] }],
          "border-w-t": [{ "border-t": [o] }],
          "border-w-r": [{ "border-r": [o] }],
          "border-w-b": [{ "border-b": [o] }],
          "border-w-l": [{ "border-l": [o] }],
          "border-opacity": [{ "border-opacity": [G] }],
          "border-style": [{ border: [...z(), "hidden"] }],
          "divide-x": [{ "divide-x": [o] }],
          "divide-x-reverse": ["divide-x-reverse"],
          "divide-y": [{ "divide-y": [o] }],
          "divide-y-reverse": ["divide-y-reverse"],
          "divide-opacity": [{ "divide-opacity": [G] }],
          "divide-style": [{ divide: z() }],
          "border-color": [{ border: [l] }],
          "border-color-x": [{ "border-x": [l] }],
          "border-color-y": [{ "border-y": [l] }],
          "border-color-s": [{ "border-s": [l] }],
          "border-color-e": [{ "border-e": [l] }],
          "border-color-t": [{ "border-t": [l] }],
          "border-color-r": [{ "border-r": [l] }],
          "border-color-b": [{ "border-b": [l] }],
          "border-color-l": [{ "border-l": [l] }],
          "divide-color": [{ divide: [l] }],
          "outline-style": [{ outline: ["", ...z()] }],
          "outline-offset": [{ "outline-offset": [ge, q] }],
          "outline-w": [{ outline: [ge, Ge] }],
          "outline-color": [{ outline: [g] }],
          "ring-w": [{ ring: P() }],
          "ring-w-inset": ["ring-inset"],
          "ring-color": [{ ring: [g] }],
          "ring-opacity": [{ "ring-opacity": [G] }],
          "ring-offset-w": [{ "ring-offset": [ge, Ge] }],
          "ring-offset-color": [{ "ring-offset": [g] }],
          shadow: [{ shadow: ["", "inner", "none", be, xh] }],
          "shadow-color": [{ shadow: [xl] }],
          opacity: [{ opacity: [G] }],
          "mix-blend": [
            { "mix-blend": [...gg(), "plus-lighter", "plus-darker"] },
          ],
          "bg-blend": [{ "bg-blend": gg() }],
          filter: [{ filter: ["", "none"] }],
          blur: [{ blur: [e] }],
          brightness: [{ brightness: [C] }],
          contrast: [{ contrast: [A] }],
          "drop-shadow": [{ "drop-shadow": ["", "none", be, q] }],
          grayscale: [{ grayscale: [c] }],
          "hue-rotate": [{ "hue-rotate": [d] }],
          invert: [{ invert: [i] }],
          saturate: [{ saturate: [B] }],
          sepia: [{ sepia: [h] }],
          "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
          "backdrop-blur": [{ "backdrop-blur": [e] }],
          "backdrop-brightness": [{ "backdrop-brightness": [C] }],
          "backdrop-contrast": [{ "backdrop-contrast": [A] }],
          "backdrop-grayscale": [{ "backdrop-grayscale": [c] }],
          "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [d] }],
          "backdrop-invert": [{ "backdrop-invert": [i] }],
          "backdrop-opacity": [{ "backdrop-opacity": [G] }],
          "backdrop-saturate": [{ "backdrop-saturate": [B] }],
          "backdrop-sepia": [{ "backdrop-sepia": [h] }],
          "border-collapse": [{ border: ["collapse", "separate"] }],
          "border-spacing": [{ "border-spacing": [n] }],
          "border-spacing-x": [{ "border-spacing-x": [n] }],
          "border-spacing-y": [{ "border-spacing-y": [n] }],
          "table-layout": [{ table: ["auto", "fixed"] }],
          caption: [{ caption: ["top", "bottom"] }],
          transition: [
            {
              transition: [
                "none",
                "all",
                "",
                "colors",
                "opacity",
                "shadow",
                "transform",
                q,
              ],
            },
          ],
          duration: [{ duration: U() }],
          ease: [{ ease: ["linear", "in", "out", "in-out", q] }],
          delay: [{ delay: U() }],
          animate: [
            { animate: ["none", "spin", "ping", "pulse", "bounce", q] },
          ],
          transform: [{ transform: ["", "gpu", "none"] }],
          scale: [{ scale: [y] }],
          "scale-x": [{ "scale-x": [y] }],
          "scale-y": [{ "scale-y": [y] }],
          rotate: [{ rotate: [Fl, q] }],
          "translate-x": [{ "translate-x": [V] }],
          "translate-y": [{ "translate-y": [V] }],
          "skew-x": [{ "skew-x": [W] }],
          "skew-y": [{ "skew-y": [W] }],
          "transform-origin": [
            {
              origin: [
                "center",
                "top",
                "top-right",
                "right",
                "bottom-right",
                "bottom",
                "bottom-left",
                "left",
                "top-left",
                q,
              ],
            },
          ],
          accent: [{ accent: ["auto", g] }],
          appearance: [{ appearance: ["none", "auto"] }],
          cursor: [
            {
              cursor: [
                "auto",
                "default",
                "pointer",
                "wait",
                "text",
                "move",
                "help",
                "not-allowed",
                "none",
                "context-menu",
                "progress",
                "cell",
                "crosshair",
                "vertical-text",
                "alias",
                "copy",
                "no-drop",
                "grab",
                "grabbing",
                "all-scroll",
                "col-resize",
                "row-resize",
                "n-resize",
                "e-resize",
                "s-resize",
                "w-resize",
                "ne-resize",
                "nw-resize",
                "se-resize",
                "sw-resize",
                "ew-resize",
                "ns-resize",
                "nesw-resize",
                "nwse-resize",
                "zoom-in",
                "zoom-out",
                q,
              ],
            },
          ],
          "caret-color": [{ caret: [g] }],
          "pointer-events": [{ "pointer-events": ["none", "auto"] }],
          resize: [{ resize: ["none", "y", "x", ""] }],
          "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
          "scroll-m": [{ "scroll-m": K() }],
          "scroll-mx": [{ "scroll-mx": K() }],
          "scroll-my": [{ "scroll-my": K() }],
          "scroll-ms": [{ "scroll-ms": K() }],
          "scroll-me": [{ "scroll-me": K() }],
          "scroll-mt": [{ "scroll-mt": K() }],
          "scroll-mr": [{ "scroll-mr": K() }],
          "scroll-mb": [{ "scroll-mb": K() }],
          "scroll-ml": [{ "scroll-ml": K() }],
          "scroll-p": [{ "scroll-p": K() }],
          "scroll-px": [{ "scroll-px": K() }],
          "scroll-py": [{ "scroll-py": K() }],
          "scroll-ps": [{ "scroll-ps": K() }],
          "scroll-pe": [{ "scroll-pe": K() }],
          "scroll-pt": [{ "scroll-pt": K() }],
          "scroll-pr": [{ "scroll-pr": K() }],
          "scroll-pb": [{ "scroll-pb": K() }],
          "scroll-pl": [{ "scroll-pl": K() }],
          "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
          "snap-stop": [{ snap: ["normal", "always"] }],
          "snap-type": [{ snap: ["none", "x", "y", "both"] }],
          "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
          touch: [{ touch: ["auto", "none", "manipulation"] }],
          "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
          "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
          "touch-pz": ["touch-pinch-zoom"],
          select: [{ select: ["none", "text", "all", "auto"] }],
          "will-change": [
            { "will-change": ["auto", "scroll", "contents", "transform", q] },
          ],
          fill: [{ fill: [g, "none"] }],
          "stroke-w": [{ stroke: [ge, Ge, gc] }],
          stroke: [{ stroke: [g, "none"] }],
          sr: ["sr-only", "not-sr-only"],
          "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
        },
        conflictingClassGroups: {
          overflow: ["overflow-x", "overflow-y"],
          overscroll: ["overscroll-x", "overscroll-y"],
          inset: [
            "inset-x",
            "inset-y",
            "start",
            "end",
            "top",
            "right",
            "bottom",
            "left",
          ],
          "inset-x": ["right", "left"],
          "inset-y": ["top", "bottom"],
          flex: ["basis", "grow", "shrink"],
          gap: ["gap-x", "gap-y"],
          p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
          px: ["pr", "pl"],
          py: ["pt", "pb"],
          m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
          mx: ["mr", "ml"],
          my: ["mt", "mb"],
          size: ["w", "h"],
          "font-size": ["leading"],
          "fvn-normal": [
            "fvn-ordinal",
            "fvn-slashed-zero",
            "fvn-figure",
            "fvn-spacing",
            "fvn-fraction",
          ],
          "fvn-ordinal": ["fvn-normal"],
          "fvn-slashed-zero": ["fvn-normal"],
          "fvn-figure": ["fvn-normal"],
          "fvn-spacing": ["fvn-normal"],
          "fvn-fraction": ["fvn-normal"],
          "line-clamp": ["display", "overflow"],
          rounded: [
            "rounded-s",
            "rounded-e",
            "rounded-t",
            "rounded-r",
            "rounded-b",
            "rounded-l",
            "rounded-ss",
            "rounded-se",
            "rounded-ee",
            "rounded-es",
            "rounded-tl",
            "rounded-tr",
            "rounded-br",
            "rounded-bl",
          ],
          "rounded-s": ["rounded-ss", "rounded-es"],
          "rounded-e": ["rounded-se", "rounded-ee"],
          "rounded-t": ["rounded-tl", "rounded-tr"],
          "rounded-r": ["rounded-tr", "rounded-br"],
          "rounded-b": ["rounded-br", "rounded-bl"],
          "rounded-l": ["rounded-tl", "rounded-bl"],
          "border-spacing": ["border-spacing-x", "border-spacing-y"],
          "border-w": [
            "border-w-s",
            "border-w-e",
            "border-w-t",
            "border-w-r",
            "border-w-b",
            "border-w-l",
          ],
          "border-w-x": ["border-w-r", "border-w-l"],
          "border-w-y": ["border-w-t", "border-w-b"],
          "border-color": [
            "border-color-s",
            "border-color-e",
            "border-color-t",
            "border-color-r",
            "border-color-b",
            "border-color-l",
          ],
          "border-color-x": ["border-color-r", "border-color-l"],
          "border-color-y": ["border-color-t", "border-color-b"],
          "scroll-m": [
            "scroll-mx",
            "scroll-my",
            "scroll-ms",
            "scroll-me",
            "scroll-mt",
            "scroll-mr",
            "scroll-mb",
            "scroll-ml",
          ],
          "scroll-mx": ["scroll-mr", "scroll-ml"],
          "scroll-my": ["scroll-mt", "scroll-mb"],
          "scroll-p": [
            "scroll-px",
            "scroll-py",
            "scroll-ps",
            "scroll-pe",
            "scroll-pt",
            "scroll-pr",
            "scroll-pb",
            "scroll-pl",
          ],
          "scroll-px": ["scroll-pr", "scroll-pl"],
          "scroll-py": ["scroll-pt", "scroll-pb"],
          touch: ["touch-x", "touch-y", "touch-pz"],
          "touch-x": ["touch"],
          "touch-y": ["touch"],
          "touch-pz": ["touch"],
        },
        conflictingClassGroupModifiers: { "font-size": ["leading"] },
      };
    },
    Qh = Vh(Uh);
  function O(...g) {
    return Qh(ah(g));
  }
  const Lh = Mi(
    "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
    {
      variants: {
        variant: {
          default:
            "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
          secondary:
            "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
          destructive:
            "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
          outline: "text-foreground",
        },
      },
      defaultVariants: { variant: "default" },
    }
  );
  function Dh({ className: g, variant: I, ...e }) {
    return s.jsx("div", { className: O(Lh({ variant: I }), g), ...e });
  }
  function Th(g, I) {
    typeof g == "function" ? g(I) : g != null && (g.current = I);
  }
  function CA(...g) {
    return (I) => g.forEach((e) => Th(e, I));
  }
  function Gg(...g) {
    return a.useCallback(CA(...g), g);
  }
  function Ot(g, I = []) {
    let e = [];
    function C(t, n) {
      const o = a.createContext(n),
        A = e.length;
      e = [...e, n];
      const c = (i) => {
        var G;
        const { scope: r, children: u, ...b } = i,
          m = ((G = r == null ? void 0 : r[g]) == null ? void 0 : G[A]) || o,
          p = a.useMemo(() => b, Object.values(b));
        return s.jsx(m.Provider, { value: p, children: u });
      };
      c.displayName = t + "Provider";
      function d(i, r) {
        var m;
        const u =
            ((m = r == null ? void 0 : r[g]) == null ? void 0 : m[A]) || o,
          b = a.useContext(u);
        if (b) return b;
        if (n !== void 0) return n;
        throw new Error(`\`${i}\` must be used within \`${t}\``);
      }
      return [c, d];
    }
    const l = () => {
      const t = e.map((n) => a.createContext(n));
      return function (o) {
        const A = (o == null ? void 0 : o[g]) || t;
        return a.useMemo(() => ({ [`__scope${g}`]: { ...o, [g]: A } }), [o, A]);
      };
    };
    return (l.scopeName = g), [C, jh(l, ...I)];
  }
  function jh(...g) {
    const I = g[0];
    if (g.length === 1) return I;
    const e = () => {
      const C = g.map((l) => ({ useScope: l(), scopeName: l.scopeName }));
      return function (t) {
        const n = C.reduce((o, { useScope: A, scopeName: c }) => {
          const i = A(t)[`__scope${c}`];
          return { ...o, ...i };
        }, {});
        return a.useMemo(() => ({ [`__scope${I.scopeName}`]: n }), [n]);
      };
    };
    return (e.scopeName = I.scopeName), e;
  }
  function E(g, I, { checkForDefaultPrevented: e = !0 } = {}) {
    return function (l) {
      if ((g == null || g(l), e === !1 || !l.defaultPrevented))
        return I == null ? void 0 : I(l);
    };
  }
  function tI(g) {
    const I = a.useRef(g);
    return (
      a.useEffect(() => {
        I.current = g;
      }),
      a.useMemo(
        () =>
          (...e) => {
            var C;
            return (C = I.current) == null ? void 0 : C.call(I, ...e);
          },
        []
      )
    );
  }
  function rl({ prop: g, defaultProp: I, onChange: e = () => {} }) {
    const [C, l] = Ph({ defaultProp: I, onChange: e }),
      t = g !== void 0,
      n = t ? g : C,
      o = tI(e),
      A = a.useCallback(
        (c) => {
          if (t) {
            const i = typeof c == "function" ? c(g) : c;
            i !== g && o(i);
          } else l(c);
        },
        [t, g, l, o]
      );
    return [n, A];
  }
  function Ph({ defaultProp: g, onChange: I }) {
    const e = a.useState(g),
      [C] = e,
      l = a.useRef(C),
      t = tI(I);
    return (
      a.useEffect(() => {
        l.current !== C && (t(C), (l.current = C));
      }, [C, l, t]),
      e
    );
  }
  function dZ(g) {
    const I = a.useRef({ value: g, previous: g });
    return a.useMemo(
      () => (
        I.current.value !== g &&
          ((I.current.previous = I.current.value), (I.current.value = g)),
        I.current.previous
      ),
      [g]
    );
  }
  var xg =
    globalThis != null && globalThis.document ? a.useLayoutEffect : () => {};
  function iZ(g) {
    const [I, e] = a.useState(void 0);
    return (
      xg(() => {
        if (g) {
          e({ width: g.offsetWidth, height: g.offsetHeight });
          const C = new ResizeObserver((l) => {
            if (!Array.isArray(l) || !l.length) return;
            const t = l[0];
            let n, o;
            if ("borderBoxSize" in t) {
              const A = t.borderBoxSize,
                c = Array.isArray(A) ? A[0] : A;
              (n = c.inlineSize), (o = c.blockSize);
            } else (n = g.offsetWidth), (o = g.offsetHeight);
            e({ width: n, height: o });
          });
          return C.observe(g, { box: "border-box" }), () => C.unobserve(g);
        } else e(void 0);
      }, [g]),
      I
    );
  }
  function Oh(g, I) {
    return a.useReducer((e, C) => I[e][C] ?? e, g);
  }
  var hl = (g) => {
    const { present: I, children: e } = g,
      C = _h(I),
      l =
        typeof e == "function"
          ? e({ present: C.isPresent })
          : a.Children.only(e),
      t = Gg(C.ref, qh(l));
    return typeof e == "function" || C.isPresent
      ? a.cloneElement(l, { ref: t })
      : null;
  };
  hl.displayName = "Presence";
  function _h(g) {
    const [I, e] = a.useState(),
      C = a.useRef({}),
      l = a.useRef(g),
      t = a.useRef("none"),
      n = g ? "mounted" : "unmounted",
      [o, A] = Oh(n, {
        mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
        unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
        unmounted: { MOUNT: "mounted" },
      });
    return (
      a.useEffect(() => {
        const c = hn(C.current);
        t.current = o === "mounted" ? c : "none";
      }, [o]),
      xg(() => {
        const c = C.current,
          d = l.current;
        if (d !== g) {
          const r = t.current,
            u = hn(c);
          g
            ? A("MOUNT")
            : u === "none" || (c == null ? void 0 : c.display) === "none"
            ? A("UNMOUNT")
            : A(d && r !== u ? "ANIMATION_OUT" : "UNMOUNT"),
            (l.current = g);
        }
      }, [g, A]),
      xg(() => {
        if (I) {
          let c;
          const d = I.ownerDocument.defaultView ?? window,
            i = (u) => {
              const m = hn(C.current).includes(u.animationName);
              if (u.target === I && m && (A("ANIMATION_END"), !l.current)) {
                const p = I.style.animationFillMode;
                (I.style.animationFillMode = "forwards"),
                  (c = d.setTimeout(() => {
                    I.style.animationFillMode === "forwards" &&
                      (I.style.animationFillMode = p);
                  }));
              }
            },
            r = (u) => {
              u.target === I && (t.current = hn(C.current));
            };
          return (
            I.addEventListener("animationstart", r),
            I.addEventListener("animationcancel", i),
            I.addEventListener("animationend", i),
            () => {
              d.clearTimeout(c),
                I.removeEventListener("animationstart", r),
                I.removeEventListener("animationcancel", i),
                I.removeEventListener("animationend", i);
            }
          );
        } else A("ANIMATION_END");
      }, [I, A]),
      {
        isPresent: ["mounted", "unmountSuspended"].includes(o),
        ref: a.useCallback((c) => {
          c && (C.current = getComputedStyle(c)), e(c);
        }, []),
      }
    );
  }
  function hn(g) {
    return (g == null ? void 0 : g.animationName) || "none";
  }
  function qh(g) {
    var C, l;
    let I =
        (C = Object.getOwnPropertyDescriptor(g.props, "ref")) == null
          ? void 0
          : C.get,
      e = I && "isReactWarning" in I && I.isReactWarning;
    return e
      ? g.ref
      : ((I =
          (l = Object.getOwnPropertyDescriptor(g, "ref")) == null
            ? void 0
            : l.get),
        (e = I && "isReactWarning" in I && I.isReactWarning),
        e ? g.props.ref : g.props.ref || g.ref);
  }
  var ZC = a.forwardRef((g, I) => {
    const { children: e, ...C } = g,
      l = a.Children.toArray(e),
      t = l.find(gS);
    if (t) {
      const n = t.props.children,
        o = l.map((A) =>
          A === t
            ? a.Children.count(n) > 1
              ? a.Children.only(null)
              : a.isValidElement(n)
              ? n.props.children
              : null
            : A
        );
      return s.jsx(md, {
        ...C,
        ref: I,
        children: a.isValidElement(n) ? a.cloneElement(n, void 0, o) : null,
      });
    }
    return s.jsx(md, { ...C, ref: I, children: e });
  });
  ZC.displayName = "Slot";
  var md = a.forwardRef((g, I) => {
    const { children: e, ...C } = g;
    if (a.isValidElement(e)) {
      const l = eS(e);
      return a.cloneElement(e, { ...IS(C, e.props), ref: I ? CA(I, l) : l });
    }
    return a.Children.count(e) > 1 ? a.Children.only(null) : null;
  });
  md.displayName = "SlotClone";
  var $h = ({ children: g }) => s.jsx(s.Fragment, { children: g });
  function gS(g) {
    return a.isValidElement(g) && g.type === $h;
  }
  function IS(g, I) {
    const e = { ...I };
    for (const C in I) {
      const l = g[C],
        t = I[C];
      /^on[A-Z]/.test(C)
        ? l && t
          ? (e[C] = (...o) => {
              t(...o), l(...o);
            })
          : l && (e[C] = l)
        : C === "style"
        ? (e[C] = { ...l, ...t })
        : C === "className" && (e[C] = [l, t].filter(Boolean).join(" "));
    }
    return { ...g, ...e };
  }
  function eS(g) {
    var C, l;
    let I =
        (C = Object.getOwnPropertyDescriptor(g.props, "ref")) == null
          ? void 0
          : C.get,
      e = I && "isReactWarning" in I && I.isReactWarning;
    return e
      ? g.ref
      : ((I =
          (l = Object.getOwnPropertyDescriptor(g, "ref")) == null
            ? void 0
            : l.get),
        (e = I && "isReactWarning" in I && I.isReactWarning),
        e ? g.props.ref : g.props.ref || g.ref);
  }
  var CS = [
      "a",
      "button",
      "div",
      "form",
      "h2",
      "h3",
      "img",
      "input",
      "label",
      "li",
      "nav",
      "ol",
      "p",
      "span",
      "svg",
      "ul",
    ],
    tg = CS.reduce((g, I) => {
      const e = a.forwardRef((C, l) => {
        const { asChild: t, ...n } = C,
          o = t ? ZC : I;
        return (
          typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
          s.jsx(o, { ...n, ref: l })
        );
      });
      return (e.displayName = `Primitive.${I}`), { ...g, [I]: e };
    }, {});
  function aZ(g, I) {
    g && jt.flushSync(() => g.dispatchEvent(I));
  }
  var Ei = "Checkbox",
    [lS, Yk] = Ot(Ei),
    [tS, nS] = lS(Ei),
    rZ = a.forwardRef((g, I) => {
      const {
          __scopeCheckbox: e,
          name: C,
          checked: l,
          defaultChecked: t,
          required: n,
          disabled: o,
          value: A = "on",
          onCheckedChange: c,
          form: d,
          ...i
        } = g,
        [r, u] = a.useState(null),
        b = Gg(I, (y) => u(y)),
        m = a.useRef(!1),
        p = r ? d || !!r.closest("form") : !0,
        [G = !1, Z] = rl({ prop: l, defaultProp: t, onChange: c }),
        B = a.useRef(G);
      return (
        a.useEffect(() => {
          const y = r == null ? void 0 : r.form;
          if (y) {
            const h = () => Z(B.current);
            return (
              y.addEventListener("reset", h),
              () => y.removeEventListener("reset", h)
            );
          }
        }, [r, Z]),
        s.jsxs(tS, {
          scope: e,
          state: G,
          disabled: o,
          children: [
            s.jsx(tg.button, {
              type: "button",
              role: "checkbox",
              "aria-checked": xe(G) ? "mixed" : G,
              "aria-required": n,
              "data-state": mZ(G),
              "data-disabled": o ? "" : void 0,
              disabled: o,
              value: A,
              ...i,
              ref: b,
              onKeyDown: E(g.onKeyDown, (y) => {
                y.key === "Enter" && y.preventDefault();
              }),
              onClick: E(g.onClick, (y) => {
                Z((h) => (xe(h) ? !0 : !h)),
                  p &&
                    ((m.current = y.isPropagationStopped()),
                    m.current || y.stopPropagation());
              }),
            }),
            p &&
              s.jsx(oS, {
                control: r,
                bubbles: !m.current,
                name: C,
                value: A,
                checked: G,
                required: n,
                disabled: o,
                form: d,
                style: { transform: "translateX(-100%)" },
                defaultChecked: xe(t) ? !1 : t,
              }),
          ],
        })
      );
    });
  rZ.displayName = Ei;
  var sZ = "CheckboxIndicator",
    uZ = a.forwardRef((g, I) => {
      const { __scopeCheckbox: e, forceMount: C, ...l } = g,
        t = nS(sZ, e);
      return s.jsx(hl, {
        present: C || xe(t.state) || t.state === !0,
        children: s.jsx(tg.span, {
          "data-state": mZ(t.state),
          "data-disabled": t.disabled ? "" : void 0,
          ...l,
          ref: I,
          style: { pointerEvents: "none", ...g.style },
        }),
      });
    });
  uZ.displayName = sZ;
  var oS = (g) => {
    const {
        control: I,
        checked: e,
        bubbles: C = !0,
        defaultChecked: l,
        ...t
      } = g,
      n = a.useRef(null),
      o = dZ(e),
      A = iZ(I);
    a.useEffect(() => {
      const d = n.current,
        i = window.HTMLInputElement.prototype,
        u = Object.getOwnPropertyDescriptor(i, "checked").set;
      if (o !== e && u) {
        const b = new Event("click", { bubbles: C });
        (d.indeterminate = xe(e)),
          u.call(d, xe(e) ? !1 : e),
          d.dispatchEvent(b);
      }
    }, [o, e, C]);
    const c = a.useRef(xe(e) ? !1 : e);
    return s.jsx("input", {
      type: "checkbox",
      "aria-hidden": !0,
      defaultChecked: l ?? c.current,
      ...t,
      tabIndex: -1,
      ref: n,
      style: {
        ...g.style,
        ...A,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0,
      },
    });
  };
  function xe(g) {
    return g === "indeterminate";
  }
  function mZ(g) {
    return xe(g) ? "indeterminate" : g ? "checked" : "unchecked";
  }
  var ZZ = rZ,
    AS = uZ;
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const cS = (g) => g.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
    GZ = (...g) =>
      g
        .filter((I, e, C) => !!I && I.trim() !== "" && C.indexOf(I) === e)
        .join(" ")
        .trim();
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ var dS = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
  };
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const iS = a.forwardRef(
    (
      {
        color: g = "currentColor",
        size: I = 24,
        strokeWidth: e = 2,
        absoluteStrokeWidth: C,
        className: l = "",
        children: t,
        iconNode: n,
        ...o
      },
      A
    ) =>
      a.createElement(
        "svg",
        {
          ref: A,
          ...dS,
          width: I,
          height: I,
          stroke: g,
          strokeWidth: C ? (Number(e) * 24) / Number(I) : e,
          className: GZ("lucide", l),
          ...o,
        },
        [
          ...n.map(([c, d]) => a.createElement(c, d)),
          ...(Array.isArray(t) ? t : [t]),
        ]
      )
  );
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const RI = (g, I) => {
    const e = a.forwardRef(({ className: C, ...l }, t) =>
      a.createElement(iS, {
        ref: t,
        iconNode: I,
        className: GZ(`lucide-${cS(g)}`, C),
        ...l,
      })
    );
    return (e.displayName = `${g}`), e;
  };
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const _r = RI("ArrowLeft", [
    ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
    ["path", { d: "M19 12H5", key: "x3x0zl" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const Ui = RI("Check", [
    ["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const bZ = RI("ChevronDown", [
    ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const aS = RI("ChevronRight", [
    ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const rS = RI("ChevronUp", [
    ["path", { d: "m18 15-6-6-6 6", key: "153udz" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const sS = RI("Circle", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const uS = RI("Grid3x3", [
    [
      "rect",
      { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" },
    ],
    ["path", { d: "M3 9h18", key: "1pudct" }],
    ["path", { d: "M3 15h18", key: "5xshup" }],
    ["path", { d: "M9 3v18", key: "fh3hqa" }],
    ["path", { d: "M15 3v18", key: "14nvp0" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const mS = RI("Info", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "M12 16v-4", key: "1dtifu" }],
    ["path", { d: "M12 8h.01", key: "e9boi3" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const BZ = RI("LoaderCircle", [
    ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const ZS = RI("RotateCcw", [
    [
      "path",
      { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" },
    ],
    ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const GS = RI("TriangleAlert", [
    [
      "path",
      {
        d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
        key: "wmoenq",
      },
    ],
    ["path", { d: "M12 9v4", key: "juzpu7" }],
    ["path", { d: "M12 17h.01", key: "p32p05" }],
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const bS = RI("X", [
      ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
      ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
    ]),
    Zd = a.forwardRef(({ className: g, ...I }, e) =>
      s.jsx(ZZ, {
        ref: e,
        className: O(
          "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
          g
        ),
        ...I,
        children: s.jsx(AS, {
          className: O("flex items-center justify-center text-current"),
          children: s.jsx(Ui, { className: "h-4 w-4" }),
        }),
      })
    );
  Zd.displayName = ZZ.displayName;
  function Mg(g, I) {
    if (g == null) return {};
    var e = {},
      C = Object.keys(g),
      l,
      t;
    for (t = 0; t < C.length; t++)
      (l = C[t]), !(I.indexOf(l) >= 0) && (e[l] = g[l]);
    return e;
  }
  var BS = ["color"],
    Gd = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, BS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    pS = ["color"],
    yS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, pS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M8.14645 3.14645C8.34171 2.95118 8.65829 2.95118 8.85355 3.14645L12.8536 7.14645C13.0488 7.34171 13.0488 7.65829 12.8536 7.85355L8.85355 11.8536C8.65829 12.0488 8.34171 12.0488 8.14645 11.8536C7.95118 11.6583 7.95118 11.3417 8.14645 11.1464L11.2929 8H2.5C2.22386 8 2 7.77614 2 7.5C2 7.22386 2.22386 7 2.5 7H11.2929L8.14645 3.85355C7.95118 3.65829 7.95118 3.34171 8.14645 3.14645Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    hS = ["color"],
    bd = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, hS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    SS = ["color"],
    VS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, SS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    WS = ["color"],
    RS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, WS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M7.49991 0.877045C3.84222 0.877045 0.877075 3.84219 0.877075 7.49988C0.877075 11.1575 3.84222 14.1227 7.49991 14.1227C11.1576 14.1227 14.1227 11.1575 14.1227 7.49988C14.1227 3.84219 11.1576 0.877045 7.49991 0.877045ZM1.82708 7.49988C1.82708 4.36686 4.36689 1.82704 7.49991 1.82704C10.6329 1.82704 13.1727 4.36686 13.1727 7.49988C13.1727 10.6329 10.6329 13.1727 7.49991 13.1727C4.36689 13.1727 1.82708 10.6329 1.82708 7.49988ZM10.1589 5.53774C10.3178 5.31191 10.2636 5.00001 10.0378 4.84109C9.81194 4.68217 9.50004 4.73642 9.34112 4.96225L6.51977 8.97154L5.35681 7.78706C5.16334 7.59002 4.84677 7.58711 4.64973 7.78058C4.45268 7.97404 4.44978 8.29061 4.64325 8.48765L6.22658 10.1003C6.33054 10.2062 6.47617 10.2604 6.62407 10.2483C6.77197 10.2363 6.90686 10.1591 6.99226 10.0377L10.1589 5.53774Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    XS = ["color"],
    JS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, XS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    vS = ["color"],
    kS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, vS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    fS = ["color"],
    YS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, fS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    HS = ["color"],
    wS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, HS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    NS = ["color"],
    KS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, NS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M0.877075 7.49988C0.877075 3.84219 3.84222 0.877045 7.49991 0.877045C11.1576 0.877045 14.1227 3.84219 14.1227 7.49988C14.1227 11.1575 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1575 0.877075 7.49988ZM7.49991 1.82704C4.36689 1.82704 1.82708 4.36686 1.82708 7.49988C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49988C13.1727 4.36686 10.6329 1.82704 7.49991 1.82704ZM9.85358 5.14644C10.0488 5.3417 10.0488 5.65829 9.85358 5.85355L8.20713 7.49999L9.85358 9.14644C10.0488 9.3417 10.0488 9.65829 9.85358 9.85355C9.65832 10.0488 9.34173 10.0488 9.14647 9.85355L7.50002 8.2071L5.85358 9.85355C5.65832 10.0488 5.34173 10.0488 5.14647 9.85355C4.95121 9.65829 4.95121 9.3417 5.14647 9.14644L6.79292 7.49999L5.14647 5.85355C4.95121 5.65829 4.95121 5.3417 5.14647 5.14644C5.34173 4.95118 5.65832 4.95118 5.85358 5.14644L7.50002 6.79289L9.14647 5.14644C9.34173 4.95118 9.65832 4.95118 9.85358 5.14644Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    FS = ["color"],
    xS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, FS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    MS = ["color"],
    zS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, MS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M6.85355 3.85355C7.04882 3.65829 7.04882 3.34171 6.85355 3.14645C6.65829 2.95118 6.34171 2.95118 6.14645 3.14645L2.14645 7.14645C1.95118 7.34171 1.95118 7.65829 2.14645 7.85355L6.14645 11.8536C6.34171 12.0488 6.65829 12.0488 6.85355 11.8536C7.04882 11.6583 7.04882 11.3417 6.85355 11.1464L3.20711 7.5L6.85355 3.85355ZM12.8536 3.85355C13.0488 3.65829 13.0488 3.34171 12.8536 3.14645C12.6583 2.95118 12.3417 2.95118 12.1464 3.14645L8.14645 7.14645C7.95118 7.34171 7.95118 7.65829 8.14645 7.85355L12.1464 11.8536C12.3417 12.0488 12.6583 12.0488 12.8536 11.8536C13.0488 11.6583 13.0488 11.3417 12.8536 11.1464L9.20711 7.5L12.8536 3.85355Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    ES = ["color"],
    US = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, ES);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M2.14645 11.1464C1.95118 11.3417 1.95118 11.6583 2.14645 11.8536C2.34171 12.0488 2.65829 12.0488 2.85355 11.8536L6.85355 7.85355C7.04882 7.65829 7.04882 7.34171 6.85355 7.14645L2.85355 3.14645C2.65829 2.95118 2.34171 2.95118 2.14645 3.14645C1.95118 3.34171 1.95118 3.65829 2.14645 3.85355L5.79289 7.5L2.14645 11.1464ZM8.14645 11.1464C7.95118 11.3417 7.95118 11.6583 8.14645 11.8536C8.34171 12.0488 8.65829 12.0488 8.85355 11.8536L12.8536 7.85355C13.0488 7.65829 13.0488 7.34171 12.8536 7.14645L8.85355 3.14645C8.65829 2.95118 8.34171 2.95118 8.14645 3.14645C7.95118 3.34171 7.95118 3.65829 8.14645 3.85355L11.7929 7.5L8.14645 11.1464Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    QS = ["color"],
    LS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, QS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M13.3536 2.35355C13.5488 2.15829 13.5488 1.84171 13.3536 1.64645C13.1583 1.45118 12.8417 1.45118 12.6464 1.64645L10.6828 3.61012C9.70652 3.21671 8.63759 3 7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C0.902945 9.08812 2.02314 10.1861 3.36061 10.9323L1.64645 12.6464C1.45118 12.8417 1.45118 13.1583 1.64645 13.3536C1.84171 13.5488 2.15829 13.5488 2.35355 13.3536L4.31723 11.3899C5.29348 11.7833 6.36241 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C14.0971 5.9119 12.9769 4.81391 11.6394 4.06771L13.3536 2.35355ZM9.90428 4.38861C9.15332 4.1361 8.34759 4 7.5 4C4.80285 4 2.52952 5.37816 1.09622 7.50001C1.87284 8.6497 2.89609 9.58106 4.09974 10.1931L9.90428 4.38861ZM5.09572 10.6114L10.9003 4.80685C12.1039 5.41894 13.1272 6.35031 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11C6.65241 11 5.84668 10.8639 5.09572 10.6114Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    DS = ["color"],
    TS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, DS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M5.5 3C4.67157 3 4 3.67157 4 4.5C4 5.32843 4.67157 6 5.5 6C6.32843 6 7 5.32843 7 4.5C7 3.67157 6.32843 3 5.5 3ZM3 5C3.01671 5 3.03323 4.99918 3.04952 4.99758C3.28022 6.1399 4.28967 7 5.5 7C6.71033 7 7.71978 6.1399 7.95048 4.99758C7.96677 4.99918 7.98329 5 8 5H13.5C13.7761 5 14 4.77614 14 4.5C14 4.22386 13.7761 4 13.5 4H8C7.98329 4 7.96677 4.00082 7.95048 4.00242C7.71978 2.86009 6.71033 2 5.5 2C4.28967 2 3.28022 2.86009 3.04952 4.00242C3.03323 4.00082 3.01671 4 3 4H1.5C1.22386 4 1 4.22386 1 4.5C1 4.77614 1.22386 5 1.5 5H3ZM11.9505 10.9976C11.7198 12.1399 10.7103 13 9.5 13C8.28967 13 7.28022 12.1399 7.04952 10.9976C7.03323 10.9992 7.01671 11 7 11H1.5C1.22386 11 1 10.7761 1 10.5C1 10.2239 1.22386 10 1.5 10H7C7.01671 10 7.03323 10.0008 7.04952 10.0024C7.28022 8.8601 8.28967 8 9.5 8C10.7103 8 11.7198 8.8601 11.9505 10.0024C11.9668 10.0008 11.9833 10 12 10H13.5C13.7761 10 14 10.2239 14 10.5C14 10.7761 13.7761 11 13.5 11H12C11.9833 11 11.9668 10.9992 11.9505 10.9976ZM8 10.5C8 9.67157 8.67157 9 9.5 9C10.3284 9 11 9.67157 11 10.5C11 11.3284 10.3284 12 9.5 12C8.67157 12 8 11.3284 8 10.5Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    jS = ["color"],
    PS = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, jS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M0.877075 7.49972C0.877075 3.84204 3.84222 0.876892 7.49991 0.876892C11.1576 0.876892 14.1227 3.84204 14.1227 7.49972C14.1227 11.1574 11.1576 14.1226 7.49991 14.1226C3.84222 14.1226 0.877075 11.1574 0.877075 7.49972ZM7.49991 1.82689C4.36689 1.82689 1.82708 4.36671 1.82708 7.49972C1.82708 10.6327 4.36689 13.1726 7.49991 13.1726C10.6329 13.1726 13.1727 10.6327 13.1727 7.49972C13.1727 4.36671 10.6329 1.82689 7.49991 1.82689ZM8.24993 10.5C8.24993 10.9142 7.91414 11.25 7.49993 11.25C7.08571 11.25 6.74993 10.9142 6.74993 10.5C6.74993 10.0858 7.08571 9.75 7.49993 9.75C7.91414 9.75 8.24993 10.0858 8.24993 10.5ZM6.05003 6.25C6.05003 5.57211 6.63511 4.925 7.50003 4.925C8.36496 4.925 8.95003 5.57211 8.95003 6.25C8.95003 6.74118 8.68002 6.99212 8.21447 7.27494C8.16251 7.30651 8.10258 7.34131 8.03847 7.37854L8.03841 7.37858C7.85521 7.48497 7.63788 7.61119 7.47449 7.73849C7.23214 7.92732 6.95003 8.23198 6.95003 8.7C6.95004 9.00376 7.19628 9.25 7.50004 9.25C7.8024 9.25 8.04778 9.00601 8.05002 8.70417L8.05056 8.7033C8.05924 8.6896 8.08493 8.65735 8.15058 8.6062C8.25207 8.52712 8.36508 8.46163 8.51567 8.37436L8.51571 8.37433C8.59422 8.32883 8.68296 8.27741 8.78559 8.21506C9.32004 7.89038 10.05 7.35382 10.05 6.25C10.05 4.92789 8.93511 3.825 7.50003 3.825C6.06496 3.825 4.95003 4.92789 4.95003 6.25C4.95003 6.55376 5.19628 6.8 5.50003 6.8C5.80379 6.8 6.05003 6.55376 6.05003 6.25Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    }),
    OS = ["color"],
    _S = a.forwardRef(function (g, I) {
      var e = g.color,
        C = e === void 0 ? "currentColor" : e,
        l = Mg(g, OS);
      return a.createElement(
        "svg",
        Object.assign(
          {
            width: "15",
            height: "15",
            viewBox: "0 0 15 15",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
          },
          l,
          { ref: I }
        ),
        a.createElement("path", {
          d: "M5.49998 0.5C5.49998 0.223858 5.72383 0 5.99998 0H7.49998H8.99998C9.27612 0 9.49998 0.223858 9.49998 0.5C9.49998 0.776142 9.27612 1 8.99998 1H7.99998V2.11922C9.09832 2.20409 10.119 2.56622 10.992 3.13572C11.0116 3.10851 11.0336 3.08252 11.058 3.05806L11.858 2.25806C12.1021 2.01398 12.4978 2.01398 12.7419 2.25806C12.986 2.50214 12.986 2.89786 12.7419 3.14194L11.967 3.91682C13.1595 5.07925 13.9 6.70314 13.9 8.49998C13.9 12.0346 11.0346 14.9 7.49998 14.9C3.96535 14.9 1.09998 12.0346 1.09998 8.49998C1.09998 5.13362 3.69904 2.3743 6.99998 2.11922V1H5.99998C5.72383 1 5.49998 0.776142 5.49998 0.5ZM2.09998 8.49998C2.09998 5.51764 4.51764 3.09998 7.49998 3.09998C10.4823 3.09998 12.9 5.51764 12.9 8.49998C12.9 11.4823 10.4823 13.9 7.49998 13.9C4.51764 13.9 2.09998 11.4823 2.09998 8.49998ZM7.99998 4.5C7.99998 4.22386 7.77612 4 7.49998 4C7.22383 4 6.99998 4.22386 6.99998 4.5V9.5C6.99998 9.77614 7.22383 10 7.49998 10C7.77612 10 7.99998 9.77614 7.99998 9.5V4.5Z",
          fill: C,
          fillRule: "evenodd",
          clipRule: "evenodd",
        })
      );
    });
  const pZ = [
      { value: "bug", label: "Bug", color: "red" },
      { value: "feature", label: "Feature", color: "green" },
      { value: "documentation", label: "Documentation", color: "blue" },
    ],
    qS = [
      { value: "backlog", label: "Backlog", icon: PS },
      { value: "todo", label: "Todo", icon: YS },
      { value: "in progress", label: "In Progress", icon: _S },
      { value: "done", label: "Done", icon: RS },
      { value: "canceled", label: "Canceled", icon: KS },
    ],
    $S = [
      { label: "Low", value: "low", icon: Gd },
      { label: "Medium", value: "medium", icon: yS },
      { label: "High", value: "high", icon: bd },
    ],
    gV = Mi(
      "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      {
        variants: {
          variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive:
              "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline:
              "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary:
              "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline",
          },
          size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10",
          },
        },
        defaultVariants: { variant: "default", size: "default" },
      }
    ),
    fg = a.forwardRef(
      ({ className: g, variant: I, size: e, asChild: C = !1, ...l }, t) => {
        const n = C ? ZC : "button";
        return s.jsx(n, {
          className: O(gV({ variant: I, size: e, className: g })),
          ref: t,
          ...l,
        });
      }
    );
  fg.displayName = "Button";
  function IV(g, I = []) {
    let e = [];
    function C(t, n) {
      const o = a.createContext(n),
        A = e.length;
      e = [...e, n];
      function c(i) {
        const { scope: r, children: u, ...b } = i,
          m = (r == null ? void 0 : r[g][A]) || o,
          p = a.useMemo(() => b, Object.values(b));
        return s.jsx(m.Provider, { value: p, children: u });
      }
      function d(i, r) {
        const u = (r == null ? void 0 : r[g][A]) || o,
          b = a.useContext(u);
        if (b) return b;
        if (n !== void 0) return n;
        throw new Error(`\`${i}\` must be used within \`${t}\``);
      }
      return (c.displayName = t + "Provider"), [c, d];
    }
    const l = () => {
      const t = e.map((n) => a.createContext(n));
      return function (o) {
        const A = (o == null ? void 0 : o[g]) || t;
        return a.useMemo(() => ({ [`__scope${g}`]: { ...o, [g]: A } }), [o, A]);
      };
    };
    return (l.scopeName = g), [C, eV(l, ...I)];
  }
  function eV(...g) {
    const I = g[0];
    if (g.length === 1) return I;
    const e = () => {
      const C = g.map((l) => ({ useScope: l(), scopeName: l.scopeName }));
      return function (t) {
        const n = C.reduce((o, { useScope: A, scopeName: c }) => {
          const i = A(t)[`__scope${c}`];
          return { ...o, ...i };
        }, {});
        return a.useMemo(() => ({ [`__scope${I.scopeName}`]: n }), [n]);
      };
    };
    return (e.scopeName = I.scopeName), e;
  }
  function Qi(g) {
    const I = g + "CollectionProvider",
      [e, C] = IV(I),
      [l, t] = e(I, { collectionRef: { current: null }, itemMap: new Map() }),
      n = (u) => {
        const { scope: b, children: m } = u,
          p = ee.useRef(null),
          G = ee.useRef(new Map()).current;
        return s.jsx(l, {
          scope: b,
          itemMap: G,
          collectionRef: p,
          children: m,
        });
      };
    n.displayName = I;
    const o = g + "CollectionSlot",
      A = ee.forwardRef((u, b) => {
        const { scope: m, children: p } = u,
          G = t(o, m),
          Z = Gg(b, G.collectionRef);
        return s.jsx(ZC, { ref: Z, children: p });
      });
    A.displayName = o;
    const c = g + "CollectionItemSlot",
      d = "data-radix-collection-item",
      i = ee.forwardRef((u, b) => {
        const { scope: m, children: p, ...G } = u,
          Z = ee.useRef(null),
          B = Gg(b, Z),
          y = t(c, m);
        return (
          ee.useEffect(
            () => (
              y.itemMap.set(Z, { ref: Z, ...G }), () => void y.itemMap.delete(Z)
            )
          ),
          s.jsx(ZC, { [d]: "", ref: B, children: p })
        );
      });
    i.displayName = c;
    function r(u) {
      const b = t(g + "CollectionConsumer", u);
      return ee.useCallback(() => {
        const p = b.collectionRef.current;
        if (!p) return [];
        const G = Array.from(p.querySelectorAll(`[${d}]`));
        return Array.from(b.itemMap.values()).sort(
          (y, h) => G.indexOf(y.ref.current) - G.indexOf(h.ref.current)
        );
      }, [b.collectionRef, b.itemMap]);
    }
    return [{ Provider: n, Slot: A, ItemSlot: i }, r, C];
  }
  var CV = a.createContext(void 0);
  function Li(g) {
    const I = a.useContext(CV);
    return g || I || "ltr";
  }
  function lV(g, I = globalThis == null ? void 0 : globalThis.document) {
    const e = tI(g);
    a.useEffect(() => {
      const C = (l) => {
        l.key === "Escape" && e(l);
      };
      return (
        I.addEventListener("keydown", C, { capture: !0 }),
        () => I.removeEventListener("keydown", C, { capture: !0 })
      );
    }, [e, I]);
  }
  var tV = "DismissableLayer",
    Bd = "dismissableLayer.update",
    nV = "dismissableLayer.pointerDownOutside",
    oV = "dismissableLayer.focusOutside",
    qr,
    yZ = a.createContext({
      layers: new Set(),
      layersWithOutsidePointerEventsDisabled: new Set(),
      branches: new Set(),
    }),
    Di = a.forwardRef((g, I) => {
      const {
          disableOutsidePointerEvents: e = !1,
          onEscapeKeyDown: C,
          onPointerDownOutside: l,
          onFocusOutside: t,
          onInteractOutside: n,
          onDismiss: o,
          ...A
        } = g,
        c = a.useContext(yZ),
        [d, i] = a.useState(null),
        r =
          (d == null ? void 0 : d.ownerDocument) ??
          (globalThis == null ? void 0 : globalThis.document),
        [, u] = a.useState({}),
        b = Gg(I, (S) => i(S)),
        m = Array.from(c.layers),
        [p] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
        G = m.indexOf(p),
        Z = d ? m.indexOf(d) : -1,
        B = c.layersWithOutsidePointerEventsDisabled.size > 0,
        y = Z >= G,
        h = dV((S) => {
          const V = S.target,
            f = [...c.branches].some((k) => k.contains(V));
          !y ||
            f ||
            (l == null || l(S),
            n == null || n(S),
            S.defaultPrevented || o == null || o());
        }, r),
        W = iV((S) => {
          const V = S.target;
          [...c.branches].some((k) => k.contains(V)) ||
            (t == null || t(S),
            n == null || n(S),
            S.defaultPrevented || o == null || o());
        }, r);
      return (
        lV((S) => {
          Z === c.layers.size - 1 &&
            (C == null || C(S),
            !S.defaultPrevented && o && (S.preventDefault(), o()));
        }, r),
        a.useEffect(() => {
          if (d)
            return (
              e &&
                (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                  ((qr = r.body.style.pointerEvents),
                  (r.body.style.pointerEvents = "none")),
                c.layersWithOutsidePointerEventsDisabled.add(d)),
              c.layers.add(d),
              $r(),
              () => {
                e &&
                  c.layersWithOutsidePointerEventsDisabled.size === 1 &&
                  (r.body.style.pointerEvents = qr);
              }
            );
        }, [d, r, e, c]),
        a.useEffect(
          () => () => {
            d &&
              (c.layers.delete(d),
              c.layersWithOutsidePointerEventsDisabled.delete(d),
              $r());
          },
          [d, c]
        ),
        a.useEffect(() => {
          const S = () => u({});
          return (
            document.addEventListener(Bd, S),
            () => document.removeEventListener(Bd, S)
          );
        }, []),
        s.jsx(tg.div, {
          ...A,
          ref: b,
          style: {
            pointerEvents: B ? (y ? "auto" : "none") : void 0,
            ...g.style,
          },
          onFocusCapture: E(g.onFocusCapture, W.onFocusCapture),
          onBlurCapture: E(g.onBlurCapture, W.onBlurCapture),
          onPointerDownCapture: E(
            g.onPointerDownCapture,
            h.onPointerDownCapture
          ),
        })
      );
    });
  Di.displayName = tV;
  var AV = "DismissableLayerBranch",
    cV = a.forwardRef((g, I) => {
      const e = a.useContext(yZ),
        C = a.useRef(null),
        l = Gg(I, C);
      return (
        a.useEffect(() => {
          const t = C.current;
          if (t)
            return (
              e.branches.add(t),
              () => {
                e.branches.delete(t);
              }
            );
        }, [e.branches]),
        s.jsx(tg.div, { ...g, ref: l })
      );
    });
  cV.displayName = AV;
  function dV(g, I = globalThis == null ? void 0 : globalThis.document) {
    const e = tI(g),
      C = a.useRef(!1),
      l = a.useRef(() => {});
    return (
      a.useEffect(() => {
        const t = (o) => {
            if (o.target && !C.current) {
              let A = function () {
                hZ(nV, e, c, { discrete: !0 });
              };
              const c = { originalEvent: o };
              o.pointerType === "touch"
                ? (I.removeEventListener("click", l.current),
                  (l.current = A),
                  I.addEventListener("click", l.current, { once: !0 }))
                : A();
            } else I.removeEventListener("click", l.current);
            C.current = !1;
          },
          n = window.setTimeout(() => {
            I.addEventListener("pointerdown", t);
          }, 0);
        return () => {
          window.clearTimeout(n),
            I.removeEventListener("pointerdown", t),
            I.removeEventListener("click", l.current);
        };
      }, [I, e]),
      { onPointerDownCapture: () => (C.current = !0) }
    );
  }
  function iV(g, I = globalThis == null ? void 0 : globalThis.document) {
    const e = tI(g),
      C = a.useRef(!1);
    return (
      a.useEffect(() => {
        const l = (t) => {
          t.target &&
            !C.current &&
            hZ(oV, e, { originalEvent: t }, { discrete: !1 });
        };
        return (
          I.addEventListener("focusin", l),
          () => I.removeEventListener("focusin", l)
        );
      }, [I, e]),
      {
        onFocusCapture: () => (C.current = !0),
        onBlurCapture: () => (C.current = !1),
      }
    );
  }
  function $r() {
    const g = new CustomEvent(Bd);
    document.dispatchEvent(g);
  }
  function hZ(g, I, e, { discrete: C }) {
    const l = e.originalEvent.target,
      t = new CustomEvent(g, { bubbles: !1, cancelable: !0, detail: e });
    I && l.addEventListener(g, I, { once: !0 }),
      C ? aZ(l, t) : l.dispatchEvent(t);
  }
  var Ic = 0;
  function SZ() {
    a.useEffect(() => {
      const g = document.querySelectorAll("[data-radix-focus-guard]");
      return (
        document.body.insertAdjacentElement("afterbegin", g[0] ?? gs()),
        document.body.insertAdjacentElement("beforeend", g[1] ?? gs()),
        Ic++,
        () => {
          Ic === 1 &&
            document
              .querySelectorAll("[data-radix-focus-guard]")
              .forEach((I) => I.remove()),
            Ic--;
        }
      );
    }, []);
  }
  function gs() {
    const g = document.createElement("span");
    return (
      g.setAttribute("data-radix-focus-guard", ""),
      (g.tabIndex = 0),
      (g.style.outline = "none"),
      (g.style.opacity = "0"),
      (g.style.position = "fixed"),
      (g.style.pointerEvents = "none"),
      g
    );
  }
  var ec = "focusScope.autoFocusOnMount",
    Cc = "focusScope.autoFocusOnUnmount",
    Is = { bubbles: !1, cancelable: !0 },
    aV = "FocusScope",
    Ti = a.forwardRef((g, I) => {
      const {
          loop: e = !1,
          trapped: C = !1,
          onMountAutoFocus: l,
          onUnmountAutoFocus: t,
          ...n
        } = g,
        [o, A] = a.useState(null),
        c = tI(l),
        d = tI(t),
        i = a.useRef(null),
        r = Gg(I, (m) => A(m)),
        u = a.useRef({
          paused: !1,
          pause() {
            this.paused = !0;
          },
          resume() {
            this.paused = !1;
          },
        }).current;
      a.useEffect(() => {
        if (C) {
          let m = function (B) {
              if (u.paused || !o) return;
              const y = B.target;
              o.contains(y) ? (i.current = y) : Be(i.current, { select: !0 });
            },
            p = function (B) {
              if (u.paused || !o) return;
              const y = B.relatedTarget;
              y !== null && (o.contains(y) || Be(i.current, { select: !0 }));
            },
            G = function (B) {
              if (document.activeElement === document.body)
                for (const h of B) h.removedNodes.length > 0 && Be(o);
            };
          document.addEventListener("focusin", m),
            document.addEventListener("focusout", p);
          const Z = new MutationObserver(G);
          return (
            o && Z.observe(o, { childList: !0, subtree: !0 }),
            () => {
              document.removeEventListener("focusin", m),
                document.removeEventListener("focusout", p),
                Z.disconnect();
            }
          );
        }
      }, [C, o, u.paused]),
        a.useEffect(() => {
          if (o) {
            Cs.add(u);
            const m = document.activeElement;
            if (!o.contains(m)) {
              const G = new CustomEvent(ec, Is);
              o.addEventListener(ec, c),
                o.dispatchEvent(G),
                G.defaultPrevented ||
                  (rV(GV(VZ(o)), { select: !0 }),
                  document.activeElement === m && Be(o));
            }
            return () => {
              o.removeEventListener(ec, c),
                setTimeout(() => {
                  const G = new CustomEvent(Cc, Is);
                  o.addEventListener(Cc, d),
                    o.dispatchEvent(G),
                    G.defaultPrevented ||
                      Be(m ?? document.body, { select: !0 }),
                    o.removeEventListener(Cc, d),
                    Cs.remove(u);
                }, 0);
            };
          }
        }, [o, c, d, u]);
      const b = a.useCallback(
        (m) => {
          if ((!e && !C) || u.paused) return;
          const p = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey,
            G = document.activeElement;
          if (p && G) {
            const Z = m.currentTarget,
              [B, y] = sV(Z);
            B && y
              ? !m.shiftKey && G === y
                ? (m.preventDefault(), e && Be(B, { select: !0 }))
                : m.shiftKey &&
                  G === B &&
                  (m.preventDefault(), e && Be(y, { select: !0 }))
              : G === Z && m.preventDefault();
          }
        },
        [e, C, u.paused]
      );
      return s.jsx(tg.div, { tabIndex: -1, ...n, ref: r, onKeyDown: b });
    });
  Ti.displayName = aV;
  function rV(g, { select: I = !1 } = {}) {
    const e = document.activeElement;
    for (const C of g)
      if ((Be(C, { select: I }), document.activeElement !== e)) return;
  }
  function sV(g) {
    const I = VZ(g),
      e = es(I, g),
      C = es(I.reverse(), g);
    return [e, C];
  }
  function VZ(g) {
    const I = [],
      e = document.createTreeWalker(g, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (C) => {
          const l = C.tagName === "INPUT" && C.type === "hidden";
          return C.disabled || C.hidden || l
            ? NodeFilter.FILTER_SKIP
            : C.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP;
        },
      });
    for (; e.nextNode(); ) I.push(e.currentNode);
    return I;
  }
  function es(g, I) {
    for (const e of g) if (!uV(e, { upTo: I })) return e;
  }
  function uV(g, { upTo: I }) {
    if (getComputedStyle(g).visibility === "hidden") return !0;
    for (; g; ) {
      if (I !== void 0 && g === I) return !1;
      if (getComputedStyle(g).display === "none") return !0;
      g = g.parentElement;
    }
    return !1;
  }
  function mV(g) {
    return g instanceof HTMLInputElement && "select" in g;
  }
  function Be(g, { select: I = !1 } = {}) {
    if (g && g.focus) {
      const e = document.activeElement;
      g.focus({ preventScroll: !0 }), g !== e && mV(g) && I && g.select();
    }
  }
  var Cs = ZV();
  function ZV() {
    let g = [];
    return {
      add(I) {
        const e = g[0];
        I !== e && (e == null || e.pause()), (g = ls(g, I)), g.unshift(I);
      },
      remove(I) {
        var e;
        (g = ls(g, I)), (e = g[0]) == null || e.resume();
      },
    };
  }
  function ls(g, I) {
    const e = [...g],
      C = e.indexOf(I);
    return C !== -1 && e.splice(C, 1), e;
  }
  function GV(g) {
    return g.filter((I) => I.tagName !== "A");
  }
  var bV = zs.useId || (() => {}),
    BV = 0;
  function Ee(g) {
    const [I, e] = a.useState(bV());
    return (
      xg(() => {
        e((C) => C ?? String(BV++));
      }, [g]),
      I ? `radix-${I}` : ""
    );
  }
  const pV = ["top", "right", "bottom", "left"],
    Ue = Math.min,
    cI = Math.max,
    So = Math.round,
    Sn = Math.floor,
    Qe = (g) => ({ x: g, y: g }),
    yV = { left: "right", right: "left", bottom: "top", top: "bottom" },
    hV = { start: "end", end: "start" };
  function pd(g, I, e) {
    return cI(g, Ue(I, e));
  }
  function re(g, I) {
    return typeof g == "function" ? g(I) : g;
  }
  function se(g) {
    return g.split("-")[0];
  }
  function Sl(g) {
    return g.split("-")[1];
  }
  function ji(g) {
    return g === "x" ? "y" : "x";
  }
  function Pi(g) {
    return g === "y" ? "height" : "width";
  }
  function Le(g) {
    return ["top", "bottom"].includes(se(g)) ? "y" : "x";
  }
  function Oi(g) {
    return ji(Le(g));
  }
  function SV(g, I, e) {
    e === void 0 && (e = !1);
    const C = Sl(g),
      l = Oi(g),
      t = Pi(l);
    let n =
      l === "x"
        ? C === (e ? "end" : "start")
          ? "right"
          : "left"
        : C === "start"
        ? "bottom"
        : "top";
    return I.reference[t] > I.floating[t] && (n = Vo(n)), [n, Vo(n)];
  }
  function VV(g) {
    const I = Vo(g);
    return [yd(g), I, yd(I)];
  }
  function yd(g) {
    return g.replace(/start|end/g, (I) => hV[I]);
  }
  function WV(g, I, e) {
    const C = ["left", "right"],
      l = ["right", "left"],
      t = ["top", "bottom"],
      n = ["bottom", "top"];
    switch (g) {
      case "top":
      case "bottom":
        return e ? (I ? l : C) : I ? C : l;
      case "left":
      case "right":
        return I ? t : n;
      default:
        return [];
    }
  }
  function RV(g, I, e, C) {
    const l = Sl(g);
    let t = WV(se(g), e === "start", C);
    return (
      l && ((t = t.map((n) => n + "-" + l)), I && (t = t.concat(t.map(yd)))), t
    );
  }
  function Vo(g) {
    return g.replace(/left|right|bottom|top/g, (I) => yV[I]);
  }
  function XV(g) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...g };
  }
  function WZ(g) {
    return typeof g != "number"
      ? XV(g)
      : { top: g, right: g, bottom: g, left: g };
  }
  function Wo(g) {
    const { x: I, y: e, width: C, height: l } = g;
    return {
      width: C,
      height: l,
      top: e,
      left: I,
      right: I + C,
      bottom: e + l,
      x: I,
      y: e,
    };
  }
  function ts(g, I, e) {
    let { reference: C, floating: l } = g;
    const t = Le(I),
      n = Oi(I),
      o = Pi(n),
      A = se(I),
      c = t === "y",
      d = C.x + C.width / 2 - l.width / 2,
      i = C.y + C.height / 2 - l.height / 2,
      r = C[o] / 2 - l[o] / 2;
    let u;
    switch (A) {
      case "top":
        u = { x: d, y: C.y - l.height };
        break;
      case "bottom":
        u = { x: d, y: C.y + C.height };
        break;
      case "right":
        u = { x: C.x + C.width, y: i };
        break;
      case "left":
        u = { x: C.x - l.width, y: i };
        break;
      default:
        u = { x: C.x, y: C.y };
    }
    switch (Sl(I)) {
      case "start":
        u[n] -= r * (e && c ? -1 : 1);
        break;
      case "end":
        u[n] += r * (e && c ? -1 : 1);
        break;
    }
    return u;
  }
  const JV = async (g, I, e) => {
    const {
        placement: C = "bottom",
        strategy: l = "absolute",
        middleware: t = [],
        platform: n,
      } = e,
      o = t.filter(Boolean),
      A = await (n.isRTL == null ? void 0 : n.isRTL(I));
    let c = await n.getElementRects({ reference: g, floating: I, strategy: l }),
      { x: d, y: i } = ts(c, C, A),
      r = C,
      u = {},
      b = 0;
    for (let m = 0; m < o.length; m++) {
      const { name: p, fn: G } = o[m],
        {
          x: Z,
          y: B,
          data: y,
          reset: h,
        } = await G({
          x: d,
          y: i,
          initialPlacement: C,
          placement: r,
          strategy: l,
          middlewareData: u,
          rects: c,
          platform: n,
          elements: { reference: g, floating: I },
        });
      (d = Z ?? d),
        (i = B ?? i),
        (u = { ...u, [p]: { ...u[p], ...y } }),
        h &&
          b <= 50 &&
          (b++,
          typeof h == "object" &&
            (h.placement && (r = h.placement),
            h.rects &&
              (c =
                h.rects === !0
                  ? await n.getElementRects({
                      reference: g,
                      floating: I,
                      strategy: l,
                    })
                  : h.rects),
            ({ x: d, y: i } = ts(c, r, A))),
          (m = -1));
    }
    return { x: d, y: i, placement: r, strategy: l, middlewareData: u };
  };
  async function St(g, I) {
    var e;
    I === void 0 && (I = {});
    const { x: C, y: l, platform: t, rects: n, elements: o, strategy: A } = g,
      {
        boundary: c = "clippingAncestors",
        rootBoundary: d = "viewport",
        elementContext: i = "floating",
        altBoundary: r = !1,
        padding: u = 0,
      } = re(I, g),
      b = WZ(u),
      p = o[r ? (i === "floating" ? "reference" : "floating") : i],
      G = Wo(
        await t.getClippingRect({
          element:
            (e = await (t.isElement == null ? void 0 : t.isElement(p))) ==
              null || e
              ? p
              : p.contextElement ||
                (await (t.getDocumentElement == null
                  ? void 0
                  : t.getDocumentElement(o.floating))),
          boundary: c,
          rootBoundary: d,
          strategy: A,
        })
      ),
      Z =
        i === "floating"
          ? { x: C, y: l, width: n.floating.width, height: n.floating.height }
          : n.reference,
      B = await (t.getOffsetParent == null
        ? void 0
        : t.getOffsetParent(o.floating)),
      y = (await (t.isElement == null ? void 0 : t.isElement(B)))
        ? (await (t.getScale == null ? void 0 : t.getScale(B))) || {
            x: 1,
            y: 1,
          }
        : { x: 1, y: 1 },
      h = Wo(
        t.convertOffsetParentRelativeRectToViewportRelativeRect
          ? await t.convertOffsetParentRelativeRectToViewportRelativeRect({
              elements: o,
              rect: Z,
              offsetParent: B,
              strategy: A,
            })
          : Z
      );
    return {
      top: (G.top - h.top + b.top) / y.y,
      bottom: (h.bottom - G.bottom + b.bottom) / y.y,
      left: (G.left - h.left + b.left) / y.x,
      right: (h.right - G.right + b.right) / y.x,
    };
  }
  const vV = (g) => ({
      name: "arrow",
      options: g,
      async fn(I) {
        const {
            x: e,
            y: C,
            placement: l,
            rects: t,
            platform: n,
            elements: o,
            middlewareData: A,
          } = I,
          { element: c, padding: d = 0 } = re(g, I) || {};
        if (c == null) return {};
        const i = WZ(d),
          r = { x: e, y: C },
          u = Oi(l),
          b = Pi(u),
          m = await n.getDimensions(c),
          p = u === "y",
          G = p ? "top" : "left",
          Z = p ? "bottom" : "right",
          B = p ? "clientHeight" : "clientWidth",
          y = t.reference[b] + t.reference[u] - r[u] - t.floating[b],
          h = r[u] - t.reference[u],
          W = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(c));
        let S = W ? W[B] : 0;
        (!S || !(await (n.isElement == null ? void 0 : n.isElement(W)))) &&
          (S = o.floating[B] || t.floating[b]);
        const V = y / 2 - h / 2,
          f = S / 2 - m[b] / 2 - 1,
          k = Ue(i[G], f),
          F = Ue(i[Z], f),
          K = k,
          P = S - m[b] - F,
          T = S / 2 - m[b] / 2 + V,
          ng = pd(K, T, P),
          z =
            !A.arrow &&
            Sl(l) != null &&
            T !== ng &&
            t.reference[b] / 2 - (T < K ? k : F) - m[b] / 2 < 0,
          gg = z ? (T < K ? T - K : T - P) : 0;
        return {
          [u]: r[u] + gg,
          data: {
            [u]: ng,
            centerOffset: T - ng - gg,
            ...(z && { alignmentOffset: gg }),
          },
          reset: z,
        };
      },
    }),
    kV = function (g) {
      return (
        g === void 0 && (g = {}),
        {
          name: "flip",
          options: g,
          async fn(I) {
            var e, C;
            const {
                placement: l,
                middlewareData: t,
                rects: n,
                initialPlacement: o,
                platform: A,
                elements: c,
              } = I,
              {
                mainAxis: d = !0,
                crossAxis: i = !0,
                fallbackPlacements: r,
                fallbackStrategy: u = "bestFit",
                fallbackAxisSideDirection: b = "none",
                flipAlignment: m = !0,
                ...p
              } = re(g, I);
            if ((e = t.arrow) != null && e.alignmentOffset) return {};
            const G = se(l),
              Z = Le(o),
              B = se(o) === o,
              y = await (A.isRTL == null ? void 0 : A.isRTL(c.floating)),
              h = r || (B || !m ? [Vo(o)] : VV(o)),
              W = b !== "none";
            !r && W && h.push(...RV(o, m, b, y));
            const S = [o, ...h],
              V = await St(I, p),
              f = [];
            let k = ((C = t.flip) == null ? void 0 : C.overflows) || [];
            if ((d && f.push(V[G]), i)) {
              const T = SV(l, n, y);
              f.push(V[T[0]], V[T[1]]);
            }
            if (
              ((k = [...k, { placement: l, overflows: f }]),
              !f.every((T) => T <= 0))
            ) {
              var F, K;
              const T = (((F = t.flip) == null ? void 0 : F.index) || 0) + 1,
                ng = S[T];
              if (ng)
                return {
                  data: { index: T, overflows: k },
                  reset: { placement: ng },
                };
              let z =
                (K = k
                  .filter((gg) => gg.overflows[0] <= 0)
                  .sort((gg, R) => gg.overflows[1] - R.overflows[1])[0]) == null
                  ? void 0
                  : K.placement;
              if (!z)
                switch (u) {
                  case "bestFit": {
                    var P;
                    const gg =
                      (P = k
                        .filter((R) => {
                          if (W) {
                            const X = Le(R.placement);
                            return X === Z || X === "y";
                          }
                          return !0;
                        })
                        .map((R) => [
                          R.placement,
                          R.overflows
                            .filter((X) => X > 0)
                            .reduce((X, H) => X + H, 0),
                        ])
                        .sort((R, X) => R[1] - X[1])[0]) == null
                        ? void 0
                        : P[0];
                    gg && (z = gg);
                    break;
                  }
                  case "initialPlacement":
                    z = o;
                    break;
                }
              if (l !== z) return { reset: { placement: z } };
            }
            return {};
          },
        }
      );
    };
  function ns(g, I) {
    return {
      top: g.top - I.height,
      right: g.right - I.width,
      bottom: g.bottom - I.height,
      left: g.left - I.width,
    };
  }
  function os(g) {
    return pV.some((I) => g[I] >= 0);
  }
  const fV = function (g) {
    return (
      g === void 0 && (g = {}),
      {
        name: "hide",
        options: g,
        async fn(I) {
          const { rects: e } = I,
            { strategy: C = "referenceHidden", ...l } = re(g, I);
          switch (C) {
            case "referenceHidden": {
              const t = await St(I, { ...l, elementContext: "reference" }),
                n = ns(t, e.reference);
              return {
                data: { referenceHiddenOffsets: n, referenceHidden: os(n) },
              };
            }
            case "escaped": {
              const t = await St(I, { ...l, altBoundary: !0 }),
                n = ns(t, e.floating);
              return { data: { escapedOffsets: n, escaped: os(n) } };
            }
            default:
              return {};
          }
        },
      }
    );
  };
  async function YV(g, I) {
    const { placement: e, platform: C, elements: l } = g,
      t = await (C.isRTL == null ? void 0 : C.isRTL(l.floating)),
      n = se(e),
      o = Sl(e),
      A = Le(e) === "y",
      c = ["left", "top"].includes(n) ? -1 : 1,
      d = t && A ? -1 : 1,
      i = re(I, g);
    let {
      mainAxis: r,
      crossAxis: u,
      alignmentAxis: b,
    } = typeof i == "number"
      ? { mainAxis: i, crossAxis: 0, alignmentAxis: null }
      : {
          mainAxis: i.mainAxis || 0,
          crossAxis: i.crossAxis || 0,
          alignmentAxis: i.alignmentAxis,
        };
    return (
      o && typeof b == "number" && (u = o === "end" ? b * -1 : b),
      A ? { x: u * d, y: r * c } : { x: r * c, y: u * d }
    );
  }
  const HV = function (g) {
      return (
        g === void 0 && (g = 0),
        {
          name: "offset",
          options: g,
          async fn(I) {
            var e, C;
            const { x: l, y: t, placement: n, middlewareData: o } = I,
              A = await YV(I, g);
            return n === ((e = o.offset) == null ? void 0 : e.placement) &&
              (C = o.arrow) != null &&
              C.alignmentOffset
              ? {}
              : { x: l + A.x, y: t + A.y, data: { ...A, placement: n } };
          },
        }
      );
    },
    wV = function (g) {
      return (
        g === void 0 && (g = {}),
        {
          name: "shift",
          options: g,
          async fn(I) {
            const { x: e, y: C, placement: l } = I,
              {
                mainAxis: t = !0,
                crossAxis: n = !1,
                limiter: o = {
                  fn: (p) => {
                    let { x: G, y: Z } = p;
                    return { x: G, y: Z };
                  },
                },
                ...A
              } = re(g, I),
              c = { x: e, y: C },
              d = await St(I, A),
              i = Le(se(l)),
              r = ji(i);
            let u = c[r],
              b = c[i];
            if (t) {
              const p = r === "y" ? "top" : "left",
                G = r === "y" ? "bottom" : "right",
                Z = u + d[p],
                B = u - d[G];
              u = pd(Z, u, B);
            }
            if (n) {
              const p = i === "y" ? "top" : "left",
                G = i === "y" ? "bottom" : "right",
                Z = b + d[p],
                B = b - d[G];
              b = pd(Z, b, B);
            }
            const m = o.fn({ ...I, [r]: u, [i]: b });
            return {
              ...m,
              data: { x: m.x - e, y: m.y - C, enabled: { [r]: t, [i]: n } },
            };
          },
        }
      );
    },
    NV = function (g) {
      return (
        g === void 0 && (g = {}),
        {
          options: g,
          fn(I) {
            const { x: e, y: C, placement: l, rects: t, middlewareData: n } = I,
              { offset: o = 0, mainAxis: A = !0, crossAxis: c = !0 } = re(g, I),
              d = { x: e, y: C },
              i = Le(l),
              r = ji(i);
            let u = d[r],
              b = d[i];
            const m = re(o, I),
              p =
                typeof m == "number"
                  ? { mainAxis: m, crossAxis: 0 }
                  : { mainAxis: 0, crossAxis: 0, ...m };
            if (A) {
              const B = r === "y" ? "height" : "width",
                y = t.reference[r] - t.floating[B] + p.mainAxis,
                h = t.reference[r] + t.reference[B] - p.mainAxis;
              u < y ? (u = y) : u > h && (u = h);
            }
            if (c) {
              var G, Z;
              const B = r === "y" ? "width" : "height",
                y = ["top", "left"].includes(se(l)),
                h =
                  t.reference[i] -
                  t.floating[B] +
                  ((y && ((G = n.offset) == null ? void 0 : G[i])) || 0) +
                  (y ? 0 : p.crossAxis),
                W =
                  t.reference[i] +
                  t.reference[B] +
                  (y ? 0 : ((Z = n.offset) == null ? void 0 : Z[i]) || 0) -
                  (y ? p.crossAxis : 0);
              b < h ? (b = h) : b > W && (b = W);
            }
            return { [r]: u, [i]: b };
          },
        }
      );
    },
    KV = function (g) {
      return (
        g === void 0 && (g = {}),
        {
          name: "size",
          options: g,
          async fn(I) {
            var e, C;
            const { placement: l, rects: t, platform: n, elements: o } = I,
              { apply: A = () => {}, ...c } = re(g, I),
              d = await St(I, c),
              i = se(l),
              r = Sl(l),
              u = Le(l) === "y",
              { width: b, height: m } = t.floating;
            let p, G;
            i === "top" || i === "bottom"
              ? ((p = i),
                (G =
                  r ===
                  ((await (n.isRTL == null ? void 0 : n.isRTL(o.floating)))
                    ? "start"
                    : "end")
                    ? "left"
                    : "right"))
              : ((G = i), (p = r === "end" ? "top" : "bottom"));
            const Z = m - d.top - d.bottom,
              B = b - d.left - d.right,
              y = Ue(m - d[p], Z),
              h = Ue(b - d[G], B),
              W = !I.middlewareData.shift;
            let S = y,
              V = h;
            if (
              ((e = I.middlewareData.shift) != null && e.enabled.x && (V = B),
              (C = I.middlewareData.shift) != null && C.enabled.y && (S = Z),
              W && !r)
            ) {
              const k = cI(d.left, 0),
                F = cI(d.right, 0),
                K = cI(d.top, 0),
                P = cI(d.bottom, 0);
              u
                ? (V =
                    b - 2 * (k !== 0 || F !== 0 ? k + F : cI(d.left, d.right)))
                : (S =
                    m - 2 * (K !== 0 || P !== 0 ? K + P : cI(d.top, d.bottom)));
            }
            await A({ ...I, availableWidth: V, availableHeight: S });
            const f = await n.getDimensions(o.floating);
            return b !== f.width || m !== f.height
              ? { reset: { rects: !0 } }
              : {};
          },
        }
      );
    };
  function lA() {
    return typeof window < "u";
  }
  function Vl(g) {
    return RZ(g) ? (g.nodeName || "").toLowerCase() : "#document";
  }
  function rI(g) {
    var I;
    return (
      (g == null || (I = g.ownerDocument) == null ? void 0 : I.defaultView) ||
      window
    );
  }
  function $I(g) {
    var I;
    return (I = (RZ(g) ? g.ownerDocument : g.document) || window.document) ==
      null
      ? void 0
      : I.documentElement;
  }
  function RZ(g) {
    return lA() ? g instanceof Node || g instanceof rI(g).Node : !1;
  }
  function xI(g) {
    return lA() ? g instanceof Element || g instanceof rI(g).Element : !1;
  }
  function OI(g) {
    return lA()
      ? g instanceof HTMLElement || g instanceof rI(g).HTMLElement
      : !1;
  }
  function As(g) {
    return !lA() || typeof ShadowRoot > "u"
      ? !1
      : g instanceof ShadowRoot || g instanceof rI(g).ShadowRoot;
  }
  function _t(g) {
    const { overflow: I, overflowX: e, overflowY: C, display: l } = MI(g);
    return (
      /auto|scroll|overlay|hidden|clip/.test(I + C + e) &&
      !["inline", "contents"].includes(l)
    );
  }
  function FV(g) {
    return ["table", "td", "th"].includes(Vl(g));
  }
  function tA(g) {
    return [":popover-open", ":modal"].some((I) => {
      try {
        return g.matches(I);
      } catch {
        return !1;
      }
    });
  }
  function _i(g) {
    const I = qi(),
      e = xI(g) ? MI(g) : g;
    return (
      e.transform !== "none" ||
      e.perspective !== "none" ||
      (e.containerType ? e.containerType !== "normal" : !1) ||
      (!I && (e.backdropFilter ? e.backdropFilter !== "none" : !1)) ||
      (!I && (e.filter ? e.filter !== "none" : !1)) ||
      ["transform", "perspective", "filter"].some((C) =>
        (e.willChange || "").includes(C)
      ) ||
      ["paint", "layout", "strict", "content"].some((C) =>
        (e.contain || "").includes(C)
      )
    );
  }
  function xV(g) {
    let I = De(g);
    for (; OI(I) && !sl(I); ) {
      if (_i(I)) return I;
      if (tA(I)) return null;
      I = De(I);
    }
    return null;
  }
  function qi() {
    return typeof CSS > "u" || !CSS.supports
      ? !1
      : CSS.supports("-webkit-backdrop-filter", "none");
  }
  function sl(g) {
    return ["html", "body", "#document"].includes(Vl(g));
  }
  function MI(g) {
    return rI(g).getComputedStyle(g);
  }
  function nA(g) {
    return xI(g)
      ? { scrollLeft: g.scrollLeft, scrollTop: g.scrollTop }
      : { scrollLeft: g.scrollX, scrollTop: g.scrollY };
  }
  function De(g) {
    if (Vl(g) === "html") return g;
    const I = g.assignedSlot || g.parentNode || (As(g) && g.host) || $I(g);
    return As(I) ? I.host : I;
  }
  function XZ(g) {
    const I = De(g);
    return sl(I)
      ? g.ownerDocument
        ? g.ownerDocument.body
        : g.body
      : OI(I) && _t(I)
      ? I
      : XZ(I);
  }
  function Vt(g, I, e) {
    var C;
    I === void 0 && (I = []), e === void 0 && (e = !0);
    const l = XZ(g),
      t = l === ((C = g.ownerDocument) == null ? void 0 : C.body),
      n = rI(l);
    if (t) {
      const o = hd(n);
      return I.concat(
        n,
        n.visualViewport || [],
        _t(l) ? l : [],
        o && e ? Vt(o) : []
      );
    }
    return I.concat(l, Vt(l, [], e));
  }
  function hd(g) {
    return g.parent && Object.getPrototypeOf(g.parent) ? g.frameElement : null;
  }
  function JZ(g) {
    const I = MI(g);
    let e = parseFloat(I.width) || 0,
      C = parseFloat(I.height) || 0;
    const l = OI(g),
      t = l ? g.offsetWidth : e,
      n = l ? g.offsetHeight : C,
      o = So(e) !== t || So(C) !== n;
    return o && ((e = t), (C = n)), { width: e, height: C, $: o };
  }
  function $i(g) {
    return xI(g) ? g : g.contextElement;
  }
  function Cl(g) {
    const I = $i(g);
    if (!OI(I)) return Qe(1);
    const e = I.getBoundingClientRect(),
      { width: C, height: l, $: t } = JZ(I);
    let n = (t ? So(e.width) : e.width) / C,
      o = (t ? So(e.height) : e.height) / l;
    return (
      (!n || !Number.isFinite(n)) && (n = 1),
      (!o || !Number.isFinite(o)) && (o = 1),
      { x: n, y: o }
    );
  }
  const MV = Qe(0);
  function vZ(g) {
    const I = rI(g);
    return !qi() || !I.visualViewport
      ? MV
      : { x: I.visualViewport.offsetLeft, y: I.visualViewport.offsetTop };
  }
  function zV(g, I, e) {
    return I === void 0 && (I = !1), !e || (I && e !== rI(g)) ? !1 : I;
  }
  function GC(g, I, e, C) {
    I === void 0 && (I = !1), e === void 0 && (e = !1);
    const l = g.getBoundingClientRect(),
      t = $i(g);
    let n = Qe(1);
    I && (C ? xI(C) && (n = Cl(C)) : (n = Cl(g)));
    const o = zV(t, e, C) ? vZ(t) : Qe(0);
    let A = (l.left + o.x) / n.x,
      c = (l.top + o.y) / n.y,
      d = l.width / n.x,
      i = l.height / n.y;
    if (t) {
      const r = rI(t),
        u = C && xI(C) ? rI(C) : C;
      let b = r,
        m = hd(b);
      for (; m && C && u !== b; ) {
        const p = Cl(m),
          G = m.getBoundingClientRect(),
          Z = MI(m),
          B = G.left + (m.clientLeft + parseFloat(Z.paddingLeft)) * p.x,
          y = G.top + (m.clientTop + parseFloat(Z.paddingTop)) * p.y;
        (A *= p.x),
          (c *= p.y),
          (d *= p.x),
          (i *= p.y),
          (A += B),
          (c += y),
          (b = rI(m)),
          (m = hd(b));
      }
    }
    return Wo({ width: d, height: i, x: A, y: c });
  }
  function EV(g) {
    let { elements: I, rect: e, offsetParent: C, strategy: l } = g;
    const t = l === "fixed",
      n = $I(C),
      o = I ? tA(I.floating) : !1;
    if (C === n || (o && t)) return e;
    let A = { scrollLeft: 0, scrollTop: 0 },
      c = Qe(1);
    const d = Qe(0),
      i = OI(C);
    if (
      (i || (!i && !t)) &&
      ((Vl(C) !== "body" || _t(n)) && (A = nA(C)), OI(C))
    ) {
      const r = GC(C);
      (c = Cl(C)), (d.x = r.x + C.clientLeft), (d.y = r.y + C.clientTop);
    }
    return {
      width: e.width * c.x,
      height: e.height * c.y,
      x: e.x * c.x - A.scrollLeft * c.x + d.x,
      y: e.y * c.y - A.scrollTop * c.y + d.y,
    };
  }
  function UV(g) {
    return Array.from(g.getClientRects());
  }
  function Sd(g, I) {
    const e = nA(g).scrollLeft;
    return I ? I.left + e : GC($I(g)).left + e;
  }
  function QV(g) {
    const I = $I(g),
      e = nA(g),
      C = g.ownerDocument.body,
      l = cI(I.scrollWidth, I.clientWidth, C.scrollWidth, C.clientWidth),
      t = cI(I.scrollHeight, I.clientHeight, C.scrollHeight, C.clientHeight);
    let n = -e.scrollLeft + Sd(g);
    const o = -e.scrollTop;
    return (
      MI(C).direction === "rtl" && (n += cI(I.clientWidth, C.clientWidth) - l),
      { width: l, height: t, x: n, y: o }
    );
  }
  function LV(g, I) {
    const e = rI(g),
      C = $I(g),
      l = e.visualViewport;
    let t = C.clientWidth,
      n = C.clientHeight,
      o = 0,
      A = 0;
    if (l) {
      (t = l.width), (n = l.height);
      const c = qi();
      (!c || (c && I === "fixed")) && ((o = l.offsetLeft), (A = l.offsetTop));
    }
    return { width: t, height: n, x: o, y: A };
  }
  function DV(g, I) {
    const e = GC(g, !0, I === "fixed"),
      C = e.top + g.clientTop,
      l = e.left + g.clientLeft,
      t = OI(g) ? Cl(g) : Qe(1),
      n = g.clientWidth * t.x,
      o = g.clientHeight * t.y,
      A = l * t.x,
      c = C * t.y;
    return { width: n, height: o, x: A, y: c };
  }
  function cs(g, I, e) {
    let C;
    if (I === "viewport") C = LV(g, e);
    else if (I === "document") C = QV($I(g));
    else if (xI(I)) C = DV(I, e);
    else {
      const l = vZ(g);
      C = { ...I, x: I.x - l.x, y: I.y - l.y };
    }
    return Wo(C);
  }
  function kZ(g, I) {
    const e = De(g);
    return e === I || !xI(e) || sl(e)
      ? !1
      : MI(e).position === "fixed" || kZ(e, I);
  }
  function TV(g, I) {
    const e = I.get(g);
    if (e) return e;
    let C = Vt(g, [], !1).filter((o) => xI(o) && Vl(o) !== "body"),
      l = null;
    const t = MI(g).position === "fixed";
    let n = t ? De(g) : g;
    for (; xI(n) && !sl(n); ) {
      const o = MI(n),
        A = _i(n);
      !A && o.position === "fixed" && (l = null),
        (
          t
            ? !A && !l
            : (!A &&
                o.position === "static" &&
                !!l &&
                ["absolute", "fixed"].includes(l.position)) ||
              (_t(n) && !A && kZ(g, n))
        )
          ? (C = C.filter((d) => d !== n))
          : (l = o),
        (n = De(n));
    }
    return I.set(g, C), C;
  }
  function jV(g) {
    let { element: I, boundary: e, rootBoundary: C, strategy: l } = g;
    const n = [
        ...(e === "clippingAncestors"
          ? tA(I)
            ? []
            : TV(I, this._c)
          : [].concat(e)),
        C,
      ],
      o = n[0],
      A = n.reduce((c, d) => {
        const i = cs(I, d, l);
        return (
          (c.top = cI(i.top, c.top)),
          (c.right = Ue(i.right, c.right)),
          (c.bottom = Ue(i.bottom, c.bottom)),
          (c.left = cI(i.left, c.left)),
          c
        );
      }, cs(I, o, l));
    return {
      width: A.right - A.left,
      height: A.bottom - A.top,
      x: A.left,
      y: A.top,
    };
  }
  function PV(g) {
    const { width: I, height: e } = JZ(g);
    return { width: I, height: e };
  }
  function OV(g, I, e) {
    const C = OI(I),
      l = $I(I),
      t = e === "fixed",
      n = GC(g, !0, t, I);
    let o = { scrollLeft: 0, scrollTop: 0 };
    const A = Qe(0);
    if (C || (!C && !t))
      if (((Vl(I) !== "body" || _t(l)) && (o = nA(I)), C)) {
        const u = GC(I, !0, t, I);
        (A.x = u.x + I.clientLeft), (A.y = u.y + I.clientTop);
      } else l && (A.x = Sd(l));
    let c = 0,
      d = 0;
    if (l && !C && !t) {
      const u = l.getBoundingClientRect();
      (d = u.top + o.scrollTop), (c = u.left + o.scrollLeft - Sd(l, u));
    }
    const i = n.left + o.scrollLeft - A.x - c,
      r = n.top + o.scrollTop - A.y - d;
    return { x: i, y: r, width: n.width, height: n.height };
  }
  function lc(g) {
    return MI(g).position === "static";
  }
  function ds(g, I) {
    if (!OI(g) || MI(g).position === "fixed") return null;
    if (I) return I(g);
    let e = g.offsetParent;
    return $I(g) === e && (e = e.ownerDocument.body), e;
  }
  function fZ(g, I) {
    const e = rI(g);
    if (tA(g)) return e;
    if (!OI(g)) {
      let l = De(g);
      for (; l && !sl(l); ) {
        if (xI(l) && !lc(l)) return l;
        l = De(l);
      }
      return e;
    }
    let C = ds(g, I);
    for (; C && FV(C) && lc(C); ) C = ds(C, I);
    return C && sl(C) && lc(C) && !_i(C) ? e : C || xV(g) || e;
  }
  const _V = async function (g) {
    const I = this.getOffsetParent || fZ,
      e = this.getDimensions,
      C = await e(g.floating);
    return {
      reference: OV(g.reference, await I(g.floating), g.strategy),
      floating: { x: 0, y: 0, width: C.width, height: C.height },
    };
  };
  function qV(g) {
    return MI(g).direction === "rtl";
  }
  const $V = {
    convertOffsetParentRelativeRectToViewportRelativeRect: EV,
    getDocumentElement: $I,
    getClippingRect: jV,
    getOffsetParent: fZ,
    getElementRects: _V,
    getClientRects: UV,
    getDimensions: PV,
    getScale: Cl,
    isElement: xI,
    isRTL: qV,
  };
  function gW(g, I) {
    let e = null,
      C;
    const l = $I(g);
    function t() {
      var o;
      clearTimeout(C), (o = e) == null || o.disconnect(), (e = null);
    }
    function n(o, A) {
      o === void 0 && (o = !1), A === void 0 && (A = 1), t();
      const {
        left: c,
        top: d,
        width: i,
        height: r,
      } = g.getBoundingClientRect();
      if ((o || I(), !i || !r)) return;
      const u = Sn(d),
        b = Sn(l.clientWidth - (c + i)),
        m = Sn(l.clientHeight - (d + r)),
        p = Sn(c),
        Z = {
          rootMargin: -u + "px " + -b + "px " + -m + "px " + -p + "px",
          threshold: cI(0, Ue(1, A)) || 1,
        };
      let B = !0;
      function y(h) {
        const W = h[0].intersectionRatio;
        if (W !== A) {
          if (!B) return n();
          W
            ? n(!1, W)
            : (C = setTimeout(() => {
                n(!1, 1e-7);
              }, 1e3));
        }
        B = !1;
      }
      try {
        e = new IntersectionObserver(y, { ...Z, root: l.ownerDocument });
      } catch {
        e = new IntersectionObserver(y, Z);
      }
      e.observe(g);
    }
    return n(!0), t;
  }
  function IW(g, I, e, C) {
    C === void 0 && (C = {});
    const {
        ancestorScroll: l = !0,
        ancestorResize: t = !0,
        elementResize: n = typeof ResizeObserver == "function",
        layoutShift: o = typeof IntersectionObserver == "function",
        animationFrame: A = !1,
      } = C,
      c = $i(g),
      d = l || t ? [...(c ? Vt(c) : []), ...Vt(I)] : [];
    d.forEach((G) => {
      l && G.addEventListener("scroll", e, { passive: !0 }),
        t && G.addEventListener("resize", e);
    });
    const i = c && o ? gW(c, e) : null;
    let r = -1,
      u = null;
    n &&
      ((u = new ResizeObserver((G) => {
        let [Z] = G;
        Z &&
          Z.target === c &&
          u &&
          (u.unobserve(I),
          cancelAnimationFrame(r),
          (r = requestAnimationFrame(() => {
            var B;
            (B = u) == null || B.observe(I);
          }))),
          e();
      })),
      c && !A && u.observe(c),
      u.observe(I));
    let b,
      m = A ? GC(g) : null;
    A && p();
    function p() {
      const G = GC(g);
      m &&
        (G.x !== m.x ||
          G.y !== m.y ||
          G.width !== m.width ||
          G.height !== m.height) &&
        e(),
        (m = G),
        (b = requestAnimationFrame(p));
    }
    return (
      e(),
      () => {
        var G;
        d.forEach((Z) => {
          l && Z.removeEventListener("scroll", e),
            t && Z.removeEventListener("resize", e);
        }),
          i == null || i(),
          (G = u) == null || G.disconnect(),
          (u = null),
          A && cancelAnimationFrame(b);
      }
    );
  }
  const eW = HV,
    CW = wV,
    lW = kV,
    tW = KV,
    nW = fV,
    is = vV,
    oW = NV,
    AW = (g, I, e) => {
      const C = new Map(),
        l = { platform: $V, ...e },
        t = { ...l.platform, _c: C };
      return JV(g, I, { ...l, platform: t });
    };
  var Dn = typeof document < "u" ? a.useLayoutEffect : a.useEffect;
  function Ro(g, I) {
    if (g === I) return !0;
    if (typeof g != typeof I) return !1;
    if (typeof g == "function" && g.toString() === I.toString()) return !0;
    let e, C, l;
    if (g && I && typeof g == "object") {
      if (Array.isArray(g)) {
        if (((e = g.length), e !== I.length)) return !1;
        for (C = e; C-- !== 0; ) if (!Ro(g[C], I[C])) return !1;
        return !0;
      }
      if (((l = Object.keys(g)), (e = l.length), e !== Object.keys(I).length))
        return !1;
      for (C = e; C-- !== 0; ) if (!{}.hasOwnProperty.call(I, l[C])) return !1;
      for (C = e; C-- !== 0; ) {
        const t = l[C];
        if (!(t === "_owner" && g.$$typeof) && !Ro(g[t], I[t])) return !1;
      }
      return !0;
    }
    return g !== g && I !== I;
  }
  function YZ(g) {
    return typeof window > "u"
      ? 1
      : (g.ownerDocument.defaultView || window).devicePixelRatio || 1;
  }
  function as(g, I) {
    const e = YZ(g);
    return Math.round(I * e) / e;
  }
  function tc(g) {
    const I = a.useRef(g);
    return (
      Dn(() => {
        I.current = g;
      }),
      I
    );
  }
  function cW(g) {
    g === void 0 && (g = {});
    const {
        placement: I = "bottom",
        strategy: e = "absolute",
        middleware: C = [],
        platform: l,
        elements: { reference: t, floating: n } = {},
        transform: o = !0,
        whileElementsMounted: A,
        open: c,
      } = g,
      [d, i] = a.useState({
        x: 0,
        y: 0,
        strategy: e,
        placement: I,
        middlewareData: {},
        isPositioned: !1,
      }),
      [r, u] = a.useState(C);
    Ro(r, C) || u(C);
    const [b, m] = a.useState(null),
      [p, G] = a.useState(null),
      Z = a.useCallback((R) => {
        R !== W.current && ((W.current = R), m(R));
      }, []),
      B = a.useCallback((R) => {
        R !== S.current && ((S.current = R), G(R));
      }, []),
      y = t || b,
      h = n || p,
      W = a.useRef(null),
      S = a.useRef(null),
      V = a.useRef(d),
      f = A != null,
      k = tc(A),
      F = tc(l),
      K = tc(c),
      P = a.useCallback(() => {
        if (!W.current || !S.current) return;
        const R = { placement: I, strategy: e, middleware: r };
        F.current && (R.platform = F.current),
          AW(W.current, S.current, R).then((X) => {
            const H = { ...X, isPositioned: K.current !== !1 };
            T.current &&
              !Ro(V.current, H) &&
              ((V.current = H),
              jt.flushSync(() => {
                i(H);
              }));
          });
      }, [r, I, e, F, K]);
    Dn(() => {
      c === !1 &&
        V.current.isPositioned &&
        ((V.current.isPositioned = !1), i((R) => ({ ...R, isPositioned: !1 })));
    }, [c]);
    const T = a.useRef(!1);
    Dn(
      () => (
        (T.current = !0),
        () => {
          T.current = !1;
        }
      ),
      []
    ),
      Dn(() => {
        if ((y && (W.current = y), h && (S.current = h), y && h)) {
          if (k.current) return k.current(y, h, P);
          P();
        }
      }, [y, h, P, k, f]);
    const ng = a.useMemo(
        () => ({ reference: W, floating: S, setReference: Z, setFloating: B }),
        [Z, B]
      ),
      z = a.useMemo(() => ({ reference: y, floating: h }), [y, h]),
      gg = a.useMemo(() => {
        const R = { position: e, left: 0, top: 0 };
        if (!z.floating) return R;
        const X = as(z.floating, d.x),
          H = as(z.floating, d.y);
        return o
          ? {
              ...R,
              transform: "translate(" + X + "px, " + H + "px)",
              ...(YZ(z.floating) >= 1.5 && { willChange: "transform" }),
            }
          : { position: e, left: X, top: H };
      }, [e, o, z.floating, d.x, d.y]);
    return a.useMemo(
      () => ({ ...d, update: P, refs: ng, elements: z, floatingStyles: gg }),
      [d, P, ng, z, gg]
    );
  }
  const dW = (g) => {
      function I(e) {
        return {}.hasOwnProperty.call(e, "current");
      }
      return {
        name: "arrow",
        options: g,
        fn(e) {
          const { element: C, padding: l } = typeof g == "function" ? g(e) : g;
          return C && I(C)
            ? C.current != null
              ? is({ element: C.current, padding: l }).fn(e)
              : {}
            : C
            ? is({ element: C, padding: l }).fn(e)
            : {};
        },
      };
    },
    iW = (g, I) => ({ ...eW(g), options: [g, I] }),
    aW = (g, I) => ({ ...CW(g), options: [g, I] }),
    rW = (g, I) => ({ ...oW(g), options: [g, I] }),
    sW = (g, I) => ({ ...lW(g), options: [g, I] }),
    uW = (g, I) => ({ ...tW(g), options: [g, I] }),
    mW = (g, I) => ({ ...nW(g), options: [g, I] }),
    ZW = (g, I) => ({ ...dW(g), options: [g, I] });
  var GW = "Arrow",
    HZ = a.forwardRef((g, I) => {
      const { children: e, width: C = 10, height: l = 5, ...t } = g;
      return s.jsx(tg.svg, {
        ...t,
        ref: I,
        width: C,
        height: l,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: g.asChild
          ? e
          : s.jsx("polygon", { points: "0,0 30,0 15,10" }),
      });
    });
  HZ.displayName = GW;
  var bW = HZ;
  function BW(g, I = []) {
    let e = [];
    function C(t, n) {
      const o = a.createContext(n),
        A = e.length;
      e = [...e, n];
      function c(i) {
        const { scope: r, children: u, ...b } = i,
          m = (r == null ? void 0 : r[g][A]) || o,
          p = a.useMemo(() => b, Object.values(b));
        return s.jsx(m.Provider, { value: p, children: u });
      }
      function d(i, r) {
        const u = (r == null ? void 0 : r[g][A]) || o,
          b = a.useContext(u);
        if (b) return b;
        if (n !== void 0) return n;
        throw new Error(`\`${i}\` must be used within \`${t}\``);
      }
      return (c.displayName = t + "Provider"), [c, d];
    }
    const l = () => {
      const t = e.map((n) => a.createContext(n));
      return function (o) {
        const A = (o == null ? void 0 : o[g]) || t;
        return a.useMemo(() => ({ [`__scope${g}`]: { ...o, [g]: A } }), [o, A]);
      };
    };
    return (l.scopeName = g), [C, pW(l, ...I)];
  }
  function pW(...g) {
    const I = g[0];
    if (g.length === 1) return I;
    const e = () => {
      const C = g.map((l) => ({ useScope: l(), scopeName: l.scopeName }));
      return function (t) {
        const n = C.reduce((o, { useScope: A, scopeName: c }) => {
          const i = A(t)[`__scope${c}`];
          return { ...o, ...i };
        }, {});
        return a.useMemo(() => ({ [`__scope${I.scopeName}`]: n }), [n]);
      };
    };
    return (e.scopeName = I.scopeName), e;
  }
  var ga = "Popper",
    [wZ, oA] = BW(ga),
    [yW, NZ] = wZ(ga),
    KZ = (g) => {
      const { __scopePopper: I, children: e } = g,
        [C, l] = a.useState(null);
      return s.jsx(yW, { scope: I, anchor: C, onAnchorChange: l, children: e });
    };
  KZ.displayName = ga;
  var FZ = "PopperAnchor",
    xZ = a.forwardRef((g, I) => {
      const { __scopePopper: e, virtualRef: C, ...l } = g,
        t = NZ(FZ, e),
        n = a.useRef(null),
        o = Gg(I, n);
      return (
        a.useEffect(() => {
          t.onAnchorChange((C == null ? void 0 : C.current) || n.current);
        }),
        C ? null : s.jsx(tg.div, { ...l, ref: o })
      );
    });
  xZ.displayName = FZ;
  var Ia = "PopperContent",
    [hW, SW] = wZ(Ia),
    MZ = a.forwardRef((g, I) => {
      var M, cg, rg, og, dg, ig;
      const {
          __scopePopper: e,
          side: C = "bottom",
          sideOffset: l = 0,
          align: t = "center",
          alignOffset: n = 0,
          arrowPadding: o = 0,
          avoidCollisions: A = !0,
          collisionBoundary: c = [],
          collisionPadding: d = 0,
          sticky: i = "partial",
          hideWhenDetached: r = !1,
          updatePositionStrategy: u = "optimized",
          onPlaced: b,
          ...m
        } = g,
        p = NZ(Ia, e),
        [G, Z] = a.useState(null),
        B = Gg(I, (oI) => Z(oI)),
        [y, h] = a.useState(null),
        W = iZ(y),
        S = (W == null ? void 0 : W.width) ?? 0,
        V = (W == null ? void 0 : W.height) ?? 0,
        f = C + (t !== "center" ? "-" + t : ""),
        k =
          typeof d == "number"
            ? d
            : { top: 0, right: 0, bottom: 0, left: 0, ...d },
        F = Array.isArray(c) ? c : [c],
        K = F.length > 0,
        P = { padding: k, boundary: F.filter(WW), altBoundary: K },
        {
          refs: T,
          floatingStyles: ng,
          placement: z,
          isPositioned: gg,
          middlewareData: R,
        } = cW({
          strategy: "fixed",
          placement: f,
          whileElementsMounted: (...oI) =>
            IW(...oI, { animationFrame: u === "always" }),
          elements: { reference: p.anchor },
          middleware: [
            iW({ mainAxis: l + V, alignmentAxis: n }),
            A &&
              aW({
                mainAxis: !0,
                crossAxis: !1,
                limiter: i === "partial" ? rW() : void 0,
                ...P,
              }),
            A && sW({ ...P }),
            uW({
              ...P,
              apply: ({
                elements: oI,
                rects: EI,
                availableWidth: Rl,
                availableHeight: Xl,
              }) => {
                const { width: Jl, height: N0 } = EI.reference,
                  ln = oI.floating.style;
                ln.setProperty("--radix-popper-available-width", `${Rl}px`),
                  ln.setProperty("--radix-popper-available-height", `${Xl}px`),
                  ln.setProperty("--radix-popper-anchor-width", `${Jl}px`),
                  ln.setProperty("--radix-popper-anchor-height", `${N0}px`);
              },
            }),
            y && ZW({ element: y, padding: o }),
            RW({ arrowWidth: S, arrowHeight: V }),
            r && mW({ strategy: "referenceHidden", ...P }),
          ],
        }),
        [X, H] = UZ(z),
        U = tI(b);
      xg(() => {
        gg && (U == null || U());
      }, [gg, U]);
      const Cg = (M = R.arrow) == null ? void 0 : M.x,
        $g = (cg = R.arrow) == null ? void 0 : cg.y,
        Rg = ((rg = R.arrow) == null ? void 0 : rg.centerOffset) !== 0,
        [nI, Vg] = a.useState();
      return (
        xg(() => {
          G && Vg(window.getComputedStyle(G).zIndex);
        }, [G]),
        s.jsx("div", {
          ref: T.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...ng,
            transform: gg ? ng.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: nI,
            "--radix-popper-transform-origin": [
              (og = R.transformOrigin) == null ? void 0 : og.x,
              (dg = R.transformOrigin) == null ? void 0 : dg.y,
            ].join(" "),
            ...(((ig = R.hide) == null ? void 0 : ig.referenceHidden) && {
              visibility: "hidden",
              pointerEvents: "none",
            }),
          },
          dir: g.dir,
          children: s.jsx(hW, {
            scope: e,
            placedSide: X,
            onArrowChange: h,
            arrowX: Cg,
            arrowY: $g,
            shouldHideArrow: Rg,
            children: s.jsx(tg.div, {
              "data-side": X,
              "data-align": H,
              ...m,
              ref: B,
              style: { ...m.style, animation: gg ? void 0 : "none" },
            }),
          }),
        })
      );
    });
  MZ.displayName = Ia;
  var zZ = "PopperArrow",
    VW = { top: "bottom", right: "left", bottom: "top", left: "right" },
    EZ = a.forwardRef(function (I, e) {
      const { __scopePopper: C, ...l } = I,
        t = SW(zZ, C),
        n = VW[t.placedSide];
      return s.jsx("span", {
        ref: t.onArrowChange,
        style: {
          position: "absolute",
          left: t.arrowX,
          top: t.arrowY,
          [n]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0",
          }[t.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)",
          }[t.placedSide],
          visibility: t.shouldHideArrow ? "hidden" : void 0,
        },
        children: s.jsx(bW, {
          ...l,
          ref: e,
          style: { ...l.style, display: "block" },
        }),
      });
    });
  EZ.displayName = zZ;
  function WW(g) {
    return g !== null;
  }
  var RW = (g) => ({
    name: "transformOrigin",
    options: g,
    fn(I) {
      var p, G, Z;
      const { placement: e, rects: C, middlewareData: l } = I,
        n = ((p = l.arrow) == null ? void 0 : p.centerOffset) !== 0,
        o = n ? 0 : g.arrowWidth,
        A = n ? 0 : g.arrowHeight,
        [c, d] = UZ(e),
        i = { start: "0%", center: "50%", end: "100%" }[d],
        r = (((G = l.arrow) == null ? void 0 : G.x) ?? 0) + o / 2,
        u = (((Z = l.arrow) == null ? void 0 : Z.y) ?? 0) + A / 2;
      let b = "",
        m = "";
      return (
        c === "bottom"
          ? ((b = n ? i : `${r}px`), (m = `${-A}px`))
          : c === "top"
          ? ((b = n ? i : `${r}px`), (m = `${C.floating.height + A}px`))
          : c === "right"
          ? ((b = `${-A}px`), (m = n ? i : `${u}px`))
          : c === "left" &&
            ((b = `${C.floating.width + A}px`), (m = n ? i : `${u}px`)),
        { data: { x: b, y: m } }
      );
    },
  });
  function UZ(g) {
    const [I, e = "center"] = g.split("-");
    return [I, e];
  }
  var ea = KZ,
    QZ = xZ,
    LZ = MZ,
    DZ = EZ,
    XW = "Portal",
    Ca = a.forwardRef((g, I) => {
      var o;
      const { container: e, ...C } = g,
        [l, t] = a.useState(!1);
      xg(() => t(!0), []);
      const n =
        e ||
        (l &&
          ((o = globalThis == null ? void 0 : globalThis.document) == null
            ? void 0
            : o.body));
      return n ? Qm.createPortal(s.jsx(tg.div, { ...C, ref: I }), n) : null;
    });
  Ca.displayName = XW;
  function JW(g, I = []) {
    let e = [];
    function C(t, n) {
      const o = a.createContext(n),
        A = e.length;
      e = [...e, n];
      function c(i) {
        const { scope: r, children: u, ...b } = i,
          m = (r == null ? void 0 : r[g][A]) || o,
          p = a.useMemo(() => b, Object.values(b));
        return s.jsx(m.Provider, { value: p, children: u });
      }
      function d(i, r) {
        const u = (r == null ? void 0 : r[g][A]) || o,
          b = a.useContext(u);
        if (b) return b;
        if (n !== void 0) return n;
        throw new Error(`\`${i}\` must be used within \`${t}\``);
      }
      return (c.displayName = t + "Provider"), [c, d];
    }
    const l = () => {
      const t = e.map((n) => a.createContext(n));
      return function (o) {
        const A = (o == null ? void 0 : o[g]) || t;
        return a.useMemo(() => ({ [`__scope${g}`]: { ...o, [g]: A } }), [o, A]);
      };
    };
    return (l.scopeName = g), [C, vW(l, ...I)];
  }
  function vW(...g) {
    const I = g[0];
    if (g.length === 1) return I;
    const e = () => {
      const C = g.map((l) => ({ useScope: l(), scopeName: l.scopeName }));
      return function (t) {
        const n = C.reduce((o, { useScope: A, scopeName: c }) => {
          const i = A(t)[`__scope${c}`];
          return { ...o, ...i };
        }, {});
        return a.useMemo(() => ({ [`__scope${I.scopeName}`]: n }), [n]);
      };
    };
    return (e.scopeName = I.scopeName), e;
  }
  var nc = "rovingFocusGroup.onEntryFocus",
    kW = { bubbles: !1, cancelable: !0 },
    AA = "RovingFocusGroup",
    [Vd, TZ, fW] = Qi(AA),
    [YW, jZ] = JW(AA, [fW]),
    [HW, wW] = YW(AA),
    PZ = a.forwardRef((g, I) =>
      s.jsx(Vd.Provider, {
        scope: g.__scopeRovingFocusGroup,
        children: s.jsx(Vd.Slot, {
          scope: g.__scopeRovingFocusGroup,
          children: s.jsx(NW, { ...g, ref: I }),
        }),
      })
    );
  PZ.displayName = AA;
  var NW = a.forwardRef((g, I) => {
      const {
          __scopeRovingFocusGroup: e,
          orientation: C,
          loop: l = !1,
          dir: t,
          currentTabStopId: n,
          defaultCurrentTabStopId: o,
          onCurrentTabStopIdChange: A,
          onEntryFocus: c,
          preventScrollOnEntryFocus: d = !1,
          ...i
        } = g,
        r = a.useRef(null),
        u = Gg(I, r),
        b = Li(t),
        [m = null, p] = rl({ prop: n, defaultProp: o, onChange: A }),
        [G, Z] = a.useState(!1),
        B = tI(c),
        y = TZ(e),
        h = a.useRef(!1),
        [W, S] = a.useState(0);
      return (
        a.useEffect(() => {
          const V = r.current;
          if (V)
            return (
              V.addEventListener(nc, B), () => V.removeEventListener(nc, B)
            );
        }, [B]),
        s.jsx(HW, {
          scope: e,
          orientation: C,
          dir: b,
          loop: l,
          currentTabStopId: m,
          onItemFocus: a.useCallback((V) => p(V), [p]),
          onItemShiftTab: a.useCallback(() => Z(!0), []),
          onFocusableItemAdd: a.useCallback(() => S((V) => V + 1), []),
          onFocusableItemRemove: a.useCallback(() => S((V) => V - 1), []),
          children: s.jsx(tg.div, {
            tabIndex: G || W === 0 ? -1 : 0,
            "data-orientation": C,
            ...i,
            ref: u,
            style: { outline: "none", ...g.style },
            onMouseDown: E(g.onMouseDown, () => {
              h.current = !0;
            }),
            onFocus: E(g.onFocus, (V) => {
              const f = !h.current;
              if (V.target === V.currentTarget && f && !G) {
                const k = new CustomEvent(nc, kW);
                if ((V.currentTarget.dispatchEvent(k), !k.defaultPrevented)) {
                  const F = y().filter((z) => z.focusable),
                    K = F.find((z) => z.active),
                    P = F.find((z) => z.id === m),
                    ng = [K, P, ...F].filter(Boolean).map((z) => z.ref.current);
                  qZ(ng, d);
                }
              }
              h.current = !1;
            }),
            onBlur: E(g.onBlur, () => Z(!1)),
          }),
        })
      );
    }),
    OZ = "RovingFocusGroupItem",
    _Z = a.forwardRef((g, I) => {
      const {
          __scopeRovingFocusGroup: e,
          focusable: C = !0,
          active: l = !1,
          tabStopId: t,
          ...n
        } = g,
        o = Ee(),
        A = t || o,
        c = wW(OZ, e),
        d = c.currentTabStopId === A,
        i = TZ(e),
        { onFocusableItemAdd: r, onFocusableItemRemove: u } = c;
      return (
        a.useEffect(() => {
          if (C) return r(), () => u();
        }, [C, r, u]),
        s.jsx(Vd.ItemSlot, {
          scope: e,
          id: A,
          focusable: C,
          active: l,
          children: s.jsx(tg.span, {
            tabIndex: d ? 0 : -1,
            "data-orientation": c.orientation,
            ...n,
            ref: I,
            onMouseDown: E(g.onMouseDown, (b) => {
              C ? c.onItemFocus(A) : b.preventDefault();
            }),
            onFocus: E(g.onFocus, () => c.onItemFocus(A)),
            onKeyDown: E(g.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                c.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const m = xW(b, c.orientation, c.dir);
              if (m !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let G = i()
                  .filter((Z) => Z.focusable)
                  .map((Z) => Z.ref.current);
                if (m === "last") G.reverse();
                else if (m === "prev" || m === "next") {
                  m === "prev" && G.reverse();
                  const Z = G.indexOf(b.currentTarget);
                  G = c.loop ? MW(G, Z + 1) : G.slice(Z + 1);
                }
                setTimeout(() => qZ(G));
              }
            }),
          }),
        })
      );
    });
  _Z.displayName = OZ;
  var KW = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last",
  };
  function FW(g, I) {
    return I !== "rtl"
      ? g
      : g === "ArrowLeft"
      ? "ArrowRight"
      : g === "ArrowRight"
      ? "ArrowLeft"
      : g;
  }
  function xW(g, I, e) {
    const C = FW(g.key, e);
    if (
      !(I === "vertical" && ["ArrowLeft", "ArrowRight"].includes(C)) &&
      !(I === "horizontal" && ["ArrowUp", "ArrowDown"].includes(C))
    )
      return KW[C];
  }
  function qZ(g, I = !1) {
    const e = document.activeElement;
    for (const C of g)
      if (
        C === e ||
        (C.focus({ preventScroll: I }), document.activeElement !== e)
      )
        return;
  }
  function MW(g, I) {
    return g.map((e, C) => g[(I + C) % g.length]);
  }
  var zW = PZ,
    EW = _Z,
    UW = function (g) {
      if (typeof document > "u") return null;
      var I = Array.isArray(g) ? g[0] : g;
      return I.ownerDocument.body;
    },
    vC = new WeakMap(),
    Vn = new WeakMap(),
    Wn = {},
    oc = 0,
    $Z = function (g) {
      return g && (g.host || $Z(g.parentNode));
    },
    QW = function (g, I) {
      return I.map(function (e) {
        if (g.contains(e)) return e;
        var C = $Z(e);
        return C && g.contains(C)
          ? C
          : (console.error(
              "aria-hidden",
              e,
              "in not contained inside",
              g,
              ". Doing nothing"
            ),
            null);
      }).filter(function (e) {
        return !!e;
      });
    },
    LW = function (g, I, e, C) {
      var l = QW(I, Array.isArray(g) ? g : [g]);
      Wn[e] || (Wn[e] = new WeakMap());
      var t = Wn[e],
        n = [],
        o = new Set(),
        A = new Set(l),
        c = function (i) {
          !i || o.has(i) || (o.add(i), c(i.parentNode));
        };
      l.forEach(c);
      var d = function (i) {
        !i ||
          A.has(i) ||
          Array.prototype.forEach.call(i.children, function (r) {
            if (o.has(r)) d(r);
            else
              try {
                var u = r.getAttribute(C),
                  b = u !== null && u !== "false",
                  m = (vC.get(r) || 0) + 1,
                  p = (t.get(r) || 0) + 1;
                vC.set(r, m),
                  t.set(r, p),
                  n.push(r),
                  m === 1 && b && Vn.set(r, !0),
                  p === 1 && r.setAttribute(e, "true"),
                  b || r.setAttribute(C, "true");
              } catch (G) {
                console.error("aria-hidden: cannot operate on ", r, G);
              }
          });
      };
      return (
        d(I),
        o.clear(),
        oc++,
        function () {
          n.forEach(function (i) {
            var r = vC.get(i) - 1,
              u = t.get(i) - 1;
            vC.set(i, r),
              t.set(i, u),
              r || (Vn.has(i) || i.removeAttribute(C), Vn.delete(i)),
              u || i.removeAttribute(e);
          }),
            oc--,
            oc ||
              ((vC = new WeakMap()),
              (vC = new WeakMap()),
              (Vn = new WeakMap()),
              (Wn = {}));
        }
      );
    },
    gG = function (g, I, e) {
      e === void 0 && (e = "data-aria-hidden");
      var C = Array.from(Array.isArray(g) ? g : [g]),
        l = UW(g);
      return l
        ? (C.push.apply(C, Array.from(l.querySelectorAll("[aria-live]"))),
          LW(C, l, e, "aria-hidden"))
        : function () {
            return null;
          };
    },
    DI = function () {
      return (
        (DI =
          Object.assign ||
          function (I) {
            for (var e, C = 1, l = arguments.length; C < l; C++) {
              e = arguments[C];
              for (var t in e)
                Object.prototype.hasOwnProperty.call(e, t) && (I[t] = e[t]);
            }
            return I;
          }),
        DI.apply(this, arguments)
      );
    };
  function IG(g, I) {
    var e = {};
    for (var C in g)
      Object.prototype.hasOwnProperty.call(g, C) &&
        I.indexOf(C) < 0 &&
        (e[C] = g[C]);
    if (g != null && typeof Object.getOwnPropertySymbols == "function")
      for (var l = 0, C = Object.getOwnPropertySymbols(g); l < C.length; l++)
        I.indexOf(C[l]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(g, C[l]) &&
          (e[C[l]] = g[C[l]]);
    return e;
  }
  function DW(g, I, e) {
    if (e || arguments.length === 2)
      for (var C = 0, l = I.length, t; C < l; C++)
        (t || !(C in I)) &&
          (t || (t = Array.prototype.slice.call(I, 0, C)), (t[C] = I[C]));
    return g.concat(t || Array.prototype.slice.call(I));
  }
  var Tn = "right-scroll-bar-position",
    jn = "width-before-scroll-bar",
    TW = "with-scroll-bars-hidden",
    jW = "--removed-body-scroll-bar-size";
  function Ac(g, I) {
    return typeof g == "function" ? g(I) : g && (g.current = I), g;
  }
  function PW(g, I) {
    var e = a.useState(function () {
      return {
        value: g,
        callback: I,
        facade: {
          get current() {
            return e.value;
          },
          set current(C) {
            var l = e.value;
            l !== C && ((e.value = C), e.callback(C, l));
          },
        },
      };
    })[0];
    return (e.callback = I), e.facade;
  }
  var OW = typeof window < "u" ? a.useLayoutEffect : a.useEffect,
    rs = new WeakMap();
  function _W(g, I) {
    var e = PW(null, function (C) {
      return g.forEach(function (l) {
        return Ac(l, C);
      });
    });
    return (
      OW(
        function () {
          var C = rs.get(e);
          if (C) {
            var l = new Set(C),
              t = new Set(g),
              n = e.current;
            l.forEach(function (o) {
              t.has(o) || Ac(o, null);
            }),
              t.forEach(function (o) {
                l.has(o) || Ac(o, n);
              });
          }
          rs.set(e, g);
        },
        [g]
      ),
      e
    );
  }
  function qW(g) {
    return g;
  }
  function $W(g, I) {
    I === void 0 && (I = qW);
    var e = [],
      C = !1,
      l = {
        read: function () {
          if (C)
            throw new Error(
              "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
            );
          return e.length ? e[e.length - 1] : g;
        },
        useMedium: function (t) {
          var n = I(t, C);
          return (
            e.push(n),
            function () {
              e = e.filter(function (o) {
                return o !== n;
              });
            }
          );
        },
        assignSyncMedium: function (t) {
          for (C = !0; e.length; ) {
            var n = e;
            (e = []), n.forEach(t);
          }
          e = {
            push: function (o) {
              return t(o);
            },
            filter: function () {
              return e;
            },
          };
        },
        assignMedium: function (t) {
          C = !0;
          var n = [];
          if (e.length) {
            var o = e;
            (e = []), o.forEach(t), (n = e);
          }
          var A = function () {
              var d = n;
              (n = []), d.forEach(t);
            },
            c = function () {
              return Promise.resolve().then(A);
            };
          c(),
            (e = {
              push: function (d) {
                n.push(d), c();
              },
              filter: function (d) {
                return (n = n.filter(d)), e;
              },
            });
        },
      };
    return l;
  }
  function gR(g) {
    g === void 0 && (g = {});
    var I = $W(null);
    return (I.options = DI({ async: !0, ssr: !1 }, g)), I;
  }
  var eG = function (g) {
    var I = g.sideCar,
      e = IG(g, ["sideCar"]);
    if (!I)
      throw new Error(
        "Sidecar: please provide `sideCar` property to import the right car"
      );
    var C = I.read();
    if (!C) throw new Error("Sidecar medium not found");
    return a.createElement(C, DI({}, e));
  };
  eG.isSideCarExport = !0;
  function IR(g, I) {
    return g.useMedium(I), eG;
  }
  var CG = gR(),
    cc = function () {},
    cA = a.forwardRef(function (g, I) {
      var e = a.useRef(null),
        C = a.useState({
          onScrollCapture: cc,
          onWheelCapture: cc,
          onTouchMoveCapture: cc,
        }),
        l = C[0],
        t = C[1],
        n = g.forwardProps,
        o = g.children,
        A = g.className,
        c = g.removeScrollBar,
        d = g.enabled,
        i = g.shards,
        r = g.sideCar,
        u = g.noIsolation,
        b = g.inert,
        m = g.allowPinchZoom,
        p = g.as,
        G = p === void 0 ? "div" : p,
        Z = g.gapMode,
        B = IG(g, [
          "forwardProps",
          "children",
          "className",
          "removeScrollBar",
          "enabled",
          "shards",
          "sideCar",
          "noIsolation",
          "inert",
          "allowPinchZoom",
          "as",
          "gapMode",
        ]),
        y = r,
        h = _W([e, I]),
        W = DI(DI({}, B), l);
      return a.createElement(
        a.Fragment,
        null,
        d &&
          a.createElement(y, {
            sideCar: CG,
            removeScrollBar: c,
            shards: i,
            noIsolation: u,
            inert: b,
            setCallbacks: t,
            allowPinchZoom: !!m,
            lockRef: e,
            gapMode: Z,
          }),
        n
          ? a.cloneElement(a.Children.only(o), DI(DI({}, W), { ref: h }))
          : a.createElement(G, DI({}, W, { className: A, ref: h }), o)
      );
    });
  cA.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
  cA.classNames = { fullWidth: jn, zeroRight: Tn };
  var eR = function () {
    if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
  };
  function CR() {
    if (!document) return null;
    var g = document.createElement("style");
    g.type = "text/css";
    var I = eR();
    return I && g.setAttribute("nonce", I), g;
  }
  function lR(g, I) {
    g.styleSheet
      ? (g.styleSheet.cssText = I)
      : g.appendChild(document.createTextNode(I));
  }
  function tR(g) {
    var I = document.head || document.getElementsByTagName("head")[0];
    I.appendChild(g);
  }
  var nR = function () {
      var g = 0,
        I = null;
      return {
        add: function (e) {
          g == 0 && (I = CR()) && (lR(I, e), tR(I)), g++;
        },
        remove: function () {
          g--,
            !g &&
              I &&
              (I.parentNode && I.parentNode.removeChild(I), (I = null));
        },
      };
    },
    oR = function () {
      var g = nR();
      return function (I, e) {
        a.useEffect(
          function () {
            return (
              g.add(I),
              function () {
                g.remove();
              }
            );
          },
          [I && e]
        );
      };
    },
    lG = function () {
      var g = oR(),
        I = function (e) {
          var C = e.styles,
            l = e.dynamic;
          return g(C, l), null;
        };
      return I;
    },
    AR = { left: 0, top: 0, right: 0, gap: 0 },
    dc = function (g) {
      return parseInt(g || "", 10) || 0;
    },
    cR = function (g) {
      var I = window.getComputedStyle(document.body),
        e = I[g === "padding" ? "paddingLeft" : "marginLeft"],
        C = I[g === "padding" ? "paddingTop" : "marginTop"],
        l = I[g === "padding" ? "paddingRight" : "marginRight"];
      return [dc(e), dc(C), dc(l)];
    },
    dR = function (g) {
      if ((g === void 0 && (g = "margin"), typeof window > "u")) return AR;
      var I = cR(g),
        e = document.documentElement.clientWidth,
        C = window.innerWidth;
      return {
        left: I[0],
        top: I[1],
        right: I[2],
        gap: Math.max(0, C - e + I[2] - I[0]),
      };
    },
    iR = lG(),
    ll = "data-scroll-locked",
    aR = function (g, I, e, C) {
      var l = g.left,
        t = g.top,
        n = g.right,
        o = g.gap;
      return (
        e === void 0 && (e = "margin"),
        `
  .`
          .concat(
            TW,
            ` {
   overflow: hidden `
          )
          .concat(
            C,
            `;
   padding-right: `
          )
          .concat(o, "px ")
          .concat(
            C,
            `;
  }
  body[`
          )
          .concat(
            ll,
            `] {
    overflow: hidden `
          )
          .concat(
            C,
            `;
    overscroll-behavior: contain;
    `
          )
          .concat(
            [
              I && "position: relative ".concat(C, ";"),
              e === "margin" &&
                `
    padding-left: `
                  .concat(
                    l,
                    `px;
    padding-top: `
                  )
                  .concat(
                    t,
                    `px;
    padding-right: `
                  )
                  .concat(
                    n,
                    `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                  )
                  .concat(o, "px ")
                  .concat(
                    C,
                    `;
    `
                  ),
              e === "padding" &&
                "padding-right: ".concat(o, "px ").concat(C, ";"),
            ]
              .filter(Boolean)
              .join(""),
            `
  }
  
  .`
          )
          .concat(
            Tn,
            ` {
    right: `
          )
          .concat(o, "px ")
          .concat(
            C,
            `;
  }
  
  .`
          )
          .concat(
            jn,
            ` {
    margin-right: `
          )
          .concat(o, "px ")
          .concat(
            C,
            `;
  }
  
  .`
          )
          .concat(Tn, " .")
          .concat(
            Tn,
            ` {
    right: 0 `
          )
          .concat(
            C,
            `;
  }
  
  .`
          )
          .concat(jn, " .")
          .concat(
            jn,
            ` {
    margin-right: 0 `
          )
          .concat(
            C,
            `;
  }
  
  body[`
          )
          .concat(
            ll,
            `] {
    `
          )
          .concat(jW, ": ")
          .concat(
            o,
            `px;
  }
`
          )
      );
    },
    ss = function () {
      var g = parseInt(document.body.getAttribute(ll) || "0", 10);
      return isFinite(g) ? g : 0;
    },
    rR = function () {
      a.useEffect(function () {
        return (
          document.body.setAttribute(ll, (ss() + 1).toString()),
          function () {
            var g = ss() - 1;
            g <= 0
              ? document.body.removeAttribute(ll)
              : document.body.setAttribute(ll, g.toString());
          }
        );
      }, []);
    },
    sR = function (g) {
      var I = g.noRelative,
        e = g.noImportant,
        C = g.gapMode,
        l = C === void 0 ? "margin" : C;
      rR();
      var t = a.useMemo(
        function () {
          return dR(l);
        },
        [l]
      );
      return a.createElement(iR, {
        styles: aR(t, !I, l, e ? "" : "!important"),
      });
    },
    Wd = !1;
  if (typeof window < "u")
    try {
      var Rn = Object.defineProperty({}, "passive", {
        get: function () {
          return (Wd = !0), !0;
        },
      });
      window.addEventListener("test", Rn, Rn),
        window.removeEventListener("test", Rn, Rn);
    } catch {
      Wd = !1;
    }
  var kC = Wd ? { passive: !1 } : !1,
    uR = function (g) {
      return g.tagName === "TEXTAREA";
    },
    tG = function (g, I) {
      if (!(g instanceof Element)) return !1;
      var e = window.getComputedStyle(g);
      return (
        e[I] !== "hidden" &&
        !(e.overflowY === e.overflowX && !uR(g) && e[I] === "visible")
      );
    },
    mR = function (g) {
      return tG(g, "overflowY");
    },
    ZR = function (g) {
      return tG(g, "overflowX");
    },
    us = function (g, I) {
      var e = I.ownerDocument,
        C = I;
      do {
        typeof ShadowRoot < "u" && C instanceof ShadowRoot && (C = C.host);
        var l = nG(g, C);
        if (l) {
          var t = oG(g, C),
            n = t[1],
            o = t[2];
          if (n > o) return !0;
        }
        C = C.parentNode;
      } while (C && C !== e.body);
      return !1;
    },
    GR = function (g) {
      var I = g.scrollTop,
        e = g.scrollHeight,
        C = g.clientHeight;
      return [I, e, C];
    },
    bR = function (g) {
      var I = g.scrollLeft,
        e = g.scrollWidth,
        C = g.clientWidth;
      return [I, e, C];
    },
    nG = function (g, I) {
      return g === "v" ? mR(I) : ZR(I);
    },
    oG = function (g, I) {
      return g === "v" ? GR(I) : bR(I);
    },
    BR = function (g, I) {
      return g === "h" && I === "rtl" ? -1 : 1;
    },
    pR = function (g, I, e, C, l) {
      var t = BR(g, window.getComputedStyle(I).direction),
        n = t * C,
        o = e.target,
        A = I.contains(o),
        c = !1,
        d = n > 0,
        i = 0,
        r = 0;
      do {
        var u = oG(g, o),
          b = u[0],
          m = u[1],
          p = u[2],
          G = m - p - t * b;
        (b || G) && nG(g, o) && ((i += G), (r += b)),
          o instanceof ShadowRoot ? (o = o.host) : (o = o.parentNode);
      } while (
        (!A && o !== document.body) ||
        (A && (I.contains(o) || I === o))
      );
      return (
        ((d && (Math.abs(i) < 1 || !l)) || (!d && (Math.abs(r) < 1 || !l))) &&
          (c = !0),
        c
      );
    },
    Xn = function (g) {
      return "changedTouches" in g
        ? [g.changedTouches[0].clientX, g.changedTouches[0].clientY]
        : [0, 0];
    },
    ms = function (g) {
      return [g.deltaX, g.deltaY];
    },
    Zs = function (g) {
      return g && "current" in g ? g.current : g;
    },
    yR = function (g, I) {
      return g[0] === I[0] && g[1] === I[1];
    },
    hR = function (g) {
      return `
  .block-interactivity-`
        .concat(
          g,
          ` {pointer-events: none;}
  .allow-interactivity-`
        )
        .concat(
          g,
          ` {pointer-events: all;}
`
        );
    },
    SR = 0,
    fC = [];
  function VR(g) {
    var I = a.useRef([]),
      e = a.useRef([0, 0]),
      C = a.useRef(),
      l = a.useState(SR++)[0],
      t = a.useState(lG)[0],
      n = a.useRef(g);
    a.useEffect(
      function () {
        n.current = g;
      },
      [g]
    ),
      a.useEffect(
        function () {
          if (g.inert) {
            document.body.classList.add("block-interactivity-".concat(l));
            var m = DW(
              [g.lockRef.current],
              (g.shards || []).map(Zs),
              !0
            ).filter(Boolean);
            return (
              m.forEach(function (p) {
                return p.classList.add("allow-interactivity-".concat(l));
              }),
              function () {
                document.body.classList.remove(
                  "block-interactivity-".concat(l)
                ),
                  m.forEach(function (p) {
                    return p.classList.remove("allow-interactivity-".concat(l));
                  });
              }
            );
          }
        },
        [g.inert, g.lockRef.current, g.shards]
      );
    var o = a.useCallback(function (m, p) {
        if (
          ("touches" in m && m.touches.length === 2) ||
          (m.type === "wheel" && m.ctrlKey)
        )
          return !n.current.allowPinchZoom;
        var G = Xn(m),
          Z = e.current,
          B = "deltaX" in m ? m.deltaX : Z[0] - G[0],
          y = "deltaY" in m ? m.deltaY : Z[1] - G[1],
          h,
          W = m.target,
          S = Math.abs(B) > Math.abs(y) ? "h" : "v";
        if ("touches" in m && S === "h" && W.type === "range") return !1;
        var V = us(S, W);
        if (!V) return !0;
        if ((V ? (h = S) : ((h = S === "v" ? "h" : "v"), (V = us(S, W))), !V))
          return !1;
        if (
          (!C.current && "changedTouches" in m && (B || y) && (C.current = h),
          !h)
        )
          return !0;
        var f = C.current || h;
        return pR(f, p, m, f === "h" ? B : y, !0);
      }, []),
      A = a.useCallback(function (m) {
        var p = m;
        if (!(!fC.length || fC[fC.length - 1] !== t)) {
          var G = "deltaY" in p ? ms(p) : Xn(p),
            Z = I.current.filter(function (h) {
              return (
                h.name === p.type &&
                (h.target === p.target || p.target === h.shadowParent) &&
                yR(h.delta, G)
              );
            })[0];
          if (Z && Z.should) {
            p.cancelable && p.preventDefault();
            return;
          }
          if (!Z) {
            var B = (n.current.shards || [])
                .map(Zs)
                .filter(Boolean)
                .filter(function (h) {
                  return h.contains(p.target);
                }),
              y = B.length > 0 ? o(p, B[0]) : !n.current.noIsolation;
            y && p.cancelable && p.preventDefault();
          }
        }
      }, []),
      c = a.useCallback(function (m, p, G, Z) {
        var B = {
          name: m,
          delta: p,
          target: G,
          should: Z,
          shadowParent: WR(G),
        };
        I.current.push(B),
          setTimeout(function () {
            I.current = I.current.filter(function (y) {
              return y !== B;
            });
          }, 1);
      }, []),
      d = a.useCallback(function (m) {
        (e.current = Xn(m)), (C.current = void 0);
      }, []),
      i = a.useCallback(function (m) {
        c(m.type, ms(m), m.target, o(m, g.lockRef.current));
      }, []),
      r = a.useCallback(function (m) {
        c(m.type, Xn(m), m.target, o(m, g.lockRef.current));
      }, []);
    a.useEffect(function () {
      return (
        fC.push(t),
        g.setCallbacks({
          onScrollCapture: i,
          onWheelCapture: i,
          onTouchMoveCapture: r,
        }),
        document.addEventListener("wheel", A, kC),
        document.addEventListener("touchmove", A, kC),
        document.addEventListener("touchstart", d, kC),
        function () {
          (fC = fC.filter(function (m) {
            return m !== t;
          })),
            document.removeEventListener("wheel", A, kC),
            document.removeEventListener("touchmove", A, kC),
            document.removeEventListener("touchstart", d, kC);
        }
      );
    }, []);
    var u = g.removeScrollBar,
      b = g.inert;
    return a.createElement(
      a.Fragment,
      null,
      b ? a.createElement(t, { styles: hR(l) }) : null,
      u ? a.createElement(sR, { gapMode: g.gapMode }) : null
    );
  }
  function WR(g) {
    for (var I = null; g !== null; )
      g instanceof ShadowRoot && ((I = g.host), (g = g.host)),
        (g = g.parentNode);
    return I;
  }
  const RR = IR(CG, VR);
  var la = a.forwardRef(function (g, I) {
    return a.createElement(cA, DI({}, g, { ref: I, sideCar: RR }));
  });
  la.classNames = cA.classNames;
  var Rd = ["Enter", " "],
    XR = ["ArrowDown", "PageUp", "Home"],
    AG = ["ArrowUp", "PageDown", "End"],
    JR = [...XR, ...AG],
    vR = { ltr: [...Rd, "ArrowRight"], rtl: [...Rd, "ArrowLeft"] },
    kR = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] },
    qt = "Menu",
    [Wt, fR, YR] = Qi(qt),
    [XC, cG] = Ot(qt, [YR, oA, jZ]),
    $t = oA(),
    dG = jZ(),
    [iG, IC] = XC(qt),
    [HR, gn] = XC(qt),
    aG = (g) => {
      const {
          __scopeMenu: I,
          open: e = !1,
          children: C,
          dir: l,
          onOpenChange: t,
          modal: n = !0,
        } = g,
        o = $t(I),
        [A, c] = a.useState(null),
        d = a.useRef(!1),
        i = tI(t),
        r = Li(l);
      return (
        a.useEffect(() => {
          const u = () => {
              (d.current = !0),
                document.addEventListener("pointerdown", b, {
                  capture: !0,
                  once: !0,
                }),
                document.addEventListener("pointermove", b, {
                  capture: !0,
                  once: !0,
                });
            },
            b = () => (d.current = !1);
          return (
            document.addEventListener("keydown", u, { capture: !0 }),
            () => {
              document.removeEventListener("keydown", u, { capture: !0 }),
                document.removeEventListener("pointerdown", b, { capture: !0 }),
                document.removeEventListener("pointermove", b, { capture: !0 });
            }
          );
        }, []),
        s.jsx(ea, {
          ...o,
          children: s.jsx(iG, {
            scope: I,
            open: e,
            onOpenChange: i,
            content: A,
            onContentChange: c,
            children: s.jsx(HR, {
              scope: I,
              onClose: a.useCallback(() => i(!1), [i]),
              isUsingKeyboardRef: d,
              dir: r,
              modal: n,
              children: C,
            }),
          }),
        })
      );
    };
  aG.displayName = qt;
  var wR = "MenuAnchor",
    ta = a.forwardRef((g, I) => {
      const { __scopeMenu: e, ...C } = g,
        l = $t(e);
      return s.jsx(QZ, { ...l, ...C, ref: I });
    });
  ta.displayName = wR;
  var na = "MenuPortal",
    [NR, rG] = XC(na, { forceMount: void 0 }),
    sG = (g) => {
      const { __scopeMenu: I, forceMount: e, children: C, container: l } = g,
        t = IC(na, I);
      return s.jsx(NR, {
        scope: I,
        forceMount: e,
        children: s.jsx(hl, {
          present: e || t.open,
          children: s.jsx(Ca, { asChild: !0, container: l, children: C }),
        }),
      });
    };
  sG.displayName = na;
  var SI = "MenuContent",
    [KR, oa] = XC(SI),
    uG = a.forwardRef((g, I) => {
      const e = rG(SI, g.__scopeMenu),
        { forceMount: C = e.forceMount, ...l } = g,
        t = IC(SI, g.__scopeMenu),
        n = gn(SI, g.__scopeMenu);
      return s.jsx(Wt.Provider, {
        scope: g.__scopeMenu,
        children: s.jsx(hl, {
          present: C || t.open,
          children: s.jsx(Wt.Slot, {
            scope: g.__scopeMenu,
            children: n.modal
              ? s.jsx(FR, { ...l, ref: I })
              : s.jsx(xR, { ...l, ref: I }),
          }),
        }),
      });
    }),
    FR = a.forwardRef((g, I) => {
      const e = IC(SI, g.__scopeMenu),
        C = a.useRef(null),
        l = Gg(I, C);
      return (
        a.useEffect(() => {
          const t = C.current;
          if (t) return gG(t);
        }, []),
        s.jsx(Aa, {
          ...g,
          ref: l,
          trapFocus: e.open,
          disableOutsidePointerEvents: e.open,
          disableOutsideScroll: !0,
          onFocusOutside: E(g.onFocusOutside, (t) => t.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
          onDismiss: () => e.onOpenChange(!1),
        })
      );
    }),
    xR = a.forwardRef((g, I) => {
      const e = IC(SI, g.__scopeMenu);
      return s.jsx(Aa, {
        ...g,
        ref: I,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => e.onOpenChange(!1),
      });
    }),
    Aa = a.forwardRef((g, I) => {
      const {
          __scopeMenu: e,
          loop: C = !1,
          trapFocus: l,
          onOpenAutoFocus: t,
          onCloseAutoFocus: n,
          disableOutsidePointerEvents: o,
          onEntryFocus: A,
          onEscapeKeyDown: c,
          onPointerDownOutside: d,
          onFocusOutside: i,
          onInteractOutside: r,
          onDismiss: u,
          disableOutsideScroll: b,
          ...m
        } = g,
        p = IC(SI, e),
        G = gn(SI, e),
        Z = $t(e),
        B = dG(e),
        y = fR(e),
        [h, W] = a.useState(null),
        S = a.useRef(null),
        V = Gg(I, S, p.onContentChange),
        f = a.useRef(0),
        k = a.useRef(""),
        F = a.useRef(0),
        K = a.useRef(null),
        P = a.useRef("right"),
        T = a.useRef(0),
        ng = b ? la : a.Fragment,
        z = b ? { as: ZC, allowPinchZoom: !0 } : void 0,
        gg = (X) => {
          var M, cg;
          const H = k.current + X,
            U = y().filter((rg) => !rg.disabled),
            Cg = document.activeElement,
            $g =
              (M = U.find((rg) => rg.ref.current === Cg)) == null
                ? void 0
                : M.textValue,
            Rg = U.map((rg) => rg.textValue),
            nI = _R(Rg, H, $g),
            Vg =
              (cg = U.find((rg) => rg.textValue === nI)) == null
                ? void 0
                : cg.ref.current;
          (function rg(og) {
            (k.current = og),
              window.clearTimeout(f.current),
              og !== "" && (f.current = window.setTimeout(() => rg(""), 1e3));
          })(H),
            Vg && setTimeout(() => Vg.focus());
        };
      a.useEffect(() => () => window.clearTimeout(f.current), []), SZ();
      const R = a.useCallback((X) => {
        var U, Cg;
        return (
          P.current === ((U = K.current) == null ? void 0 : U.side) &&
          $R(X, (Cg = K.current) == null ? void 0 : Cg.area)
        );
      }, []);
      return s.jsx(KR, {
        scope: e,
        searchRef: k,
        onItemEnter: a.useCallback(
          (X) => {
            R(X) && X.preventDefault();
          },
          [R]
        ),
        onItemLeave: a.useCallback(
          (X) => {
            var H;
            R(X) || ((H = S.current) == null || H.focus(), W(null));
          },
          [R]
        ),
        onTriggerLeave: a.useCallback(
          (X) => {
            R(X) && X.preventDefault();
          },
          [R]
        ),
        pointerGraceTimerRef: F,
        onPointerGraceIntentChange: a.useCallback((X) => {
          K.current = X;
        }, []),
        children: s.jsx(ng, {
          ...z,
          children: s.jsx(Ti, {
            asChild: !0,
            trapped: l,
            onMountAutoFocus: E(t, (X) => {
              var H;
              X.preventDefault(),
                (H = S.current) == null || H.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: n,
            children: s.jsx(Di, {
              asChild: !0,
              disableOutsidePointerEvents: o,
              onEscapeKeyDown: c,
              onPointerDownOutside: d,
              onFocusOutside: i,
              onInteractOutside: r,
              onDismiss: u,
              children: s.jsx(zW, {
                asChild: !0,
                ...B,
                dir: G.dir,
                orientation: "vertical",
                loop: C,
                currentTabStopId: h,
                onCurrentTabStopIdChange: W,
                onEntryFocus: E(A, (X) => {
                  G.isUsingKeyboardRef.current || X.preventDefault();
                }),
                preventScrollOnEntryFocus: !0,
                children: s.jsx(LZ, {
                  role: "menu",
                  "aria-orientation": "vertical",
                  "data-state": fG(p.open),
                  "data-radix-menu-content": "",
                  dir: G.dir,
                  ...Z,
                  ...m,
                  ref: V,
                  style: { outline: "none", ...m.style },
                  onKeyDown: E(m.onKeyDown, (X) => {
                    const U =
                        X.target.closest("[data-radix-menu-content]") ===
                        X.currentTarget,
                      Cg = X.ctrlKey || X.altKey || X.metaKey,
                      $g = X.key.length === 1;
                    U &&
                      (X.key === "Tab" && X.preventDefault(),
                      !Cg && $g && gg(X.key));
                    const Rg = S.current;
                    if (X.target !== Rg || !JR.includes(X.key)) return;
                    X.preventDefault();
                    const Vg = y()
                      .filter((M) => !M.disabled)
                      .map((M) => M.ref.current);
                    AG.includes(X.key) && Vg.reverse(), PR(Vg);
                  }),
                  onBlur: E(g.onBlur, (X) => {
                    X.currentTarget.contains(X.target) ||
                      (window.clearTimeout(f.current), (k.current = ""));
                  }),
                  onPointerMove: E(
                    g.onPointerMove,
                    Rt((X) => {
                      const H = X.target,
                        U = T.current !== X.clientX;
                      if (X.currentTarget.contains(H) && U) {
                        const Cg = X.clientX > T.current ? "right" : "left";
                        (P.current = Cg), (T.current = X.clientX);
                      }
                    })
                  ),
                }),
              }),
            }),
          }),
        }),
      });
    });
  uG.displayName = SI;
  var MR = "MenuGroup",
    ca = a.forwardRef((g, I) => {
      const { __scopeMenu: e, ...C } = g;
      return s.jsx(tg.div, { role: "group", ...C, ref: I });
    });
  ca.displayName = MR;
  var zR = "MenuLabel",
    mG = a.forwardRef((g, I) => {
      const { __scopeMenu: e, ...C } = g;
      return s.jsx(tg.div, { ...C, ref: I });
    });
  mG.displayName = zR;
  var Xo = "MenuItem",
    Gs = "menu.itemSelect",
    dA = a.forwardRef((g, I) => {
      const { disabled: e = !1, onSelect: C, ...l } = g,
        t = a.useRef(null),
        n = gn(Xo, g.__scopeMenu),
        o = oa(Xo, g.__scopeMenu),
        A = Gg(I, t),
        c = a.useRef(!1),
        d = () => {
          const i = t.current;
          if (!e && i) {
            const r = new CustomEvent(Gs, { bubbles: !0, cancelable: !0 });
            i.addEventListener(Gs, (u) => (C == null ? void 0 : C(u)), {
              once: !0,
            }),
              aZ(i, r),
              r.defaultPrevented ? (c.current = !1) : n.onClose();
          }
        };
      return s.jsx(ZG, {
        ...l,
        ref: A,
        disabled: e,
        onClick: E(g.onClick, d),
        onPointerDown: (i) => {
          var r;
          (r = g.onPointerDown) == null || r.call(g, i), (c.current = !0);
        },
        onPointerUp: E(g.onPointerUp, (i) => {
          var r;
          c.current || (r = i.currentTarget) == null || r.click();
        }),
        onKeyDown: E(g.onKeyDown, (i) => {
          const r = o.searchRef.current !== "";
          e ||
            (r && i.key === " ") ||
            (Rd.includes(i.key) &&
              (i.currentTarget.click(), i.preventDefault()));
        }),
      });
    });
  dA.displayName = Xo;
  var ZG = a.forwardRef((g, I) => {
      const { __scopeMenu: e, disabled: C = !1, textValue: l, ...t } = g,
        n = oa(Xo, e),
        o = dG(e),
        A = a.useRef(null),
        c = Gg(I, A),
        [d, i] = a.useState(!1),
        [r, u] = a.useState("");
      return (
        a.useEffect(() => {
          const b = A.current;
          b && u((b.textContent ?? "").trim());
        }, [t.children]),
        s.jsx(Wt.ItemSlot, {
          scope: e,
          disabled: C,
          textValue: l ?? r,
          children: s.jsx(EW, {
            asChild: !0,
            ...o,
            focusable: !C,
            children: s.jsx(tg.div, {
              role: "menuitem",
              "data-highlighted": d ? "" : void 0,
              "aria-disabled": C || void 0,
              "data-disabled": C ? "" : void 0,
              ...t,
              ref: c,
              onPointerMove: E(
                g.onPointerMove,
                Rt((b) => {
                  C
                    ? n.onItemLeave(b)
                    : (n.onItemEnter(b),
                      b.defaultPrevented ||
                        b.currentTarget.focus({ preventScroll: !0 }));
                })
              ),
              onPointerLeave: E(
                g.onPointerLeave,
                Rt((b) => n.onItemLeave(b))
              ),
              onFocus: E(g.onFocus, () => i(!0)),
              onBlur: E(g.onBlur, () => i(!1)),
            }),
          }),
        })
      );
    }),
    ER = "MenuCheckboxItem",
    GG = a.forwardRef((g, I) => {
      const { checked: e = !1, onCheckedChange: C, ...l } = g;
      return s.jsx(hG, {
        scope: g.__scopeMenu,
        checked: e,
        children: s.jsx(dA, {
          role: "menuitemcheckbox",
          "aria-checked": Jo(e) ? "mixed" : e,
          ...l,
          ref: I,
          "data-state": aa(e),
          onSelect: E(
            l.onSelect,
            () => (C == null ? void 0 : C(Jo(e) ? !0 : !e)),
            { checkForDefaultPrevented: !1 }
          ),
        }),
      });
    });
  GG.displayName = ER;
  var bG = "MenuRadioGroup",
    [UR, QR] = XC(bG, { value: void 0, onValueChange: () => {} }),
    BG = a.forwardRef((g, I) => {
      const { value: e, onValueChange: C, ...l } = g,
        t = tI(C);
      return s.jsx(UR, {
        scope: g.__scopeMenu,
        value: e,
        onValueChange: t,
        children: s.jsx(ca, { ...l, ref: I }),
      });
    });
  BG.displayName = bG;
  var pG = "MenuRadioItem",
    yG = a.forwardRef((g, I) => {
      const { value: e, ...C } = g,
        l = QR(pG, g.__scopeMenu),
        t = e === l.value;
      return s.jsx(hG, {
        scope: g.__scopeMenu,
        checked: t,
        children: s.jsx(dA, {
          role: "menuitemradio",
          "aria-checked": t,
          ...C,
          ref: I,
          "data-state": aa(t),
          onSelect: E(
            C.onSelect,
            () => {
              var n;
              return (n = l.onValueChange) == null ? void 0 : n.call(l, e);
            },
            { checkForDefaultPrevented: !1 }
          ),
        }),
      });
    });
  yG.displayName = pG;
  var da = "MenuItemIndicator",
    [hG, LR] = XC(da, { checked: !1 }),
    SG = a.forwardRef((g, I) => {
      const { __scopeMenu: e, forceMount: C, ...l } = g,
        t = LR(da, e);
      return s.jsx(hl, {
        present: C || Jo(t.checked) || t.checked === !0,
        children: s.jsx(tg.span, { ...l, ref: I, "data-state": aa(t.checked) }),
      });
    });
  SG.displayName = da;
  var DR = "MenuSeparator",
    VG = a.forwardRef((g, I) => {
      const { __scopeMenu: e, ...C } = g;
      return s.jsx(tg.div, {
        role: "separator",
        "aria-orientation": "horizontal",
        ...C,
        ref: I,
      });
    });
  VG.displayName = DR;
  var TR = "MenuArrow",
    WG = a.forwardRef((g, I) => {
      const { __scopeMenu: e, ...C } = g,
        l = $t(e);
      return s.jsx(DZ, { ...l, ...C, ref: I });
    });
  WG.displayName = TR;
  var ia = "MenuSub",
    [jR, RG] = XC(ia),
    XG = (g) => {
      const { __scopeMenu: I, children: e, open: C = !1, onOpenChange: l } = g,
        t = IC(ia, I),
        n = $t(I),
        [o, A] = a.useState(null),
        [c, d] = a.useState(null),
        i = tI(l);
      return (
        a.useEffect(() => (t.open === !1 && i(!1), () => i(!1)), [t.open, i]),
        s.jsx(ea, {
          ...n,
          children: s.jsx(iG, {
            scope: I,
            open: C,
            onOpenChange: i,
            content: c,
            onContentChange: d,
            children: s.jsx(jR, {
              scope: I,
              contentId: Ee(),
              triggerId: Ee(),
              trigger: o,
              onTriggerChange: A,
              children: e,
            }),
          }),
        })
      );
    };
  XG.displayName = ia;
  var Ll = "MenuSubTrigger",
    JG = a.forwardRef((g, I) => {
      const e = IC(Ll, g.__scopeMenu),
        C = gn(Ll, g.__scopeMenu),
        l = RG(Ll, g.__scopeMenu),
        t = oa(Ll, g.__scopeMenu),
        n = a.useRef(null),
        { pointerGraceTimerRef: o, onPointerGraceIntentChange: A } = t,
        c = { __scopeMenu: g.__scopeMenu },
        d = a.useCallback(() => {
          n.current && window.clearTimeout(n.current), (n.current = null);
        }, []);
      return (
        a.useEffect(() => d, [d]),
        a.useEffect(() => {
          const i = o.current;
          return () => {
            window.clearTimeout(i), A(null);
          };
        }, [o, A]),
        s.jsx(ta, {
          asChild: !0,
          ...c,
          children: s.jsx(ZG, {
            id: l.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": e.open,
            "aria-controls": l.contentId,
            "data-state": fG(e.open),
            ...g,
            ref: CA(I, l.onTriggerChange),
            onClick: (i) => {
              var r;
              (r = g.onClick) == null || r.call(g, i),
                !(g.disabled || i.defaultPrevented) &&
                  (i.currentTarget.focus(), e.open || e.onOpenChange(!0));
            },
            onPointerMove: E(
              g.onPointerMove,
              Rt((i) => {
                t.onItemEnter(i),
                  !i.defaultPrevented &&
                    !g.disabled &&
                    !e.open &&
                    !n.current &&
                    (t.onPointerGraceIntentChange(null),
                    (n.current = window.setTimeout(() => {
                      e.onOpenChange(!0), d();
                    }, 100)));
              })
            ),
            onPointerLeave: E(
              g.onPointerLeave,
              Rt((i) => {
                var u, b;
                d();
                const r =
                  (u = e.content) == null ? void 0 : u.getBoundingClientRect();
                if (r) {
                  const m = (b = e.content) == null ? void 0 : b.dataset.side,
                    p = m === "right",
                    G = p ? -5 : 5,
                    Z = r[p ? "left" : "right"],
                    B = r[p ? "right" : "left"];
                  t.onPointerGraceIntentChange({
                    area: [
                      { x: i.clientX + G, y: i.clientY },
                      { x: Z, y: r.top },
                      { x: B, y: r.top },
                      { x: B, y: r.bottom },
                      { x: Z, y: r.bottom },
                    ],
                    side: m,
                  }),
                    window.clearTimeout(o.current),
                    (o.current = window.setTimeout(
                      () => t.onPointerGraceIntentChange(null),
                      300
                    ));
                } else {
                  if ((t.onTriggerLeave(i), i.defaultPrevented)) return;
                  t.onPointerGraceIntentChange(null);
                }
              })
            ),
            onKeyDown: E(g.onKeyDown, (i) => {
              var u;
              const r = t.searchRef.current !== "";
              g.disabled ||
                (r && i.key === " ") ||
                (vR[C.dir].includes(i.key) &&
                  (e.onOpenChange(!0),
                  (u = e.content) == null || u.focus(),
                  i.preventDefault()));
            }),
          }),
        })
      );
    });
  JG.displayName = Ll;
  var vG = "MenuSubContent",
    kG = a.forwardRef((g, I) => {
      const e = rG(SI, g.__scopeMenu),
        { forceMount: C = e.forceMount, ...l } = g,
        t = IC(SI, g.__scopeMenu),
        n = gn(SI, g.__scopeMenu),
        o = RG(vG, g.__scopeMenu),
        A = a.useRef(null),
        c = Gg(I, A);
      return s.jsx(Wt.Provider, {
        scope: g.__scopeMenu,
        children: s.jsx(hl, {
          present: C || t.open,
          children: s.jsx(Wt.Slot, {
            scope: g.__scopeMenu,
            children: s.jsx(Aa, {
              id: o.contentId,
              "aria-labelledby": o.triggerId,
              ...l,
              ref: c,
              align: "start",
              side: n.dir === "rtl" ? "left" : "right",
              disableOutsidePointerEvents: !1,
              disableOutsideScroll: !1,
              trapFocus: !1,
              onOpenAutoFocus: (d) => {
                var i;
                n.isUsingKeyboardRef.current &&
                  ((i = A.current) == null || i.focus()),
                  d.preventDefault();
              },
              onCloseAutoFocus: (d) => d.preventDefault(),
              onFocusOutside: E(g.onFocusOutside, (d) => {
                d.target !== o.trigger && t.onOpenChange(!1);
              }),
              onEscapeKeyDown: E(g.onEscapeKeyDown, (d) => {
                n.onClose(), d.preventDefault();
              }),
              onKeyDown: E(g.onKeyDown, (d) => {
                var u;
                const i = d.currentTarget.contains(d.target),
                  r = kR[n.dir].includes(d.key);
                i &&
                  r &&
                  (t.onOpenChange(!1),
                  (u = o.trigger) == null || u.focus(),
                  d.preventDefault());
              }),
            }),
          }),
        }),
      });
    });
  kG.displayName = vG;
  function fG(g) {
    return g ? "open" : "closed";
  }
  function Jo(g) {
    return g === "indeterminate";
  }
  function aa(g) {
    return Jo(g) ? "indeterminate" : g ? "checked" : "unchecked";
  }
  function PR(g) {
    const I = document.activeElement;
    for (const e of g)
      if (e === I || (e.focus(), document.activeElement !== I)) return;
  }
  function OR(g, I) {
    return g.map((e, C) => g[(I + C) % g.length]);
  }
  function _R(g, I, e) {
    const l = I.length > 1 && Array.from(I).every((c) => c === I[0]) ? I[0] : I,
      t = e ? g.indexOf(e) : -1;
    let n = OR(g, Math.max(t, 0));
    l.length === 1 && (n = n.filter((c) => c !== e));
    const A = n.find((c) => c.toLowerCase().startsWith(l.toLowerCase()));
    return A !== e ? A : void 0;
  }
  function qR(g, I) {
    const { x: e, y: C } = g;
    let l = !1;
    for (let t = 0, n = I.length - 1; t < I.length; n = t++) {
      const o = I[t].x,
        A = I[t].y,
        c = I[n].x,
        d = I[n].y;
      A > C != d > C && e < ((c - o) * (C - A)) / (d - A) + o && (l = !l);
    }
    return l;
  }
  function $R(g, I) {
    if (!I) return !1;
    const e = { x: g.clientX, y: g.clientY };
    return qR(e, I);
  }
  function Rt(g) {
    return (I) => (I.pointerType === "mouse" ? g(I) : void 0);
  }
  var gX = aG,
    IX = ta,
    eX = sG,
    CX = uG,
    lX = ca,
    tX = mG,
    nX = dA,
    oX = GG,
    AX = BG,
    cX = yG,
    dX = SG,
    iX = VG,
    aX = WG,
    rX = XG,
    sX = JG,
    uX = kG,
    ra = "DropdownMenu",
    [mX, Hk] = Ot(ra, [cG]),
    Tg = cG(),
    [ZX, YG] = mX(ra),
    HG = (g) => {
      const {
          __scopeDropdownMenu: I,
          children: e,
          dir: C,
          open: l,
          defaultOpen: t,
          onOpenChange: n,
          modal: o = !0,
        } = g,
        A = Tg(I),
        c = a.useRef(null),
        [d = !1, i] = rl({ prop: l, defaultProp: t, onChange: n });
      return s.jsx(ZX, {
        scope: I,
        triggerId: Ee(),
        triggerRef: c,
        contentId: Ee(),
        open: d,
        onOpenChange: i,
        onOpenToggle: a.useCallback(() => i((r) => !r), [i]),
        modal: o,
        children: s.jsx(gX, {
          ...A,
          open: d,
          onOpenChange: i,
          dir: C,
          modal: o,
          children: e,
        }),
      });
    };
  HG.displayName = ra;
  var wG = "DropdownMenuTrigger",
    sa = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, disabled: C = !1, ...l } = g,
        t = YG(wG, e),
        n = Tg(e);
      return s.jsx(IX, {
        asChild: !0,
        ...n,
        children: s.jsx(tg.button, {
          type: "button",
          id: t.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": t.open,
          "aria-controls": t.open ? t.contentId : void 0,
          "data-state": t.open ? "open" : "closed",
          "data-disabled": C ? "" : void 0,
          disabled: C,
          ...l,
          ref: CA(I, t.triggerRef),
          onPointerDown: E(g.onPointerDown, (o) => {
            !C &&
              o.button === 0 &&
              o.ctrlKey === !1 &&
              (t.onOpenToggle(), t.open || o.preventDefault());
          }),
          onKeyDown: E(g.onKeyDown, (o) => {
            C ||
              (["Enter", " "].includes(o.key) && t.onOpenToggle(),
              o.key === "ArrowDown" && t.onOpenChange(!0),
              ["Enter", " ", "ArrowDown"].includes(o.key) &&
                o.preventDefault());
          }),
        }),
      });
    });
  sa.displayName = wG;
  var GX = "DropdownMenuPortal",
    NG = (g) => {
      const { __scopeDropdownMenu: I, ...e } = g,
        C = Tg(I);
      return s.jsx(eX, { ...C, ...e });
    };
  NG.displayName = GX;
  var KG = "DropdownMenuContent",
    FG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = YG(KG, e),
        t = Tg(e),
        n = a.useRef(!1);
      return s.jsx(CX, {
        id: l.contentId,
        "aria-labelledby": l.triggerId,
        ...t,
        ...C,
        ref: I,
        onCloseAutoFocus: E(g.onCloseAutoFocus, (o) => {
          var A;
          n.current || (A = l.triggerRef.current) == null || A.focus(),
            (n.current = !1),
            o.preventDefault();
        }),
        onInteractOutside: E(g.onInteractOutside, (o) => {
          const A = o.detail.originalEvent,
            c = A.button === 0 && A.ctrlKey === !0,
            d = A.button === 2 || c;
          (!l.modal || d) && (n.current = !0);
        }),
        style: {
          ...g.style,
          "--radix-dropdown-menu-content-transform-origin":
            "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width":
            "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height":
            "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width":
            "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height":
            "var(--radix-popper-anchor-height)",
        },
      });
    });
  FG.displayName = KG;
  var bX = "DropdownMenuGroup",
    xG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(lX, { ...l, ...C, ref: I });
    });
  xG.displayName = bX;
  var BX = "DropdownMenuLabel",
    MG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(tX, { ...l, ...C, ref: I });
    });
  MG.displayName = BX;
  var pX = "DropdownMenuItem",
    zG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(nX, { ...l, ...C, ref: I });
    });
  zG.displayName = pX;
  var yX = "DropdownMenuCheckboxItem",
    EG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(oX, { ...l, ...C, ref: I });
    });
  EG.displayName = yX;
  var hX = "DropdownMenuRadioGroup",
    UG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(AX, { ...l, ...C, ref: I });
    });
  UG.displayName = hX;
  var SX = "DropdownMenuRadioItem",
    QG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(cX, { ...l, ...C, ref: I });
    });
  QG.displayName = SX;
  var VX = "DropdownMenuItemIndicator",
    LG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(dX, { ...l, ...C, ref: I });
    });
  LG.displayName = VX;
  var WX = "DropdownMenuSeparator",
    DG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(iX, { ...l, ...C, ref: I });
    });
  DG.displayName = WX;
  var RX = "DropdownMenuArrow",
    XX = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(aX, { ...l, ...C, ref: I });
    });
  XX.displayName = RX;
  var JX = (g) => {
      const {
          __scopeDropdownMenu: I,
          children: e,
          open: C,
          onOpenChange: l,
          defaultOpen: t,
        } = g,
        n = Tg(I),
        [o = !1, A] = rl({ prop: C, defaultProp: t, onChange: l });
      return s.jsx(rX, { ...n, open: o, onOpenChange: A, children: e });
    },
    vX = "DropdownMenuSubTrigger",
    TG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(sX, { ...l, ...C, ref: I });
    });
  TG.displayName = vX;
  var kX = "DropdownMenuSubContent",
    jG = a.forwardRef((g, I) => {
      const { __scopeDropdownMenu: e, ...C } = g,
        l = Tg(e);
      return s.jsx(uX, {
        ...l,
        ...C,
        ref: I,
        style: {
          ...g.style,
          "--radix-dropdown-menu-content-transform-origin":
            "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width":
            "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height":
            "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width":
            "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height":
            "var(--radix-popper-anchor-height)",
        },
      });
    });
  jG.displayName = kX;
  var fX = HG,
    YX = sa,
    HX = NG,
    PG = FG,
    wX = xG,
    OG = MG,
    _G = zG,
    qG = EG,
    NX = UG,
    $G = QG,
    gb = LG,
    Ib = DG,
    KX = JX,
    eb = TG,
    Cb = jG;
  const iA = fX,
    ua = YX,
    FX = wX,
    xX = KX,
    MX = NX,
    lb = a.forwardRef(({ className: g, inset: I, children: e, ...C }, l) =>
      s.jsxs(eb, {
        ref: l,
        className: O(
          "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
          I && "pl-8",
          g
        ),
        ...C,
        children: [e, s.jsx(aS, { className: "ml-auto" })],
      })
    );
  lb.displayName = eb.displayName;
  const tb = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(Cb, {
      ref: e,
      className: O(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        g
      ),
      ...I,
    })
  );
  tb.displayName = Cb.displayName;
  const In = a.forwardRef(({ className: g, sideOffset: I = 4, ...e }, C) =>
    s.jsx(HX, {
      children: s.jsx(PG, {
        ref: C,
        sideOffset: I,
        className: O(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          g
        ),
        ...e,
      }),
    })
  );
  In.displayName = PG.displayName;
  const dI = a.forwardRef(({ className: g, inset: I, ...e }, C) =>
    s.jsx(_G, {
      ref: C,
      className: O(
        "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        I && "pl-8",
        g
      ),
      ...e,
    })
  );
  dI.displayName = _G.displayName;
  const nb = a.forwardRef(
    ({ className: g, children: I, checked: e, ...C }, l) =>
      s.jsxs(qG, {
        ref: l,
        className: O(
          "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
          g
        ),
        checked: e,
        ...C,
        children: [
          s.jsx("span", {
            className:
              "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
            children: s.jsx(gb, {
              children: s.jsx(Ui, { className: "h-4 w-4" }),
            }),
          }),
          I,
        ],
      })
  );
  nb.displayName = qG.displayName;
  const ob = a.forwardRef(({ className: g, children: I, ...e }, C) =>
    s.jsxs($G, {
      ref: C,
      className: O(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        g
      ),
      ...e,
      children: [
        s.jsx("span", {
          className:
            "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
          children: s.jsx(gb, {
            children: s.jsx(sS, { className: "h-2 w-2 fill-current" }),
          }),
        }),
        I,
      ],
    })
  );
  ob.displayName = $G.displayName;
  const ma = a.forwardRef(({ className: g, inset: I, ...e }, C) =>
    s.jsx(OG, {
      ref: C,
      className: O("px-2 py-1.5 text-sm font-semibold", I && "pl-8", g),
      ...e,
    })
  );
  ma.displayName = OG.displayName;
  const bC = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(Ib, { ref: e, className: O("-mx-1 my-1 h-px bg-muted", g), ...I })
  );
  bC.displayName = Ib.displayName;
  const jC = ({ className: g, ...I }) =>
    s.jsx("span", {
      className: O("ml-auto text-xs tracking-widest opacity-60", g),
      ...I,
    });
  jC.displayName = "DropdownMenuShortcut";
  function Jn({ column: g, title: I, className: e }) {
    return g.getCanSort()
      ? s.jsx("div", {
          className: O("flex items-center space-x-2", e),
          children: s.jsxs(iA, {
            children: [
              s.jsx(ua, {
                asChild: !0,
                children: s.jsxs(fg, {
                  variant: "ghost",
                  size: "sm",
                  className: "-ml-3 h-8 data-[state=open]:bg-accent",
                  children: [
                    s.jsx("span", { children: I }),
                    g.getIsSorted() === "desc"
                      ? s.jsx(Gd, { className: "ml-2 h-4 w-4" })
                      : g.getIsSorted() === "asc"
                      ? s.jsx(bd, { className: "ml-2 h-4 w-4" })
                      : s.jsx(VS, { className: "ml-2 h-4 w-4" }),
                  ],
                }),
              }),
              s.jsxs(In, {
                align: "start",
                children: [
                  s.jsxs(dI, {
                    onClick: () => g.toggleSorting(!1),
                    children: [
                      s.jsx(bd, {
                        className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70",
                      }),
                      "Asc",
                    ],
                  }),
                  s.jsxs(dI, {
                    onClick: () => g.toggleSorting(!0),
                    children: [
                      s.jsx(Gd, {
                        className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70",
                      }),
                      "Desc",
                    ],
                  }),
                  s.jsx(bC, {}),
                  s.jsxs(dI, {
                    onClick: () => g.toggleVisibility(!1),
                    children: [
                      s.jsx(LS, {
                        className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70",
                      }),
                      "Hide",
                    ],
                  }),
                ],
              }),
            ],
          }),
        })
      : s.jsx("div", { className: O(e), children: I });
  }
  var eg;
  (function (g) {
    g.assertEqual = (l) => l;
    function I(l) {}
    g.assertIs = I;
    function e(l) {
      throw new Error();
    }
    (g.assertNever = e),
      (g.arrayToEnum = (l) => {
        const t = {};
        for (const n of l) t[n] = n;
        return t;
      }),
      (g.getValidEnumValues = (l) => {
        const t = g.objectKeys(l).filter((o) => typeof l[l[o]] != "number"),
          n = {};
        for (const o of t) n[o] = l[o];
        return g.objectValues(n);
      }),
      (g.objectValues = (l) =>
        g.objectKeys(l).map(function (t) {
          return l[t];
        })),
      (g.objectKeys =
        typeof Object.keys == "function"
          ? (l) => Object.keys(l)
          : (l) => {
              const t = [];
              for (const n in l)
                Object.prototype.hasOwnProperty.call(l, n) && t.push(n);
              return t;
            }),
      (g.find = (l, t) => {
        for (const n of l) if (t(n)) return n;
      }),
      (g.isInteger =
        typeof Number.isInteger == "function"
          ? (l) => Number.isInteger(l)
          : (l) => typeof l == "number" && isFinite(l) && Math.floor(l) === l);
    function C(l, t = " | ") {
      return l.map((n) => (typeof n == "string" ? `'${n}'` : n)).join(t);
    }
    (g.joinValues = C),
      (g.jsonStringifyReplacer = (l, t) =>
        typeof t == "bigint" ? t.toString() : t);
  })(eg || (eg = {}));
  var Xd;
  (function (g) {
    g.mergeShapes = (I, e) => ({ ...I, ...e });
  })(Xd || (Xd = {}));
  const w = eg.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set",
    ]),
    Ve = (g) => {
      switch (typeof g) {
        case "undefined":
          return w.undefined;
        case "string":
          return w.string;
        case "number":
          return isNaN(g) ? w.nan : w.number;
        case "boolean":
          return w.boolean;
        case "function":
          return w.function;
        case "bigint":
          return w.bigint;
        case "symbol":
          return w.symbol;
        case "object":
          return Array.isArray(g)
            ? w.array
            : g === null
            ? w.null
            : g.then &&
              typeof g.then == "function" &&
              g.catch &&
              typeof g.catch == "function"
            ? w.promise
            : typeof Map < "u" && g instanceof Map
            ? w.map
            : typeof Set < "u" && g instanceof Set
            ? w.set
            : typeof Date < "u" && g instanceof Date
            ? w.date
            : w.object;
        default:
          return w.unknown;
      }
    },
    v = eg.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite",
    ]),
    zX = (g) => JSON.stringify(g, null, 2).replace(/"([^"]+)":/g, "$1:");
  class sI extends Error {
    constructor(I) {
      super(),
        (this.issues = []),
        (this.addIssue = (C) => {
          this.issues = [...this.issues, C];
        }),
        (this.addIssues = (C = []) => {
          this.issues = [...this.issues, ...C];
        });
      const e = new.target.prototype;
      Object.setPrototypeOf
        ? Object.setPrototypeOf(this, e)
        : (this.__proto__ = e),
        (this.name = "ZodError"),
        (this.issues = I);
    }
    get errors() {
      return this.issues;
    }
    format(I) {
      const e =
          I ||
          function (t) {
            return t.message;
          },
        C = { _errors: [] },
        l = (t) => {
          for (const n of t.issues)
            if (n.code === "invalid_union") n.unionErrors.map(l);
            else if (n.code === "invalid_return_type") l(n.returnTypeError);
            else if (n.code === "invalid_arguments") l(n.argumentsError);
            else if (n.path.length === 0) C._errors.push(e(n));
            else {
              let o = C,
                A = 0;
              for (; A < n.path.length; ) {
                const c = n.path[A];
                A === n.path.length - 1
                  ? ((o[c] = o[c] || { _errors: [] }), o[c]._errors.push(e(n)))
                  : (o[c] = o[c] || { _errors: [] }),
                  (o = o[c]),
                  A++;
              }
            }
        };
      return l(this), C;
    }
    static assert(I) {
      if (!(I instanceof sI)) throw new Error(`Not a ZodError: ${I}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, eg.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(I = (e) => e.message) {
      const e = {},
        C = [];
      for (const l of this.issues)
        l.path.length > 0
          ? ((e[l.path[0]] = e[l.path[0]] || []), e[l.path[0]].push(I(l)))
          : C.push(I(l));
      return { formErrors: C, fieldErrors: e };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  sI.create = (g) => new sI(g);
  const ul = (g, I) => {
    let e;
    switch (g.code) {
      case v.invalid_type:
        g.received === w.undefined
          ? (e = "Required")
          : (e = `Expected ${g.expected}, received ${g.received}`);
        break;
      case v.invalid_literal:
        e = `Invalid literal value, expected ${JSON.stringify(
          g.expected,
          eg.jsonStringifyReplacer
        )}`;
        break;
      case v.unrecognized_keys:
        e = `Unrecognized key(s) in object: ${eg.joinValues(g.keys, ", ")}`;
        break;
      case v.invalid_union:
        e = "Invalid input";
        break;
      case v.invalid_union_discriminator:
        e = `Invalid discriminator value. Expected ${eg.joinValues(g.options)}`;
        break;
      case v.invalid_enum_value:
        e = `Invalid enum value. Expected ${eg.joinValues(
          g.options
        )}, received '${g.received}'`;
        break;
      case v.invalid_arguments:
        e = "Invalid function arguments";
        break;
      case v.invalid_return_type:
        e = "Invalid function return type";
        break;
      case v.invalid_date:
        e = "Invalid date";
        break;
      case v.invalid_string:
        typeof g.validation == "object"
          ? "includes" in g.validation
            ? ((e = `Invalid input: must include "${g.validation.includes}"`),
              typeof g.validation.position == "number" &&
                (e = `${e} at one or more positions greater than or equal to ${g.validation.position}`))
            : "startsWith" in g.validation
            ? (e = `Invalid input: must start with "${g.validation.startsWith}"`)
            : "endsWith" in g.validation
            ? (e = `Invalid input: must end with "${g.validation.endsWith}"`)
            : eg.assertNever(g.validation)
          : g.validation !== "regex"
          ? (e = `Invalid ${g.validation}`)
          : (e = "Invalid");
        break;
      case v.too_small:
        g.type === "array"
          ? (e = `Array must contain ${
              g.exact ? "exactly" : g.inclusive ? "at least" : "more than"
            } ${g.minimum} element(s)`)
          : g.type === "string"
          ? (e = `String must contain ${
              g.exact ? "exactly" : g.inclusive ? "at least" : "over"
            } ${g.minimum} character(s)`)
          : g.type === "number"
          ? (e = `Number must be ${
              g.exact
                ? "exactly equal to "
                : g.inclusive
                ? "greater than or equal to "
                : "greater than "
            }${g.minimum}`)
          : g.type === "date"
          ? (e = `Date must be ${
              g.exact
                ? "exactly equal to "
                : g.inclusive
                ? "greater than or equal to "
                : "greater than "
            }${new Date(Number(g.minimum))}`)
          : (e = "Invalid input");
        break;
      case v.too_big:
        g.type === "array"
          ? (e = `Array must contain ${
              g.exact ? "exactly" : g.inclusive ? "at most" : "less than"
            } ${g.maximum} element(s)`)
          : g.type === "string"
          ? (e = `String must contain ${
              g.exact ? "exactly" : g.inclusive ? "at most" : "under"
            } ${g.maximum} character(s)`)
          : g.type === "number"
          ? (e = `Number must be ${
              g.exact
                ? "exactly"
                : g.inclusive
                ? "less than or equal to"
                : "less than"
            } ${g.maximum}`)
          : g.type === "bigint"
          ? (e = `BigInt must be ${
              g.exact
                ? "exactly"
                : g.inclusive
                ? "less than or equal to"
                : "less than"
            } ${g.maximum}`)
          : g.type === "date"
          ? (e = `Date must be ${
              g.exact
                ? "exactly"
                : g.inclusive
                ? "smaller than or equal to"
                : "smaller than"
            } ${new Date(Number(g.maximum))}`)
          : (e = "Invalid input");
        break;
      case v.custom:
        e = "Invalid input";
        break;
      case v.invalid_intersection_types:
        e = "Intersection results could not be merged";
        break;
      case v.not_multiple_of:
        e = `Number must be a multiple of ${g.multipleOf}`;
        break;
      case v.not_finite:
        e = "Number must be finite";
        break;
      default:
        (e = I.defaultError), eg.assertNever(g);
    }
    return { message: e };
  };
  let Ab = ul;
  function EX(g) {
    Ab = g;
  }
  function vo() {
    return Ab;
  }
  const ko = (g) => {
      const { data: I, path: e, errorMaps: C, issueData: l } = g,
        t = [...e, ...(l.path || [])],
        n = { ...l, path: t };
      if (l.message !== void 0) return { ...l, path: t, message: l.message };
      let o = "";
      const A = C.filter((c) => !!c)
        .slice()
        .reverse();
      for (const c of A) o = c(n, { data: I, defaultError: o }).message;
      return { ...l, path: t, message: o };
    },
    UX = [];
  function Y(g, I) {
    const e = vo(),
      C = ko({
        issueData: I,
        data: g.data,
        path: g.path,
        errorMaps: [
          g.common.contextualErrorMap,
          g.schemaErrorMap,
          e,
          e === ul ? void 0 : ul,
        ].filter((l) => !!l),
      });
    g.common.issues.push(C);
  }
  class Dg {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(I, e) {
      const C = [];
      for (const l of e) {
        if (l.status === "aborted") return j;
        l.status === "dirty" && I.dirty(), C.push(l.value);
      }
      return { status: I.value, value: C };
    }
    static async mergeObjectAsync(I, e) {
      const C = [];
      for (const l of e) {
        const t = await l.key,
          n = await l.value;
        C.push({ key: t, value: n });
      }
      return Dg.mergeObjectSync(I, C);
    }
    static mergeObjectSync(I, e) {
      const C = {};
      for (const l of e) {
        const { key: t, value: n } = l;
        if (t.status === "aborted" || n.status === "aborted") return j;
        t.status === "dirty" && I.dirty(),
          n.status === "dirty" && I.dirty(),
          t.value !== "__proto__" &&
            (typeof n.value < "u" || l.alwaysSet) &&
            (C[t.value] = n.value);
      }
      return { status: I.value, value: C };
    }
  }
  const j = Object.freeze({ status: "aborted" }),
    PC = (g) => ({ status: "dirty", value: g }),
    Og = (g) => ({ status: "valid", value: g }),
    Jd = (g) => g.status === "aborted",
    vd = (g) => g.status === "dirty",
    Xt = (g) => g.status === "valid",
    Jt = (g) => typeof Promise < "u" && g instanceof Promise;
  function fo(g, I, e, C) {
    if (typeof I == "function" ? g !== I || !C : !I.has(g))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return I.get(g);
  }
  function cb(g, I, e, C, l) {
    if (typeof I == "function" ? g !== I || !l : !I.has(g))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it"
      );
    return I.set(g, e), e;
  }
  var x;
  (function (g) {
    (g.errToObj = (I) => (typeof I == "string" ? { message: I } : I || {})),
      (g.toString = (I) =>
        typeof I == "string" ? I : I == null ? void 0 : I.message);
  })(x || (x = {}));
  var Dl, Tl;
  class _I {
    constructor(I, e, C, l) {
      (this._cachedPath = []),
        (this.parent = I),
        (this.data = e),
        (this._path = C),
        (this._key = l);
    }
    get path() {
      return (
        this._cachedPath.length ||
          (this._key instanceof Array
            ? this._cachedPath.push(...this._path, ...this._key)
            : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
      );
    }
  }
  const bs = (g, I) => {
    if (Xt(I)) return { success: !0, data: I.value };
    if (!g.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        const e = new sI(g.common.issues);
        return (this._error = e), this._error;
      },
    };
  };
  function _(g) {
    if (!g) return {};
    const {
      errorMap: I,
      invalid_type_error: e,
      required_error: C,
      description: l,
    } = g;
    if (I && (e || C))
      throw new Error(
        `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
      );
    return I
      ? { errorMap: I, description: l }
      : {
          errorMap: (n, o) => {
            var A, c;
            const { message: d } = g;
            return n.code === "invalid_enum_value"
              ? { message: d ?? o.defaultError }
              : typeof o.data > "u"
              ? {
                  message:
                    (A = d ?? C) !== null && A !== void 0 ? A : o.defaultError,
                }
              : n.code !== "invalid_type"
              ? { message: o.defaultError }
              : {
                  message:
                    (c = d ?? e) !== null && c !== void 0 ? c : o.defaultError,
                };
          },
          description: l,
        };
  }
  class $ {
    constructor(I) {
      (this.spa = this.safeParseAsync),
        (this._def = I),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this));
    }
    get description() {
      return this._def.description;
    }
    _getType(I) {
      return Ve(I.data);
    }
    _getOrReturnCtx(I, e) {
      return (
        e || {
          common: I.parent.common,
          data: I.data,
          parsedType: Ve(I.data),
          schemaErrorMap: this._def.errorMap,
          path: I.path,
          parent: I.parent,
        }
      );
    }
    _processInputParams(I) {
      return {
        status: new Dg(),
        ctx: {
          common: I.parent.common,
          data: I.data,
          parsedType: Ve(I.data),
          schemaErrorMap: this._def.errorMap,
          path: I.path,
          parent: I.parent,
        },
      };
    }
    _parseSync(I) {
      const e = this._parse(I);
      if (Jt(e)) throw new Error("Synchronous parse encountered promise.");
      return e;
    }
    _parseAsync(I) {
      const e = this._parse(I);
      return Promise.resolve(e);
    }
    parse(I, e) {
      const C = this.safeParse(I, e);
      if (C.success) return C.data;
      throw C.error;
    }
    safeParse(I, e) {
      var C;
      const l = {
          common: {
            issues: [],
            async:
              (C = e == null ? void 0 : e.async) !== null && C !== void 0
                ? C
                : !1,
            contextualErrorMap: e == null ? void 0 : e.errorMap,
          },
          path: (e == null ? void 0 : e.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: I,
          parsedType: Ve(I),
        },
        t = this._parseSync({ data: I, path: l.path, parent: l });
      return bs(l, t);
    }
    async parseAsync(I, e) {
      const C = await this.safeParseAsync(I, e);
      if (C.success) return C.data;
      throw C.error;
    }
    async safeParseAsync(I, e) {
      const C = {
          common: {
            issues: [],
            contextualErrorMap: e == null ? void 0 : e.errorMap,
            async: !0,
          },
          path: (e == null ? void 0 : e.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: I,
          parsedType: Ve(I),
        },
        l = this._parse({ data: I, path: C.path, parent: C }),
        t = await (Jt(l) ? l : Promise.resolve(l));
      return bs(C, t);
    }
    refine(I, e) {
      const C = (l) =>
        typeof e == "string" || typeof e > "u"
          ? { message: e }
          : typeof e == "function"
          ? e(l)
          : e;
      return this._refinement((l, t) => {
        const n = I(l),
          o = () => t.addIssue({ code: v.custom, ...C(l) });
        return typeof Promise < "u" && n instanceof Promise
          ? n.then((A) => (A ? !0 : (o(), !1)))
          : n
          ? !0
          : (o(), !1);
      });
    }
    refinement(I, e) {
      return this._refinement((C, l) =>
        I(C) ? !0 : (l.addIssue(typeof e == "function" ? e(C, l) : e), !1)
      );
    }
    _refinement(I) {
      return new zI({
        schema: this,
        typeName: D.ZodEffects,
        effect: { type: "refinement", refinement: I },
      });
    }
    superRefine(I) {
      return this._refinement(I);
    }
    optional() {
      return PI.create(this, this._def);
    }
    nullable() {
      return Oe.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return NI.create(this, this._def);
    }
    promise() {
      return Zl.create(this, this._def);
    }
    or(I) {
      return Yt.create([this, I], this._def);
    }
    and(I) {
      return Ht.create(this, I, this._def);
    }
    transform(I) {
      return new zI({
        ..._(this._def),
        schema: this,
        typeName: D.ZodEffects,
        effect: { type: "transform", transform: I },
      });
    }
    default(I) {
      const e = typeof I == "function" ? I : () => I;
      return new xt({
        ..._(this._def),
        innerType: this,
        defaultValue: e,
        typeName: D.ZodDefault,
      });
    }
    brand() {
      return new Za({ typeName: D.ZodBranded, type: this, ..._(this._def) });
    }
    catch(I) {
      const e = typeof I == "function" ? I : () => I;
      return new Mt({
        ..._(this._def),
        innerType: this,
        catchValue: e,
        typeName: D.ZodCatch,
      });
    }
    describe(I) {
      const e = this.constructor;
      return new e({ ...this._def, description: I });
    }
    pipe(I) {
      return en.create(this, I);
    }
    readonly() {
      return zt.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const QX = /^c[^\s-]{8,}$/i,
    LX = /^[0-9a-z]+$/,
    DX = /^[0-9A-HJKMNP-TV-Z]{26}$/,
    TX =
      /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    jX = /^[a-z0-9_-]{21}$/i,
    PX =
      /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    OX =
      /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    _X = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let ic;
  const qX =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    $X =
      /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    gJ = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    db =
      "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
    IJ = new RegExp(`^${db}$`);
  function ib(g) {
    let I = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return (
      g.precision
        ? (I = `${I}\\.\\d{${g.precision}}`)
        : g.precision == null && (I = `${I}(\\.\\d+)?`),
      I
    );
  }
  function eJ(g) {
    return new RegExp(`^${ib(g)}$`);
  }
  function ab(g) {
    let I = `${db}T${ib(g)}`;
    const e = [];
    return (
      e.push(g.local ? "Z?" : "Z"),
      g.offset && e.push("([+-]\\d{2}:?\\d{2})"),
      (I = `${I}(${e.join("|")})`),
      new RegExp(`^${I}$`)
    );
  }
  function CJ(g, I) {
    return !!(
      ((I === "v4" || !I) && qX.test(g)) ||
      ((I === "v6" || !I) && $X.test(g))
    );
  }
  class YI extends $ {
    _parse(I) {
      if (
        (this._def.coerce && (I.data = String(I.data)),
        this._getType(I) !== w.string)
      ) {
        const t = this._getOrReturnCtx(I);
        return (
          Y(t, {
            code: v.invalid_type,
            expected: w.string,
            received: t.parsedType,
          }),
          j
        );
      }
      const C = new Dg();
      let l;
      for (const t of this._def.checks)
        if (t.kind === "min")
          I.data.length < t.value &&
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              code: v.too_small,
              minimum: t.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "max")
          I.data.length > t.value &&
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              code: v.too_big,
              maximum: t.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "length") {
          const n = I.data.length > t.value,
            o = I.data.length < t.value;
          (n || o) &&
            ((l = this._getOrReturnCtx(I, l)),
            n
              ? Y(l, {
                  code: v.too_big,
                  maximum: t.value,
                  type: "string",
                  inclusive: !0,
                  exact: !0,
                  message: t.message,
                })
              : o &&
                Y(l, {
                  code: v.too_small,
                  minimum: t.value,
                  type: "string",
                  inclusive: !0,
                  exact: !0,
                  message: t.message,
                }),
            C.dirty());
        } else if (t.kind === "email")
          OX.test(I.data) ||
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              validation: "email",
              code: v.invalid_string,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "emoji")
          ic || (ic = new RegExp(_X, "u")),
            ic.test(I.data) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                validation: "emoji",
                code: v.invalid_string,
                message: t.message,
              }),
              C.dirty());
        else if (t.kind === "uuid")
          TX.test(I.data) ||
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              validation: "uuid",
              code: v.invalid_string,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "nanoid")
          jX.test(I.data) ||
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              validation: "nanoid",
              code: v.invalid_string,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "cuid")
          QX.test(I.data) ||
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              validation: "cuid",
              code: v.invalid_string,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "cuid2")
          LX.test(I.data) ||
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              validation: "cuid2",
              code: v.invalid_string,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "ulid")
          DX.test(I.data) ||
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              validation: "ulid",
              code: v.invalid_string,
              message: t.message,
            }),
            C.dirty());
        else if (t.kind === "url")
          try {
            new URL(I.data);
          } catch {
            (l = this._getOrReturnCtx(I, l)),
              Y(l, {
                validation: "url",
                code: v.invalid_string,
                message: t.message,
              }),
              C.dirty();
          }
        else
          t.kind === "regex"
            ? ((t.regex.lastIndex = 0),
              t.regex.test(I.data) ||
                ((l = this._getOrReturnCtx(I, l)),
                Y(l, {
                  validation: "regex",
                  code: v.invalid_string,
                  message: t.message,
                }),
                C.dirty()))
            : t.kind === "trim"
            ? (I.data = I.data.trim())
            : t.kind === "includes"
            ? I.data.includes(t.value, t.position) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                code: v.invalid_string,
                validation: { includes: t.value, position: t.position },
                message: t.message,
              }),
              C.dirty())
            : t.kind === "toLowerCase"
            ? (I.data = I.data.toLowerCase())
            : t.kind === "toUpperCase"
            ? (I.data = I.data.toUpperCase())
            : t.kind === "startsWith"
            ? I.data.startsWith(t.value) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                code: v.invalid_string,
                validation: { startsWith: t.value },
                message: t.message,
              }),
              C.dirty())
            : t.kind === "endsWith"
            ? I.data.endsWith(t.value) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                code: v.invalid_string,
                validation: { endsWith: t.value },
                message: t.message,
              }),
              C.dirty())
            : t.kind === "datetime"
            ? ab(t).test(I.data) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                code: v.invalid_string,
                validation: "datetime",
                message: t.message,
              }),
              C.dirty())
            : t.kind === "date"
            ? IJ.test(I.data) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                code: v.invalid_string,
                validation: "date",
                message: t.message,
              }),
              C.dirty())
            : t.kind === "time"
            ? eJ(t).test(I.data) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                code: v.invalid_string,
                validation: "time",
                message: t.message,
              }),
              C.dirty())
            : t.kind === "duration"
            ? PX.test(I.data) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                validation: "duration",
                code: v.invalid_string,
                message: t.message,
              }),
              C.dirty())
            : t.kind === "ip"
            ? CJ(I.data, t.version) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                validation: "ip",
                code: v.invalid_string,
                message: t.message,
              }),
              C.dirty())
            : t.kind === "base64"
            ? gJ.test(I.data) ||
              ((l = this._getOrReturnCtx(I, l)),
              Y(l, {
                validation: "base64",
                code: v.invalid_string,
                message: t.message,
              }),
              C.dirty())
            : eg.assertNever(t);
      return { status: C.value, value: I.data };
    }
    _regex(I, e, C) {
      return this.refinement((l) => I.test(l), {
        validation: e,
        code: v.invalid_string,
        ...x.errToObj(C),
      });
    }
    _addCheck(I) {
      return new YI({ ...this._def, checks: [...this._def.checks, I] });
    }
    email(I) {
      return this._addCheck({ kind: "email", ...x.errToObj(I) });
    }
    url(I) {
      return this._addCheck({ kind: "url", ...x.errToObj(I) });
    }
    emoji(I) {
      return this._addCheck({ kind: "emoji", ...x.errToObj(I) });
    }
    uuid(I) {
      return this._addCheck({ kind: "uuid", ...x.errToObj(I) });
    }
    nanoid(I) {
      return this._addCheck({ kind: "nanoid", ...x.errToObj(I) });
    }
    cuid(I) {
      return this._addCheck({ kind: "cuid", ...x.errToObj(I) });
    }
    cuid2(I) {
      return this._addCheck({ kind: "cuid2", ...x.errToObj(I) });
    }
    ulid(I) {
      return this._addCheck({ kind: "ulid", ...x.errToObj(I) });
    }
    base64(I) {
      return this._addCheck({ kind: "base64", ...x.errToObj(I) });
    }
    ip(I) {
      return this._addCheck({ kind: "ip", ...x.errToObj(I) });
    }
    datetime(I) {
      var e, C;
      return typeof I == "string"
        ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: I,
          })
        : this._addCheck({
            kind: "datetime",
            precision:
              typeof (I == null ? void 0 : I.precision) > "u"
                ? null
                : I == null
                ? void 0
                : I.precision,
            offset:
              (e = I == null ? void 0 : I.offset) !== null && e !== void 0
                ? e
                : !1,
            local:
              (C = I == null ? void 0 : I.local) !== null && C !== void 0
                ? C
                : !1,
            ...x.errToObj(I == null ? void 0 : I.message),
          });
    }
    date(I) {
      return this._addCheck({ kind: "date", message: I });
    }
    time(I) {
      return typeof I == "string"
        ? this._addCheck({ kind: "time", precision: null, message: I })
        : this._addCheck({
            kind: "time",
            precision:
              typeof (I == null ? void 0 : I.precision) > "u"
                ? null
                : I == null
                ? void 0
                : I.precision,
            ...x.errToObj(I == null ? void 0 : I.message),
          });
    }
    duration(I) {
      return this._addCheck({ kind: "duration", ...x.errToObj(I) });
    }
    regex(I, e) {
      return this._addCheck({ kind: "regex", regex: I, ...x.errToObj(e) });
    }
    includes(I, e) {
      return this._addCheck({
        kind: "includes",
        value: I,
        position: e == null ? void 0 : e.position,
        ...x.errToObj(e == null ? void 0 : e.message),
      });
    }
    startsWith(I, e) {
      return this._addCheck({ kind: "startsWith", value: I, ...x.errToObj(e) });
    }
    endsWith(I, e) {
      return this._addCheck({ kind: "endsWith", value: I, ...x.errToObj(e) });
    }
    min(I, e) {
      return this._addCheck({ kind: "min", value: I, ...x.errToObj(e) });
    }
    max(I, e) {
      return this._addCheck({ kind: "max", value: I, ...x.errToObj(e) });
    }
    length(I, e) {
      return this._addCheck({ kind: "length", value: I, ...x.errToObj(e) });
    }
    nonempty(I) {
      return this.min(1, x.errToObj(I));
    }
    trim() {
      return new YI({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }],
      });
    }
    toLowerCase() {
      return new YI({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }],
      });
    }
    toUpperCase() {
      return new YI({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }],
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((I) => I.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((I) => I.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((I) => I.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((I) => I.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((I) => I.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((I) => I.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((I) => I.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((I) => I.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((I) => I.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((I) => I.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((I) => I.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((I) => I.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((I) => I.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((I) => I.kind === "base64");
    }
    get minLength() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "min" && (I === null || e.value > I) && (I = e.value);
      return I;
    }
    get maxLength() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "max" && (I === null || e.value < I) && (I = e.value);
      return I;
    }
  }
  YI.create = (g) => {
    var I;
    return new YI({
      checks: [],
      typeName: D.ZodString,
      coerce:
        (I = g == null ? void 0 : g.coerce) !== null && I !== void 0 ? I : !1,
      ..._(g),
    });
  };
  function lJ(g, I) {
    const e = (g.toString().split(".")[1] || "").length,
      C = (I.toString().split(".")[1] || "").length,
      l = e > C ? e : C,
      t = parseInt(g.toFixed(l).replace(".", "")),
      n = parseInt(I.toFixed(l).replace(".", ""));
    return (t % n) / Math.pow(10, l);
  }
  class Te extends $ {
    constructor() {
      super(...arguments),
        (this.min = this.gte),
        (this.max = this.lte),
        (this.step = this.multipleOf);
    }
    _parse(I) {
      if (
        (this._def.coerce && (I.data = Number(I.data)),
        this._getType(I) !== w.number)
      ) {
        const t = this._getOrReturnCtx(I);
        return (
          Y(t, {
            code: v.invalid_type,
            expected: w.number,
            received: t.parsedType,
          }),
          j
        );
      }
      let C;
      const l = new Dg();
      for (const t of this._def.checks)
        t.kind === "int"
          ? eg.isInteger(I.data) ||
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.invalid_type,
              expected: "integer",
              received: "float",
              message: t.message,
            }),
            l.dirty())
          : t.kind === "min"
          ? (t.inclusive ? I.data < t.value : I.data <= t.value) &&
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.too_small,
              minimum: t.value,
              type: "number",
              inclusive: t.inclusive,
              exact: !1,
              message: t.message,
            }),
            l.dirty())
          : t.kind === "max"
          ? (t.inclusive ? I.data > t.value : I.data >= t.value) &&
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.too_big,
              maximum: t.value,
              type: "number",
              inclusive: t.inclusive,
              exact: !1,
              message: t.message,
            }),
            l.dirty())
          : t.kind === "multipleOf"
          ? lJ(I.data, t.value) !== 0 &&
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.not_multiple_of,
              multipleOf: t.value,
              message: t.message,
            }),
            l.dirty())
          : t.kind === "finite"
          ? Number.isFinite(I.data) ||
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, { code: v.not_finite, message: t.message }),
            l.dirty())
          : eg.assertNever(t);
      return { status: l.value, value: I.data };
    }
    gte(I, e) {
      return this.setLimit("min", I, !0, x.toString(e));
    }
    gt(I, e) {
      return this.setLimit("min", I, !1, x.toString(e));
    }
    lte(I, e) {
      return this.setLimit("max", I, !0, x.toString(e));
    }
    lt(I, e) {
      return this.setLimit("max", I, !1, x.toString(e));
    }
    setLimit(I, e, C, l) {
      return new Te({
        ...this._def,
        checks: [
          ...this._def.checks,
          { kind: I, value: e, inclusive: C, message: x.toString(l) },
        ],
      });
    }
    _addCheck(I) {
      return new Te({ ...this._def, checks: [...this._def.checks, I] });
    }
    int(I) {
      return this._addCheck({ kind: "int", message: x.toString(I) });
    }
    positive(I) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: x.toString(I),
      });
    }
    negative(I) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: x.toString(I),
      });
    }
    nonpositive(I) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: x.toString(I),
      });
    }
    nonnegative(I) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: x.toString(I),
      });
    }
    multipleOf(I, e) {
      return this._addCheck({
        kind: "multipleOf",
        value: I,
        message: x.toString(e),
      });
    }
    finite(I) {
      return this._addCheck({ kind: "finite", message: x.toString(I) });
    }
    safe(I) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: x.toString(I),
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: x.toString(I),
      });
    }
    get minValue() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "min" && (I === null || e.value > I) && (I = e.value);
      return I;
    }
    get maxValue() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "max" && (I === null || e.value < I) && (I = e.value);
      return I;
    }
    get isInt() {
      return !!this._def.checks.find(
        (I) =>
          I.kind === "int" || (I.kind === "multipleOf" && eg.isInteger(I.value))
      );
    }
    get isFinite() {
      let I = null,
        e = null;
      for (const C of this._def.checks) {
        if (C.kind === "finite" || C.kind === "int" || C.kind === "multipleOf")
          return !0;
        C.kind === "min"
          ? (e === null || C.value > e) && (e = C.value)
          : C.kind === "max" && (I === null || C.value < I) && (I = C.value);
      }
      return Number.isFinite(e) && Number.isFinite(I);
    }
  }
  Te.create = (g) =>
    new Te({
      checks: [],
      typeName: D.ZodNumber,
      coerce: (g == null ? void 0 : g.coerce) || !1,
      ..._(g),
    });
  class je extends $ {
    constructor() {
      super(...arguments), (this.min = this.gte), (this.max = this.lte);
    }
    _parse(I) {
      if (
        (this._def.coerce && (I.data = BigInt(I.data)),
        this._getType(I) !== w.bigint)
      ) {
        const t = this._getOrReturnCtx(I);
        return (
          Y(t, {
            code: v.invalid_type,
            expected: w.bigint,
            received: t.parsedType,
          }),
          j
        );
      }
      let C;
      const l = new Dg();
      for (const t of this._def.checks)
        t.kind === "min"
          ? (t.inclusive ? I.data < t.value : I.data <= t.value) &&
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.too_small,
              type: "bigint",
              minimum: t.value,
              inclusive: t.inclusive,
              message: t.message,
            }),
            l.dirty())
          : t.kind === "max"
          ? (t.inclusive ? I.data > t.value : I.data >= t.value) &&
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.too_big,
              type: "bigint",
              maximum: t.value,
              inclusive: t.inclusive,
              message: t.message,
            }),
            l.dirty())
          : t.kind === "multipleOf"
          ? I.data % t.value !== BigInt(0) &&
            ((C = this._getOrReturnCtx(I, C)),
            Y(C, {
              code: v.not_multiple_of,
              multipleOf: t.value,
              message: t.message,
            }),
            l.dirty())
          : eg.assertNever(t);
      return { status: l.value, value: I.data };
    }
    gte(I, e) {
      return this.setLimit("min", I, !0, x.toString(e));
    }
    gt(I, e) {
      return this.setLimit("min", I, !1, x.toString(e));
    }
    lte(I, e) {
      return this.setLimit("max", I, !0, x.toString(e));
    }
    lt(I, e) {
      return this.setLimit("max", I, !1, x.toString(e));
    }
    setLimit(I, e, C, l) {
      return new je({
        ...this._def,
        checks: [
          ...this._def.checks,
          { kind: I, value: e, inclusive: C, message: x.toString(l) },
        ],
      });
    }
    _addCheck(I) {
      return new je({ ...this._def, checks: [...this._def.checks, I] });
    }
    positive(I) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: x.toString(I),
      });
    }
    negative(I) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: x.toString(I),
      });
    }
    nonpositive(I) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: x.toString(I),
      });
    }
    nonnegative(I) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: x.toString(I),
      });
    }
    multipleOf(I, e) {
      return this._addCheck({
        kind: "multipleOf",
        value: I,
        message: x.toString(e),
      });
    }
    get minValue() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "min" && (I === null || e.value > I) && (I = e.value);
      return I;
    }
    get maxValue() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "max" && (I === null || e.value < I) && (I = e.value);
      return I;
    }
  }
  je.create = (g) => {
    var I;
    return new je({
      checks: [],
      typeName: D.ZodBigInt,
      coerce:
        (I = g == null ? void 0 : g.coerce) !== null && I !== void 0 ? I : !1,
      ..._(g),
    });
  };
  class vt extends $ {
    _parse(I) {
      if (
        (this._def.coerce && (I.data = !!I.data),
        this._getType(I) !== w.boolean)
      ) {
        const C = this._getOrReturnCtx(I);
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.boolean,
            received: C.parsedType,
          }),
          j
        );
      }
      return Og(I.data);
    }
  }
  vt.create = (g) =>
    new vt({
      typeName: D.ZodBoolean,
      coerce: (g == null ? void 0 : g.coerce) || !1,
      ..._(g),
    });
  class BC extends $ {
    _parse(I) {
      if (
        (this._def.coerce && (I.data = new Date(I.data)),
        this._getType(I) !== w.date)
      ) {
        const t = this._getOrReturnCtx(I);
        return (
          Y(t, {
            code: v.invalid_type,
            expected: w.date,
            received: t.parsedType,
          }),
          j
        );
      }
      if (isNaN(I.data.getTime())) {
        const t = this._getOrReturnCtx(I);
        return Y(t, { code: v.invalid_date }), j;
      }
      const C = new Dg();
      let l;
      for (const t of this._def.checks)
        t.kind === "min"
          ? I.data.getTime() < t.value &&
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              code: v.too_small,
              message: t.message,
              inclusive: !0,
              exact: !1,
              minimum: t.value,
              type: "date",
            }),
            C.dirty())
          : t.kind === "max"
          ? I.data.getTime() > t.value &&
            ((l = this._getOrReturnCtx(I, l)),
            Y(l, {
              code: v.too_big,
              message: t.message,
              inclusive: !0,
              exact: !1,
              maximum: t.value,
              type: "date",
            }),
            C.dirty())
          : eg.assertNever(t);
      return { status: C.value, value: new Date(I.data.getTime()) };
    }
    _addCheck(I) {
      return new BC({ ...this._def, checks: [...this._def.checks, I] });
    }
    min(I, e) {
      return this._addCheck({
        kind: "min",
        value: I.getTime(),
        message: x.toString(e),
      });
    }
    max(I, e) {
      return this._addCheck({
        kind: "max",
        value: I.getTime(),
        message: x.toString(e),
      });
    }
    get minDate() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "min" && (I === null || e.value > I) && (I = e.value);
      return I != null ? new Date(I) : null;
    }
    get maxDate() {
      let I = null;
      for (const e of this._def.checks)
        e.kind === "max" && (I === null || e.value < I) && (I = e.value);
      return I != null ? new Date(I) : null;
    }
  }
  BC.create = (g) =>
    new BC({
      checks: [],
      coerce: (g == null ? void 0 : g.coerce) || !1,
      typeName: D.ZodDate,
      ..._(g),
    });
  class Yo extends $ {
    _parse(I) {
      if (this._getType(I) !== w.symbol) {
        const C = this._getOrReturnCtx(I);
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.symbol,
            received: C.parsedType,
          }),
          j
        );
      }
      return Og(I.data);
    }
  }
  Yo.create = (g) => new Yo({ typeName: D.ZodSymbol, ..._(g) });
  class kt extends $ {
    _parse(I) {
      if (this._getType(I) !== w.undefined) {
        const C = this._getOrReturnCtx(I);
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.undefined,
            received: C.parsedType,
          }),
          j
        );
      }
      return Og(I.data);
    }
  }
  kt.create = (g) => new kt({ typeName: D.ZodUndefined, ..._(g) });
  class ft extends $ {
    _parse(I) {
      if (this._getType(I) !== w.null) {
        const C = this._getOrReturnCtx(I);
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.null,
            received: C.parsedType,
          }),
          j
        );
      }
      return Og(I.data);
    }
  }
  ft.create = (g) => new ft({ typeName: D.ZodNull, ..._(g) });
  class ml extends $ {
    constructor() {
      super(...arguments), (this._any = !0);
    }
    _parse(I) {
      return Og(I.data);
    }
  }
  ml.create = (g) => new ml({ typeName: D.ZodAny, ..._(g) });
  class iC extends $ {
    constructor() {
      super(...arguments), (this._unknown = !0);
    }
    _parse(I) {
      return Og(I.data);
    }
  }
  iC.create = (g) => new iC({ typeName: D.ZodUnknown, ..._(g) });
  class ue extends $ {
    _parse(I) {
      const e = this._getOrReturnCtx(I);
      return (
        Y(e, {
          code: v.invalid_type,
          expected: w.never,
          received: e.parsedType,
        }),
        j
      );
    }
  }
  ue.create = (g) => new ue({ typeName: D.ZodNever, ..._(g) });
  class Ho extends $ {
    _parse(I) {
      if (this._getType(I) !== w.undefined) {
        const C = this._getOrReturnCtx(I);
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.void,
            received: C.parsedType,
          }),
          j
        );
      }
      return Og(I.data);
    }
  }
  Ho.create = (g) => new Ho({ typeName: D.ZodVoid, ..._(g) });
  class NI extends $ {
    _parse(I) {
      const { ctx: e, status: C } = this._processInputParams(I),
        l = this._def;
      if (e.parsedType !== w.array)
        return (
          Y(e, {
            code: v.invalid_type,
            expected: w.array,
            received: e.parsedType,
          }),
          j
        );
      if (l.exactLength !== null) {
        const n = e.data.length > l.exactLength.value,
          o = e.data.length < l.exactLength.value;
        (n || o) &&
          (Y(e, {
            code: n ? v.too_big : v.too_small,
            minimum: o ? l.exactLength.value : void 0,
            maximum: n ? l.exactLength.value : void 0,
            type: "array",
            inclusive: !0,
            exact: !0,
            message: l.exactLength.message,
          }),
          C.dirty());
      }
      if (
        (l.minLength !== null &&
          e.data.length < l.minLength.value &&
          (Y(e, {
            code: v.too_small,
            minimum: l.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: l.minLength.message,
          }),
          C.dirty()),
        l.maxLength !== null &&
          e.data.length > l.maxLength.value &&
          (Y(e, {
            code: v.too_big,
            maximum: l.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: l.maxLength.message,
          }),
          C.dirty()),
        e.common.async)
      )
        return Promise.all(
          [...e.data].map((n, o) => l.type._parseAsync(new _I(e, n, e.path, o)))
        ).then((n) => Dg.mergeArray(C, n));
      const t = [...e.data].map((n, o) =>
        l.type._parseSync(new _I(e, n, e.path, o))
      );
      return Dg.mergeArray(C, t);
    }
    get element() {
      return this._def.type;
    }
    min(I, e) {
      return new NI({
        ...this._def,
        minLength: { value: I, message: x.toString(e) },
      });
    }
    max(I, e) {
      return new NI({
        ...this._def,
        maxLength: { value: I, message: x.toString(e) },
      });
    }
    length(I, e) {
      return new NI({
        ...this._def,
        exactLength: { value: I, message: x.toString(e) },
      });
    }
    nonempty(I) {
      return this.min(1, I);
    }
  }
  NI.create = (g, I) =>
    new NI({
      type: g,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: D.ZodArray,
      ..._(I),
    });
  function wC(g) {
    if (g instanceof Bg) {
      const I = {};
      for (const e in g.shape) {
        const C = g.shape[e];
        I[e] = PI.create(wC(C));
      }
      return new Bg({ ...g._def, shape: () => I });
    } else
      return g instanceof NI
        ? new NI({ ...g._def, type: wC(g.element) })
        : g instanceof PI
        ? PI.create(wC(g.unwrap()))
        : g instanceof Oe
        ? Oe.create(wC(g.unwrap()))
        : g instanceof qI
        ? qI.create(g.items.map((I) => wC(I)))
        : g;
  }
  class Bg extends $ {
    constructor() {
      super(...arguments),
        (this._cached = null),
        (this.nonstrict = this.passthrough),
        (this.augment = this.extend);
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      const I = this._def.shape(),
        e = eg.objectKeys(I);
      return (this._cached = { shape: I, keys: e });
    }
    _parse(I) {
      if (this._getType(I) !== w.object) {
        const c = this._getOrReturnCtx(I);
        return (
          Y(c, {
            code: v.invalid_type,
            expected: w.object,
            received: c.parsedType,
          }),
          j
        );
      }
      const { status: C, ctx: l } = this._processInputParams(I),
        { shape: t, keys: n } = this._getCached(),
        o = [];
      if (
        !(this._def.catchall instanceof ue && this._def.unknownKeys === "strip")
      )
        for (const c in l.data) n.includes(c) || o.push(c);
      const A = [];
      for (const c of n) {
        const d = t[c],
          i = l.data[c];
        A.push({
          key: { status: "valid", value: c },
          value: d._parse(new _I(l, i, l.path, c)),
          alwaysSet: c in l.data,
        });
      }
      if (this._def.catchall instanceof ue) {
        const c = this._def.unknownKeys;
        if (c === "passthrough")
          for (const d of o)
            A.push({
              key: { status: "valid", value: d },
              value: { status: "valid", value: l.data[d] },
            });
        else if (c === "strict")
          o.length > 0 &&
            (Y(l, { code: v.unrecognized_keys, keys: o }), C.dirty());
        else if (c !== "strip")
          throw new Error(
            "Internal ZodObject error: invalid unknownKeys value."
          );
      } else {
        const c = this._def.catchall;
        for (const d of o) {
          const i = l.data[d];
          A.push({
            key: { status: "valid", value: d },
            value: c._parse(new _I(l, i, l.path, d)),
            alwaysSet: d in l.data,
          });
        }
      }
      return l.common.async
        ? Promise.resolve()
            .then(async () => {
              const c = [];
              for (const d of A) {
                const i = await d.key,
                  r = await d.value;
                c.push({ key: i, value: r, alwaysSet: d.alwaysSet });
              }
              return c;
            })
            .then((c) => Dg.mergeObjectSync(C, c))
        : Dg.mergeObjectSync(C, A);
    }
    get shape() {
      return this._def.shape();
    }
    strict(I) {
      return (
        x.errToObj,
        new Bg({
          ...this._def,
          unknownKeys: "strict",
          ...(I !== void 0
            ? {
                errorMap: (e, C) => {
                  var l, t, n, o;
                  const A =
                    (n =
                      (t = (l = this._def).errorMap) === null || t === void 0
                        ? void 0
                        : t.call(l, e, C).message) !== null && n !== void 0
                      ? n
                      : C.defaultError;
                  return e.code === "unrecognized_keys"
                    ? {
                        message:
                          (o = x.errToObj(I).message) !== null && o !== void 0
                            ? o
                            : A,
                      }
                    : { message: A };
                },
              }
            : {}),
        })
      );
    }
    strip() {
      return new Bg({ ...this._def, unknownKeys: "strip" });
    }
    passthrough() {
      return new Bg({ ...this._def, unknownKeys: "passthrough" });
    }
    extend(I) {
      return new Bg({
        ...this._def,
        shape: () => ({ ...this._def.shape(), ...I }),
      });
    }
    merge(I) {
      return new Bg({
        unknownKeys: I._def.unknownKeys,
        catchall: I._def.catchall,
        shape: () => ({ ...this._def.shape(), ...I._def.shape() }),
        typeName: D.ZodObject,
      });
    }
    setKey(I, e) {
      return this.augment({ [I]: e });
    }
    catchall(I) {
      return new Bg({ ...this._def, catchall: I });
    }
    pick(I) {
      const e = {};
      return (
        eg.objectKeys(I).forEach((C) => {
          I[C] && this.shape[C] && (e[C] = this.shape[C]);
        }),
        new Bg({ ...this._def, shape: () => e })
      );
    }
    omit(I) {
      const e = {};
      return (
        eg.objectKeys(this.shape).forEach((C) => {
          I[C] || (e[C] = this.shape[C]);
        }),
        new Bg({ ...this._def, shape: () => e })
      );
    }
    deepPartial() {
      return wC(this);
    }
    partial(I) {
      const e = {};
      return (
        eg.objectKeys(this.shape).forEach((C) => {
          const l = this.shape[C];
          I && !I[C] ? (e[C] = l) : (e[C] = l.optional());
        }),
        new Bg({ ...this._def, shape: () => e })
      );
    }
    required(I) {
      const e = {};
      return (
        eg.objectKeys(this.shape).forEach((C) => {
          if (I && !I[C]) e[C] = this.shape[C];
          else {
            let t = this.shape[C];
            for (; t instanceof PI; ) t = t._def.innerType;
            e[C] = t;
          }
        }),
        new Bg({ ...this._def, shape: () => e })
      );
    }
    keyof() {
      return rb(eg.objectKeys(this.shape));
    }
  }
  Bg.create = (g, I) =>
    new Bg({
      shape: () => g,
      unknownKeys: "strip",
      catchall: ue.create(),
      typeName: D.ZodObject,
      ..._(I),
    });
  Bg.strictCreate = (g, I) =>
    new Bg({
      shape: () => g,
      unknownKeys: "strict",
      catchall: ue.create(),
      typeName: D.ZodObject,
      ..._(I),
    });
  Bg.lazycreate = (g, I) =>
    new Bg({
      shape: g,
      unknownKeys: "strip",
      catchall: ue.create(),
      typeName: D.ZodObject,
      ..._(I),
    });
  class Yt extends $ {
    _parse(I) {
      const { ctx: e } = this._processInputParams(I),
        C = this._def.options;
      function l(t) {
        for (const o of t) if (o.result.status === "valid") return o.result;
        for (const o of t)
          if (o.result.status === "dirty")
            return e.common.issues.push(...o.ctx.common.issues), o.result;
        const n = t.map((o) => new sI(o.ctx.common.issues));
        return Y(e, { code: v.invalid_union, unionErrors: n }), j;
      }
      if (e.common.async)
        return Promise.all(
          C.map(async (t) => {
            const n = {
              ...e,
              common: { ...e.common, issues: [] },
              parent: null,
            };
            return {
              result: await t._parseAsync({
                data: e.data,
                path: e.path,
                parent: n,
              }),
              ctx: n,
            };
          })
        ).then(l);
      {
        let t;
        const n = [];
        for (const A of C) {
          const c = { ...e, common: { ...e.common, issues: [] }, parent: null },
            d = A._parseSync({ data: e.data, path: e.path, parent: c });
          if (d.status === "valid") return d;
          d.status === "dirty" && !t && (t = { result: d, ctx: c }),
            c.common.issues.length && n.push(c.common.issues);
        }
        if (t) return e.common.issues.push(...t.ctx.common.issues), t.result;
        const o = n.map((A) => new sI(A));
        return Y(e, { code: v.invalid_union, unionErrors: o }), j;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  Yt.create = (g, I) => new Yt({ options: g, typeName: D.ZodUnion, ..._(I) });
  const Ie = (g) =>
    g instanceof Nt
      ? Ie(g.schema)
      : g instanceof zI
      ? Ie(g.innerType())
      : g instanceof Kt
      ? [g.value]
      : g instanceof Pe
      ? g.options
      : g instanceof Ft
      ? eg.objectValues(g.enum)
      : g instanceof xt
      ? Ie(g._def.innerType)
      : g instanceof kt
      ? [void 0]
      : g instanceof ft
      ? [null]
      : g instanceof PI
      ? [void 0, ...Ie(g.unwrap())]
      : g instanceof Oe
      ? [null, ...Ie(g.unwrap())]
      : g instanceof Za || g instanceof zt
      ? Ie(g.unwrap())
      : g instanceof Mt
      ? Ie(g._def.innerType)
      : [];
  class aA extends $ {
    _parse(I) {
      const { ctx: e } = this._processInputParams(I);
      if (e.parsedType !== w.object)
        return (
          Y(e, {
            code: v.invalid_type,
            expected: w.object,
            received: e.parsedType,
          }),
          j
        );
      const C = this.discriminator,
        l = e.data[C],
        t = this.optionsMap.get(l);
      return t
        ? e.common.async
          ? t._parseAsync({ data: e.data, path: e.path, parent: e })
          : t._parseSync({ data: e.data, path: e.path, parent: e })
        : (Y(e, {
            code: v.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [C],
          }),
          j);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(I, e, C) {
      const l = new Map();
      for (const t of e) {
        const n = Ie(t.shape[I]);
        if (!n.length)
          throw new Error(
            `A discriminator value for key \`${I}\` could not be extracted from all schema options`
          );
        for (const o of n) {
          if (l.has(o))
            throw new Error(
              `Discriminator property ${String(I)} has duplicate value ${String(
                o
              )}`
            );
          l.set(o, t);
        }
      }
      return new aA({
        typeName: D.ZodDiscriminatedUnion,
        discriminator: I,
        options: e,
        optionsMap: l,
        ..._(C),
      });
    }
  }
  function kd(g, I) {
    const e = Ve(g),
      C = Ve(I);
    if (g === I) return { valid: !0, data: g };
    if (e === w.object && C === w.object) {
      const l = eg.objectKeys(I),
        t = eg.objectKeys(g).filter((o) => l.indexOf(o) !== -1),
        n = { ...g, ...I };
      for (const o of t) {
        const A = kd(g[o], I[o]);
        if (!A.valid) return { valid: !1 };
        n[o] = A.data;
      }
      return { valid: !0, data: n };
    } else if (e === w.array && C === w.array) {
      if (g.length !== I.length) return { valid: !1 };
      const l = [];
      for (let t = 0; t < g.length; t++) {
        const n = g[t],
          o = I[t],
          A = kd(n, o);
        if (!A.valid) return { valid: !1 };
        l.push(A.data);
      }
      return { valid: !0, data: l };
    } else
      return e === w.date && C === w.date && +g == +I
        ? { valid: !0, data: g }
        : { valid: !1 };
  }
  class Ht extends $ {
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I),
        l = (t, n) => {
          if (Jd(t) || Jd(n)) return j;
          const o = kd(t.value, n.value);
          return o.valid
            ? ((vd(t) || vd(n)) && e.dirty(),
              { status: e.value, value: o.data })
            : (Y(C, { code: v.invalid_intersection_types }), j);
        };
      return C.common.async
        ? Promise.all([
            this._def.left._parseAsync({
              data: C.data,
              path: C.path,
              parent: C,
            }),
            this._def.right._parseAsync({
              data: C.data,
              path: C.path,
              parent: C,
            }),
          ]).then(([t, n]) => l(t, n))
        : l(
            this._def.left._parseSync({
              data: C.data,
              path: C.path,
              parent: C,
            }),
            this._def.right._parseSync({
              data: C.data,
              path: C.path,
              parent: C,
            })
          );
    }
  }
  Ht.create = (g, I, e) =>
    new Ht({ left: g, right: I, typeName: D.ZodIntersection, ..._(e) });
  class qI extends $ {
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I);
      if (C.parsedType !== w.array)
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.array,
            received: C.parsedType,
          }),
          j
        );
      if (C.data.length < this._def.items.length)
        return (
          Y(C, {
            code: v.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array",
          }),
          j
        );
      !this._def.rest &&
        C.data.length > this._def.items.length &&
        (Y(C, {
          code: v.too_big,
          maximum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        e.dirty());
      const t = [...C.data]
        .map((n, o) => {
          const A = this._def.items[o] || this._def.rest;
          return A ? A._parse(new _I(C, n, C.path, o)) : null;
        })
        .filter((n) => !!n);
      return C.common.async
        ? Promise.all(t).then((n) => Dg.mergeArray(e, n))
        : Dg.mergeArray(e, t);
    }
    get items() {
      return this._def.items;
    }
    rest(I) {
      return new qI({ ...this._def, rest: I });
    }
  }
  qI.create = (g, I) => {
    if (!Array.isArray(g))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new qI({ items: g, typeName: D.ZodTuple, rest: null, ..._(I) });
  };
  class wt extends $ {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I);
      if (C.parsedType !== w.object)
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.object,
            received: C.parsedType,
          }),
          j
        );
      const l = [],
        t = this._def.keyType,
        n = this._def.valueType;
      for (const o in C.data)
        l.push({
          key: t._parse(new _I(C, o, C.path, o)),
          value: n._parse(new _I(C, C.data[o], C.path, o)),
          alwaysSet: o in C.data,
        });
      return C.common.async
        ? Dg.mergeObjectAsync(e, l)
        : Dg.mergeObjectSync(e, l);
    }
    get element() {
      return this._def.valueType;
    }
    static create(I, e, C) {
      return e instanceof $
        ? new wt({ keyType: I, valueType: e, typeName: D.ZodRecord, ..._(C) })
        : new wt({
            keyType: YI.create(),
            valueType: I,
            typeName: D.ZodRecord,
            ..._(e),
          });
    }
  }
  class wo extends $ {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I);
      if (C.parsedType !== w.map)
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.map,
            received: C.parsedType,
          }),
          j
        );
      const l = this._def.keyType,
        t = this._def.valueType,
        n = [...C.data.entries()].map(([o, A], c) => ({
          key: l._parse(new _I(C, o, C.path, [c, "key"])),
          value: t._parse(new _I(C, A, C.path, [c, "value"])),
        }));
      if (C.common.async) {
        const o = new Map();
        return Promise.resolve().then(async () => {
          for (const A of n) {
            const c = await A.key,
              d = await A.value;
            if (c.status === "aborted" || d.status === "aborted") return j;
            (c.status === "dirty" || d.status === "dirty") && e.dirty(),
              o.set(c.value, d.value);
          }
          return { status: e.value, value: o };
        });
      } else {
        const o = new Map();
        for (const A of n) {
          const c = A.key,
            d = A.value;
          if (c.status === "aborted" || d.status === "aborted") return j;
          (c.status === "dirty" || d.status === "dirty") && e.dirty(),
            o.set(c.value, d.value);
        }
        return { status: e.value, value: o };
      }
    }
  }
  wo.create = (g, I, e) =>
    new wo({ valueType: I, keyType: g, typeName: D.ZodMap, ..._(e) });
  class pC extends $ {
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I);
      if (C.parsedType !== w.set)
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.set,
            received: C.parsedType,
          }),
          j
        );
      const l = this._def;
      l.minSize !== null &&
        C.data.size < l.minSize.value &&
        (Y(C, {
          code: v.too_small,
          minimum: l.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: l.minSize.message,
        }),
        e.dirty()),
        l.maxSize !== null &&
          C.data.size > l.maxSize.value &&
          (Y(C, {
            code: v.too_big,
            maximum: l.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: l.maxSize.message,
          }),
          e.dirty());
      const t = this._def.valueType;
      function n(A) {
        const c = new Set();
        for (const d of A) {
          if (d.status === "aborted") return j;
          d.status === "dirty" && e.dirty(), c.add(d.value);
        }
        return { status: e.value, value: c };
      }
      const o = [...C.data.values()].map((A, c) =>
        t._parse(new _I(C, A, C.path, c))
      );
      return C.common.async ? Promise.all(o).then((A) => n(A)) : n(o);
    }
    min(I, e) {
      return new pC({
        ...this._def,
        minSize: { value: I, message: x.toString(e) },
      });
    }
    max(I, e) {
      return new pC({
        ...this._def,
        maxSize: { value: I, message: x.toString(e) },
      });
    }
    size(I, e) {
      return this.min(I, e).max(I, e);
    }
    nonempty(I) {
      return this.min(1, I);
    }
  }
  pC.create = (g, I) =>
    new pC({
      valueType: g,
      minSize: null,
      maxSize: null,
      typeName: D.ZodSet,
      ..._(I),
    });
  class tl extends $ {
    constructor() {
      super(...arguments), (this.validate = this.implement);
    }
    _parse(I) {
      const { ctx: e } = this._processInputParams(I);
      if (e.parsedType !== w.function)
        return (
          Y(e, {
            code: v.invalid_type,
            expected: w.function,
            received: e.parsedType,
          }),
          j
        );
      function C(o, A) {
        return ko({
          data: o,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            vo(),
            ul,
          ].filter((c) => !!c),
          issueData: { code: v.invalid_arguments, argumentsError: A },
        });
      }
      function l(o, A) {
        return ko({
          data: o,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            vo(),
            ul,
          ].filter((c) => !!c),
          issueData: { code: v.invalid_return_type, returnTypeError: A },
        });
      }
      const t = { errorMap: e.common.contextualErrorMap },
        n = e.data;
      if (this._def.returns instanceof Zl) {
        const o = this;
        return Og(async function (...A) {
          const c = new sI([]),
            d = await o._def.args.parseAsync(A, t).catch((u) => {
              throw (c.addIssue(C(A, u)), c);
            }),
            i = await Reflect.apply(n, this, d);
          return await o._def.returns._def.type.parseAsync(i, t).catch((u) => {
            throw (c.addIssue(l(i, u)), c);
          });
        });
      } else {
        const o = this;
        return Og(function (...A) {
          const c = o._def.args.safeParse(A, t);
          if (!c.success) throw new sI([C(A, c.error)]);
          const d = Reflect.apply(n, this, c.data),
            i = o._def.returns.safeParse(d, t);
          if (!i.success) throw new sI([l(d, i.error)]);
          return i.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...I) {
      return new tl({ ...this._def, args: qI.create(I).rest(iC.create()) });
    }
    returns(I) {
      return new tl({ ...this._def, returns: I });
    }
    implement(I) {
      return this.parse(I);
    }
    strictImplement(I) {
      return this.parse(I);
    }
    static create(I, e, C) {
      return new tl({
        args: I || qI.create([]).rest(iC.create()),
        returns: e || iC.create(),
        typeName: D.ZodFunction,
        ..._(C),
      });
    }
  }
  class Nt extends $ {
    get schema() {
      return this._def.getter();
    }
    _parse(I) {
      const { ctx: e } = this._processInputParams(I);
      return this._def
        .getter()
        ._parse({ data: e.data, path: e.path, parent: e });
    }
  }
  Nt.create = (g, I) => new Nt({ getter: g, typeName: D.ZodLazy, ..._(I) });
  class Kt extends $ {
    _parse(I) {
      if (I.data !== this._def.value) {
        const e = this._getOrReturnCtx(I);
        return (
          Y(e, {
            received: e.data,
            code: v.invalid_literal,
            expected: this._def.value,
          }),
          j
        );
      }
      return { status: "valid", value: I.data };
    }
    get value() {
      return this._def.value;
    }
  }
  Kt.create = (g, I) => new Kt({ value: g, typeName: D.ZodLiteral, ..._(I) });
  function rb(g, I) {
    return new Pe({ values: g, typeName: D.ZodEnum, ..._(I) });
  }
  class Pe extends $ {
    constructor() {
      super(...arguments), Dl.set(this, void 0);
    }
    _parse(I) {
      if (typeof I.data != "string") {
        const e = this._getOrReturnCtx(I),
          C = this._def.values;
        return (
          Y(e, {
            expected: eg.joinValues(C),
            received: e.parsedType,
            code: v.invalid_type,
          }),
          j
        );
      }
      if (
        (fo(this, Dl) || cb(this, Dl, new Set(this._def.values)),
        !fo(this, Dl).has(I.data))
      ) {
        const e = this._getOrReturnCtx(I),
          C = this._def.values;
        return (
          Y(e, { received: e.data, code: v.invalid_enum_value, options: C }), j
        );
      }
      return Og(I.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const I = {};
      for (const e of this._def.values) I[e] = e;
      return I;
    }
    get Values() {
      const I = {};
      for (const e of this._def.values) I[e] = e;
      return I;
    }
    get Enum() {
      const I = {};
      for (const e of this._def.values) I[e] = e;
      return I;
    }
    extract(I, e = this._def) {
      return Pe.create(I, { ...this._def, ...e });
    }
    exclude(I, e = this._def) {
      return Pe.create(
        this.options.filter((C) => !I.includes(C)),
        { ...this._def, ...e }
      );
    }
  }
  Dl = new WeakMap();
  Pe.create = rb;
  class Ft extends $ {
    constructor() {
      super(...arguments), Tl.set(this, void 0);
    }
    _parse(I) {
      const e = eg.getValidEnumValues(this._def.values),
        C = this._getOrReturnCtx(I);
      if (C.parsedType !== w.string && C.parsedType !== w.number) {
        const l = eg.objectValues(e);
        return (
          Y(C, {
            expected: eg.joinValues(l),
            received: C.parsedType,
            code: v.invalid_type,
          }),
          j
        );
      }
      if (
        (fo(this, Tl) ||
          cb(this, Tl, new Set(eg.getValidEnumValues(this._def.values))),
        !fo(this, Tl).has(I.data))
      ) {
        const l = eg.objectValues(e);
        return (
          Y(C, { received: C.data, code: v.invalid_enum_value, options: l }), j
        );
      }
      return Og(I.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  Tl = new WeakMap();
  Ft.create = (g, I) =>
    new Ft({ values: g, typeName: D.ZodNativeEnum, ..._(I) });
  class Zl extends $ {
    unwrap() {
      return this._def.type;
    }
    _parse(I) {
      const { ctx: e } = this._processInputParams(I);
      if (e.parsedType !== w.promise && e.common.async === !1)
        return (
          Y(e, {
            code: v.invalid_type,
            expected: w.promise,
            received: e.parsedType,
          }),
          j
        );
      const C = e.parsedType === w.promise ? e.data : Promise.resolve(e.data);
      return Og(
        C.then((l) =>
          this._def.type.parseAsync(l, {
            path: e.path,
            errorMap: e.common.contextualErrorMap,
          })
        )
      );
    }
  }
  Zl.create = (g, I) => new Zl({ type: g, typeName: D.ZodPromise, ..._(I) });
  class zI extends $ {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === D.ZodEffects
        ? this._def.schema.sourceType()
        : this._def.schema;
    }
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I),
        l = this._def.effect || null,
        t = {
          addIssue: (n) => {
            Y(C, n), n.fatal ? e.abort() : e.dirty();
          },
          get path() {
            return C.path;
          },
        };
      if (((t.addIssue = t.addIssue.bind(t)), l.type === "preprocess")) {
        const n = l.transform(C.data, t);
        if (C.common.async)
          return Promise.resolve(n).then(async (o) => {
            if (e.value === "aborted") return j;
            const A = await this._def.schema._parseAsync({
              data: o,
              path: C.path,
              parent: C,
            });
            return A.status === "aborted"
              ? j
              : A.status === "dirty" || e.value === "dirty"
              ? PC(A.value)
              : A;
          });
        {
          if (e.value === "aborted") return j;
          const o = this._def.schema._parseSync({
            data: n,
            path: C.path,
            parent: C,
          });
          return o.status === "aborted"
            ? j
            : o.status === "dirty" || e.value === "dirty"
            ? PC(o.value)
            : o;
        }
      }
      if (l.type === "refinement") {
        const n = (o) => {
          const A = l.refinement(o, t);
          if (C.common.async) return Promise.resolve(A);
          if (A instanceof Promise)
            throw new Error(
              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
            );
          return o;
        };
        if (C.common.async === !1) {
          const o = this._def.schema._parseSync({
            data: C.data,
            path: C.path,
            parent: C,
          });
          return o.status === "aborted"
            ? j
            : (o.status === "dirty" && e.dirty(),
              n(o.value),
              { status: e.value, value: o.value });
        } else
          return this._def.schema
            ._parseAsync({ data: C.data, path: C.path, parent: C })
            .then((o) =>
              o.status === "aborted"
                ? j
                : (o.status === "dirty" && e.dirty(),
                  n(o.value).then(() => ({ status: e.value, value: o.value })))
            );
      }
      if (l.type === "transform")
        if (C.common.async === !1) {
          const n = this._def.schema._parseSync({
            data: C.data,
            path: C.path,
            parent: C,
          });
          if (!Xt(n)) return n;
          const o = l.transform(n.value, t);
          if (o instanceof Promise)
            throw new Error(
              "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
            );
          return { status: e.value, value: o };
        } else
          return this._def.schema
            ._parseAsync({ data: C.data, path: C.path, parent: C })
            .then((n) =>
              Xt(n)
                ? Promise.resolve(l.transform(n.value, t)).then((o) => ({
                    status: e.value,
                    value: o,
                  }))
                : n
            );
      eg.assertNever(l);
    }
  }
  zI.create = (g, I, e) =>
    new zI({ schema: g, typeName: D.ZodEffects, effect: I, ..._(e) });
  zI.createWithPreprocess = (g, I, e) =>
    new zI({
      schema: I,
      effect: { type: "preprocess", transform: g },
      typeName: D.ZodEffects,
      ..._(e),
    });
  class PI extends $ {
    _parse(I) {
      return this._getType(I) === w.undefined
        ? Og(void 0)
        : this._def.innerType._parse(I);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  PI.create = (g, I) =>
    new PI({ innerType: g, typeName: D.ZodOptional, ..._(I) });
  class Oe extends $ {
    _parse(I) {
      return this._getType(I) === w.null
        ? Og(null)
        : this._def.innerType._parse(I);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  Oe.create = (g, I) =>
    new Oe({ innerType: g, typeName: D.ZodNullable, ..._(I) });
  class xt extends $ {
    _parse(I) {
      const { ctx: e } = this._processInputParams(I);
      let C = e.data;
      return (
        e.parsedType === w.undefined && (C = this._def.defaultValue()),
        this._def.innerType._parse({ data: C, path: e.path, parent: e })
      );
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  xt.create = (g, I) =>
    new xt({
      innerType: g,
      typeName: D.ZodDefault,
      defaultValue:
        typeof I.default == "function" ? I.default : () => I.default,
      ..._(I),
    });
  class Mt extends $ {
    _parse(I) {
      const { ctx: e } = this._processInputParams(I),
        C = { ...e, common: { ...e.common, issues: [] } },
        l = this._def.innerType._parse({
          data: C.data,
          path: C.path,
          parent: { ...C },
        });
      return Jt(l)
        ? l.then((t) => ({
            status: "valid",
            value:
              t.status === "valid"
                ? t.value
                : this._def.catchValue({
                    get error() {
                      return new sI(C.common.issues);
                    },
                    input: C.data,
                  }),
          }))
        : {
            status: "valid",
            value:
              l.status === "valid"
                ? l.value
                : this._def.catchValue({
                    get error() {
                      return new sI(C.common.issues);
                    },
                    input: C.data,
                  }),
          };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  Mt.create = (g, I) =>
    new Mt({
      innerType: g,
      typeName: D.ZodCatch,
      catchValue: typeof I.catch == "function" ? I.catch : () => I.catch,
      ..._(I),
    });
  class No extends $ {
    _parse(I) {
      if (this._getType(I) !== w.nan) {
        const C = this._getOrReturnCtx(I);
        return (
          Y(C, {
            code: v.invalid_type,
            expected: w.nan,
            received: C.parsedType,
          }),
          j
        );
      }
      return { status: "valid", value: I.data };
    }
  }
  No.create = (g) => new No({ typeName: D.ZodNaN, ..._(g) });
  const tJ = Symbol("zod_brand");
  class Za extends $ {
    _parse(I) {
      const { ctx: e } = this._processInputParams(I),
        C = e.data;
      return this._def.type._parse({ data: C, path: e.path, parent: e });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class en extends $ {
    _parse(I) {
      const { status: e, ctx: C } = this._processInputParams(I);
      if (C.common.async)
        return (async () => {
          const t = await this._def.in._parseAsync({
            data: C.data,
            path: C.path,
            parent: C,
          });
          return t.status === "aborted"
            ? j
            : t.status === "dirty"
            ? (e.dirty(), PC(t.value))
            : this._def.out._parseAsync({
                data: t.value,
                path: C.path,
                parent: C,
              });
        })();
      {
        const l = this._def.in._parseSync({
          data: C.data,
          path: C.path,
          parent: C,
        });
        return l.status === "aborted"
          ? j
          : l.status === "dirty"
          ? (e.dirty(), { status: "dirty", value: l.value })
          : this._def.out._parseSync({
              data: l.value,
              path: C.path,
              parent: C,
            });
      }
    }
    static create(I, e) {
      return new en({ in: I, out: e, typeName: D.ZodPipeline });
    }
  }
  class zt extends $ {
    _parse(I) {
      const e = this._def.innerType._parse(I),
        C = (l) => (Xt(l) && (l.value = Object.freeze(l.value)), l);
      return Jt(e) ? e.then((l) => C(l)) : C(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  zt.create = (g, I) =>
    new zt({ innerType: g, typeName: D.ZodReadonly, ..._(I) });
  function sb(g, I = {}, e) {
    return g
      ? ml.create().superRefine((C, l) => {
          var t, n;
          if (!g(C)) {
            const o =
                typeof I == "function"
                  ? I(C)
                  : typeof I == "string"
                  ? { message: I }
                  : I,
              A =
                (n = (t = o.fatal) !== null && t !== void 0 ? t : e) !== null &&
                n !== void 0
                  ? n
                  : !0,
              c = typeof o == "string" ? { message: o } : o;
            l.addIssue({ code: "custom", ...c, fatal: A });
          }
        })
      : ml.create();
  }
  const nJ = { object: Bg.lazycreate };
  var D;
  (function (g) {
    (g.ZodString = "ZodString"),
      (g.ZodNumber = "ZodNumber"),
      (g.ZodNaN = "ZodNaN"),
      (g.ZodBigInt = "ZodBigInt"),
      (g.ZodBoolean = "ZodBoolean"),
      (g.ZodDate = "ZodDate"),
      (g.ZodSymbol = "ZodSymbol"),
      (g.ZodUndefined = "ZodUndefined"),
      (g.ZodNull = "ZodNull"),
      (g.ZodAny = "ZodAny"),
      (g.ZodUnknown = "ZodUnknown"),
      (g.ZodNever = "ZodNever"),
      (g.ZodVoid = "ZodVoid"),
      (g.ZodArray = "ZodArray"),
      (g.ZodObject = "ZodObject"),
      (g.ZodUnion = "ZodUnion"),
      (g.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
      (g.ZodIntersection = "ZodIntersection"),
      (g.ZodTuple = "ZodTuple"),
      (g.ZodRecord = "ZodRecord"),
      (g.ZodMap = "ZodMap"),
      (g.ZodSet = "ZodSet"),
      (g.ZodFunction = "ZodFunction"),
      (g.ZodLazy = "ZodLazy"),
      (g.ZodLiteral = "ZodLiteral"),
      (g.ZodEnum = "ZodEnum"),
      (g.ZodEffects = "ZodEffects"),
      (g.ZodNativeEnum = "ZodNativeEnum"),
      (g.ZodOptional = "ZodOptional"),
      (g.ZodNullable = "ZodNullable"),
      (g.ZodDefault = "ZodDefault"),
      (g.ZodCatch = "ZodCatch"),
      (g.ZodPromise = "ZodPromise"),
      (g.ZodBranded = "ZodBranded"),
      (g.ZodPipeline = "ZodPipeline"),
      (g.ZodReadonly = "ZodReadonly");
  })(D || (D = {}));
  const oJ = (g, I = { message: `Input not instance of ${g.name}` }) =>
      sb((e) => e instanceof g, I),
    ub = YI.create,
    mb = Te.create,
    AJ = No.create,
    cJ = je.create,
    Zb = vt.create,
    dJ = BC.create,
    iJ = Yo.create,
    aJ = kt.create,
    rJ = ft.create,
    sJ = ml.create,
    uJ = iC.create,
    mJ = ue.create,
    ZJ = Ho.create,
    GJ = NI.create,
    bJ = Bg.create,
    BJ = Bg.strictCreate,
    pJ = Yt.create,
    yJ = aA.create,
    hJ = Ht.create,
    SJ = qI.create,
    VJ = wt.create,
    WJ = wo.create,
    RJ = pC.create,
    XJ = tl.create,
    JJ = Nt.create,
    vJ = Kt.create,
    kJ = Pe.create,
    fJ = Ft.create,
    YJ = Zl.create,
    Bs = zI.create,
    HJ = PI.create,
    wJ = Oe.create,
    NJ = zI.createWithPreprocess,
    KJ = en.create,
    FJ = () => ub().optional(),
    xJ = () => mb().optional(),
    MJ = () => Zb().optional(),
    zJ = {
      string: (g) => YI.create({ ...g, coerce: !0 }),
      number: (g) => Te.create({ ...g, coerce: !0 }),
      boolean: (g) => vt.create({ ...g, coerce: !0 }),
      bigint: (g) => je.create({ ...g, coerce: !0 }),
      date: (g) => BC.create({ ...g, coerce: !0 }),
    },
    EJ = j;
  var YC = Object.freeze({
    __proto__: null,
    defaultErrorMap: ul,
    setErrorMap: EX,
    getErrorMap: vo,
    makeIssue: ko,
    EMPTY_PATH: UX,
    addIssueToContext: Y,
    ParseStatus: Dg,
    INVALID: j,
    DIRTY: PC,
    OK: Og,
    isAborted: Jd,
    isDirty: vd,
    isValid: Xt,
    isAsync: Jt,
    get util() {
      return eg;
    },
    get objectUtil() {
      return Xd;
    },
    ZodParsedType: w,
    getParsedType: Ve,
    ZodType: $,
    datetimeRegex: ab,
    ZodString: YI,
    ZodNumber: Te,
    ZodBigInt: je,
    ZodBoolean: vt,
    ZodDate: BC,
    ZodSymbol: Yo,
    ZodUndefined: kt,
    ZodNull: ft,
    ZodAny: ml,
    ZodUnknown: iC,
    ZodNever: ue,
    ZodVoid: Ho,
    ZodArray: NI,
    ZodObject: Bg,
    ZodUnion: Yt,
    ZodDiscriminatedUnion: aA,
    ZodIntersection: Ht,
    ZodTuple: qI,
    ZodRecord: wt,
    ZodMap: wo,
    ZodSet: pC,
    ZodFunction: tl,
    ZodLazy: Nt,
    ZodLiteral: Kt,
    ZodEnum: Pe,
    ZodNativeEnum: Ft,
    ZodPromise: Zl,
    ZodEffects: zI,
    ZodTransformer: zI,
    ZodOptional: PI,
    ZodNullable: Oe,
    ZodDefault: xt,
    ZodCatch: Mt,
    ZodNaN: No,
    BRAND: tJ,
    ZodBranded: Za,
    ZodPipeline: en,
    ZodReadonly: zt,
    custom: sb,
    Schema: $,
    ZodSchema: $,
    late: nJ,
    get ZodFirstPartyTypeKind() {
      return D;
    },
    coerce: zJ,
    any: sJ,
    array: GJ,
    bigint: cJ,
    boolean: Zb,
    date: dJ,
    discriminatedUnion: yJ,
    effect: Bs,
    enum: kJ,
    function: XJ,
    instanceof: oJ,
    intersection: hJ,
    lazy: JJ,
    literal: vJ,
    map: WJ,
    nan: AJ,
    nativeEnum: fJ,
    never: mJ,
    null: rJ,
    nullable: wJ,
    number: mb,
    object: bJ,
    oboolean: MJ,
    onumber: xJ,
    optional: HJ,
    ostring: FJ,
    pipeline: KJ,
    preprocess: NJ,
    promise: YJ,
    record: VJ,
    set: RJ,
    strictObject: BJ,
    string: ub,
    symbol: iJ,
    transformer: Bs,
    tuple: SJ,
    undefined: aJ,
    union: pJ,
    unknown: uJ,
    void: ZJ,
    NEVER: EJ,
    ZodIssueCode: v,
    quotelessJson: zX,
    ZodError: sI,
  });
  const UJ = YC.object({
    id: YC.string(),
    title: YC.string(),
    status: YC.string(),
    label: YC.string(),
    priority: YC.string(),
  });
  function QJ({ row: g }) {
    const I = UJ.parse(g.original);
    return s.jsxs(iA, {
      children: [
        s.jsx(ua, {
          asChild: !0,
          children: s.jsxs(fg, {
            variant: "ghost",
            className: "flex h-8 w-8 p-0 data-[state=open]:bg-muted",
            children: [
              s.jsx(xS, { className: "h-4 w-4" }),
              s.jsx("span", { className: "sr-only", children: "Open menu" }),
            ],
          }),
        }),
        s.jsxs(In, {
          align: "end",
          className: "w-[160px]",
          children: [
            s.jsx(dI, { children: "Edit" }),
            s.jsx(dI, { children: "Make a copy" }),
            s.jsx(dI, { children: "Favorite" }),
            s.jsx(bC, {}),
            s.jsxs(xX, {
              children: [
                s.jsx(lb, { children: "Labels" }),
                s.jsx(tb, {
                  children: s.jsx(MX, {
                    value: I.label,
                    children: pZ.map((e) =>
                      s.jsx(ob, { value: e.value, children: e.label }, e.value)
                    ),
                  }),
                }),
              ],
            }),
            s.jsx(bC, {}),
            s.jsxs(dI, { children: ["Delete", s.jsx(jC, { children: "" })] }),
          ],
        }),
      ],
    });
  }
  const LJ = [
    {
      id: "select",
      header: ({ table: g }) =>
        s.jsx(Zd, {
          checked:
            g.getIsAllPageRowsSelected() ||
            (g.getIsSomePageRowsSelected() && "indeterminate"),
          onCheckedChange: (I) => g.toggleAllPageRowsSelected(!!I),
          "aria-label": "Select all",
          className: "translate-y-[2px]",
        }),
      cell: ({ row: g }) =>
        s.jsx(Zd, {
          checked: g.getIsSelected(),
          onCheckedChange: (I) => g.toggleSelected(!!I),
          "aria-label": "Select row",
          className: "translate-y-[2px]",
        }),
      enableSorting: !1,
      enableHiding: !1,
    },
    {
      accessorKey: "id",
      header: ({ column: g }) => s.jsx(Jn, { column: g, title: "Task" }),
      cell: ({ row: g }) =>
        s.jsx("div", { className: "w-[80px]", children: g.getValue("id") }),
      enableSorting: !1,
      enableHiding: !1,
    },
    {
      accessorKey: "title",
      header: ({ column: g }) => s.jsx(Jn, { column: g, title: "Title" }),
      cell: ({ row: g }) => {
        const I = pZ.find((e) => e.value === g.original.label);
        return s.jsxs("div", {
          className: "flex space-x-2",
          children: [
            I && s.jsx(DJ, { color: I.color, children: I.label }),
            s.jsx("span", {
              className: "max-w-[500px] truncate font-medium",
              children: g.getValue("title"),
            }),
          ],
        });
      },
    },
    {
      accessorKey: "status",
      header: ({ column: g }) => s.jsx(Jn, { column: g, title: "Status" }),
      cell: ({ row: g }) => {
        const I = qS.find((e) => e.value === g.getValue("status"));
        return I
          ? s.jsxs("div", {
              className: "flex w-[100px] items-center",
              children: [
                I.icon &&
                  s.jsx(I.icon, {
                    className: "mr-2 h-4 w-4 text-muted-foreground",
                  }),
                s.jsx("span", { children: I.label }),
              ],
            })
          : null;
      },
      filterFn: (g, I, e) => e.includes(g.getValue(I)),
    },
    {
      accessorKey: "priority",
      header: ({ column: g }) => s.jsx(Jn, { column: g, title: "Priority" }),
      cell: ({ row: g }) => {
        const I = $S.find((e) => e.value === g.getValue("priority"));
        return I
          ? s.jsxs("div", {
              className: "flex items-center",
              children: [
                I.icon &&
                  s.jsx(I.icon, {
                    className: "mr-2 h-4 w-4 text-muted-foreground",
                  }),
                s.jsx("span", { children: I.label }),
              ],
            })
          : null;
      },
      filterFn: (g, I, e) => e.includes(g.getValue(I)),
    },
    { id: "actions", cell: ({ row: g }) => s.jsx(QJ, { row: g }) },
  ];
  function DJ({ color: g = "blue", children: I }) {
    const e = {
      blue: "bg-blue-500 text-white",
      red: "bg-red-500 text-white",
      green: "bg-green-500 text-white",
    };
    return s.jsx(Dh, { className: e[g], children: I });
  }
  /**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */ function Je(g, I) {
    return typeof g == "function" ? g(I) : g;
  }
  function mI(g, I) {
    return (e) => {
      I.setState((C) => ({ ...C, [g]: Je(e, C[g]) }));
    };
  }
  function rA(g) {
    return g instanceof Function;
  }
  function TJ(g) {
    return Array.isArray(g) && g.every((I) => typeof I == "number");
  }
  function jJ(g, I) {
    const e = [],
      C = (l) => {
        l.forEach((t) => {
          e.push(t);
          const n = I(t);
          n != null && n.length && C(n);
        });
      };
    return C(g), e;
  }
  function Q(g, I, e) {
    let C = [],
      l;
    return (t) => {
      let n;
      e.key && e.debug && (n = Date.now());
      const o = g(t);
      if (!(o.length !== C.length || o.some((d, i) => C[i] !== d))) return l;
      C = o;
      let c;
      if (
        (e.key && e.debug && (c = Date.now()),
        (l = I(...o)),
        e == null || e.onChange == null || e.onChange(l),
        e.key && e.debug && e != null && e.debug())
      ) {
        const d = Math.round((Date.now() - n) * 100) / 100,
          i = Math.round((Date.now() - c) * 100) / 100,
          r = i / 16,
          u = (b, m) => {
            for (b = String(b); b.length < m; ) b = " " + b;
            return b;
          };
        console.info(
          `%c ${u(i, 5)} /${u(d, 5)} ms`,
          `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
              0,
              Math.min(120 - 120 * r, 120)
            )}deg 100% 31%);`,
          e == null ? void 0 : e.key
        );
      }
      return l;
    };
  }
  function L(g, I, e, C) {
    return {
      debug: () => {
        var l;
        return (l = g == null ? void 0 : g.debugAll) != null ? l : g[I];
      },
      key: !1,
      onChange: C,
    };
  }
  function PJ(g, I, e, C) {
    const l = () => {
        var n;
        return (n = t.getValue()) != null ? n : g.options.renderFallbackValue;
      },
      t = {
        id: `${I.id}_${e.id}`,
        row: I,
        column: e,
        getValue: () => I.getValue(C),
        renderValue: l,
        getContext: Q(
          () => [g, e, I, t],
          (n, o, A, c) => ({
            table: n,
            column: o,
            row: A,
            cell: c,
            getValue: c.getValue,
            renderValue: c.renderValue,
          }),
          L(g.options, "debugCells")
        ),
      };
    return (
      g._features.forEach((n) => {
        n.createCell == null || n.createCell(t, e, I, g);
      }, {}),
      t
    );
  }
  function OJ(g, I, e, C) {
    var l, t;
    const o = { ...g._getDefaultColumnDef(), ...I },
      A = o.accessorKey;
    let c =
        (l =
          (t = o.id) != null
            ? t
            : A
            ? typeof String.prototype.replaceAll == "function"
              ? A.replaceAll(".", "_")
              : A.replace(/\./g, "_")
            : void 0) != null
          ? l
          : typeof o.header == "string"
          ? o.header
          : void 0,
      d;
    if (
      (o.accessorFn
        ? (d = o.accessorFn)
        : A &&
          (A.includes(".")
            ? (d = (r) => {
                let u = r;
                for (const m of A.split(".")) {
                  var b;
                  u = (b = u) == null ? void 0 : b[m];
                }
                return u;
              })
            : (d = (r) => r[o.accessorKey])),
      !c)
    )
      throw new Error();
    let i = {
      id: `${String(c)}`,
      accessorFn: d,
      parent: C,
      depth: e,
      columnDef: o,
      columns: [],
      getFlatColumns: Q(
        () => [!0],
        () => {
          var r;
          return [
            i,
            ...((r = i.columns) == null
              ? void 0
              : r.flatMap((u) => u.getFlatColumns())),
          ];
        },
        L(g.options, "debugColumns")
      ),
      getLeafColumns: Q(
        () => [g._getOrderColumnsFn()],
        (r) => {
          var u;
          if ((u = i.columns) != null && u.length) {
            let b = i.columns.flatMap((m) => m.getLeafColumns());
            return r(b);
          }
          return [i];
        },
        L(g.options, "debugColumns")
      ),
    };
    for (const r of g._features) r.createColumn == null || r.createColumn(i, g);
    return i;
  }
  const Ug = "debugHeaders";
  function ps(g, I, e) {
    var C;
    let t = {
      id: (C = e.id) != null ? C : I.id,
      column: I,
      index: e.index,
      isPlaceholder: !!e.isPlaceholder,
      placeholderId: e.placeholderId,
      depth: e.depth,
      subHeaders: [],
      colSpan: 0,
      rowSpan: 0,
      headerGroup: null,
      getLeafHeaders: () => {
        const n = [],
          o = (A) => {
            A.subHeaders && A.subHeaders.length && A.subHeaders.map(o),
              n.push(A);
          };
        return o(t), n;
      },
      getContext: () => ({ table: g, header: t, column: I }),
    };
    return (
      g._features.forEach((n) => {
        n.createHeader == null || n.createHeader(t, g);
      }),
      t
    );
  }
  const _J = {
    createTable: (g) => {
      (g.getHeaderGroups = Q(
        () => [
          g.getAllColumns(),
          g.getVisibleLeafColumns(),
          g.getState().columnPinning.left,
          g.getState().columnPinning.right,
        ],
        (I, e, C, l) => {
          var t, n;
          const o =
              (t =
                C == null
                  ? void 0
                  : C.map((i) => e.find((r) => r.id === i)).filter(Boolean)) !=
              null
                ? t
                : [],
            A =
              (n =
                l == null
                  ? void 0
                  : l.map((i) => e.find((r) => r.id === i)).filter(Boolean)) !=
              null
                ? n
                : [],
            c = e.filter(
              (i) =>
                !(C != null && C.includes(i.id)) &&
                !(l != null && l.includes(i.id))
            );
          return vn(I, [...o, ...c, ...A], g);
        },
        L(g.options, Ug)
      )),
        (g.getCenterHeaderGroups = Q(
          () => [
            g.getAllColumns(),
            g.getVisibleLeafColumns(),
            g.getState().columnPinning.left,
            g.getState().columnPinning.right,
          ],
          (I, e, C, l) => (
            (e = e.filter(
              (t) =>
                !(C != null && C.includes(t.id)) &&
                !(l != null && l.includes(t.id))
            )),
            vn(I, e, g, "center")
          ),
          L(g.options, Ug)
        )),
        (g.getLeftHeaderGroups = Q(
          () => [
            g.getAllColumns(),
            g.getVisibleLeafColumns(),
            g.getState().columnPinning.left,
          ],
          (I, e, C) => {
            var l;
            const t =
              (l =
                C == null
                  ? void 0
                  : C.map((n) => e.find((o) => o.id === n)).filter(Boolean)) !=
              null
                ? l
                : [];
            return vn(I, t, g, "left");
          },
          L(g.options, Ug)
        )),
        (g.getRightHeaderGroups = Q(
          () => [
            g.getAllColumns(),
            g.getVisibleLeafColumns(),
            g.getState().columnPinning.right,
          ],
          (I, e, C) => {
            var l;
            const t =
              (l =
                C == null
                  ? void 0
                  : C.map((n) => e.find((o) => o.id === n)).filter(Boolean)) !=
              null
                ? l
                : [];
            return vn(I, t, g, "right");
          },
          L(g.options, Ug)
        )),
        (g.getFooterGroups = Q(
          () => [g.getHeaderGroups()],
          (I) => [...I].reverse(),
          L(g.options, Ug)
        )),
        (g.getLeftFooterGroups = Q(
          () => [g.getLeftHeaderGroups()],
          (I) => [...I].reverse(),
          L(g.options, Ug)
        )),
        (g.getCenterFooterGroups = Q(
          () => [g.getCenterHeaderGroups()],
          (I) => [...I].reverse(),
          L(g.options, Ug)
        )),
        (g.getRightFooterGroups = Q(
          () => [g.getRightHeaderGroups()],
          (I) => [...I].reverse(),
          L(g.options, Ug)
        )),
        (g.getFlatHeaders = Q(
          () => [g.getHeaderGroups()],
          (I) => I.map((e) => e.headers).flat(),
          L(g.options, Ug)
        )),
        (g.getLeftFlatHeaders = Q(
          () => [g.getLeftHeaderGroups()],
          (I) => I.map((e) => e.headers).flat(),
          L(g.options, Ug)
        )),
        (g.getCenterFlatHeaders = Q(
          () => [g.getCenterHeaderGroups()],
          (I) => I.map((e) => e.headers).flat(),
          L(g.options, Ug)
        )),
        (g.getRightFlatHeaders = Q(
          () => [g.getRightHeaderGroups()],
          (I) => I.map((e) => e.headers).flat(),
          L(g.options, Ug)
        )),
        (g.getCenterLeafHeaders = Q(
          () => [g.getCenterFlatHeaders()],
          (I) =>
            I.filter((e) => {
              var C;
              return !((C = e.subHeaders) != null && C.length);
            }),
          L(g.options, Ug)
        )),
        (g.getLeftLeafHeaders = Q(
          () => [g.getLeftFlatHeaders()],
          (I) =>
            I.filter((e) => {
              var C;
              return !((C = e.subHeaders) != null && C.length);
            }),
          L(g.options, Ug)
        )),
        (g.getRightLeafHeaders = Q(
          () => [g.getRightFlatHeaders()],
          (I) =>
            I.filter((e) => {
              var C;
              return !((C = e.subHeaders) != null && C.length);
            }),
          L(g.options, Ug)
        )),
        (g.getLeafHeaders = Q(
          () => [
            g.getLeftHeaderGroups(),
            g.getCenterHeaderGroups(),
            g.getRightHeaderGroups(),
          ],
          (I, e, C) => {
            var l, t, n, o, A, c;
            return [
              ...((l = (t = I[0]) == null ? void 0 : t.headers) != null
                ? l
                : []),
              ...((n = (o = e[0]) == null ? void 0 : o.headers) != null
                ? n
                : []),
              ...((A = (c = C[0]) == null ? void 0 : c.headers) != null
                ? A
                : []),
            ]
              .map((d) => d.getLeafHeaders())
              .flat();
          },
          L(g.options, Ug)
        ));
    },
  };
  function vn(g, I, e, C) {
    var l, t;
    let n = 0;
    const o = function (r, u) {
      u === void 0 && (u = 1),
        (n = Math.max(n, u)),
        r
          .filter((b) => b.getIsVisible())
          .forEach((b) => {
            var m;
            (m = b.columns) != null && m.length && o(b.columns, u + 1);
          }, 0);
    };
    o(g);
    let A = [];
    const c = (r, u) => {
        const b = {
            depth: u,
            id: [C, `${u}`].filter(Boolean).join("_"),
            headers: [],
          },
          m = [];
        r.forEach((p) => {
          const G = [...m].reverse()[0],
            Z = p.column.depth === b.depth;
          let B,
            y = !1;
          if (
            (Z && p.column.parent
              ? (B = p.column.parent)
              : ((B = p.column), (y = !0)),
            G && (G == null ? void 0 : G.column) === B)
          )
            G.subHeaders.push(p);
          else {
            const h = ps(e, B, {
              id: [C, u, B.id, p == null ? void 0 : p.id]
                .filter(Boolean)
                .join("_"),
              isPlaceholder: y,
              placeholderId: y
                ? `${m.filter((W) => W.column === B).length}`
                : void 0,
              depth: u,
              index: m.length,
            });
            h.subHeaders.push(p), m.push(h);
          }
          b.headers.push(p), (p.headerGroup = b);
        }),
          A.push(b),
          u > 0 && c(m, u - 1);
      },
      d = I.map((r, u) => ps(e, r, { depth: n, index: u }));
    c(d, n - 1), A.reverse();
    const i = (r) =>
      r
        .filter((b) => b.column.getIsVisible())
        .map((b) => {
          let m = 0,
            p = 0,
            G = [0];
          b.subHeaders && b.subHeaders.length
            ? ((G = []),
              i(b.subHeaders).forEach((B) => {
                let { colSpan: y, rowSpan: h } = B;
                (m += y), G.push(h);
              }))
            : (m = 1);
          const Z = Math.min(...G);
          return (
            (p = p + Z),
            (b.colSpan = m),
            (b.rowSpan = p),
            { colSpan: m, rowSpan: p }
          );
        });
    return i((l = (t = A[0]) == null ? void 0 : t.headers) != null ? l : []), A;
  }
  const Ga = (g, I, e, C, l, t, n) => {
      let o = {
        id: I,
        index: C,
        original: e,
        depth: l,
        parentId: n,
        _valuesCache: {},
        _uniqueValuesCache: {},
        getValue: (A) => {
          if (o._valuesCache.hasOwnProperty(A)) return o._valuesCache[A];
          const c = g.getColumn(A);
          if (c != null && c.accessorFn)
            return (
              (o._valuesCache[A] = c.accessorFn(o.original, C)),
              o._valuesCache[A]
            );
        },
        getUniqueValues: (A) => {
          if (o._uniqueValuesCache.hasOwnProperty(A))
            return o._uniqueValuesCache[A];
          const c = g.getColumn(A);
          if (c != null && c.accessorFn)
            return c.columnDef.getUniqueValues
              ? ((o._uniqueValuesCache[A] = c.columnDef.getUniqueValues(
                  o.original,
                  C
                )),
                o._uniqueValuesCache[A])
              : ((o._uniqueValuesCache[A] = [o.getValue(A)]),
                o._uniqueValuesCache[A]);
        },
        renderValue: (A) => {
          var c;
          return (c = o.getValue(A)) != null
            ? c
            : g.options.renderFallbackValue;
        },
        subRows: [],
        getLeafRows: () => jJ(o.subRows, (A) => A.subRows),
        getParentRow: () => (o.parentId ? g.getRow(o.parentId, !0) : void 0),
        getParentRows: () => {
          let A = [],
            c = o;
          for (;;) {
            const d = c.getParentRow();
            if (!d) break;
            A.push(d), (c = d);
          }
          return A.reverse();
        },
        getAllCells: Q(
          () => [g.getAllLeafColumns()],
          (A) => A.map((c) => PJ(g, o, c, c.id)),
          L(g.options, "debugRows")
        ),
        _getAllCellsByColumnId: Q(
          () => [o.getAllCells()],
          (A) => A.reduce((c, d) => ((c[d.column.id] = d), c), {}),
          L(g.options, "debugRows")
        ),
      };
      for (let A = 0; A < g._features.length; A++) {
        const c = g._features[A];
        c == null || c.createRow == null || c.createRow(o, g);
      }
      return o;
    },
    qJ = {
      createColumn: (g, I) => {
        (g._getFacetedRowModel =
          I.options.getFacetedRowModel &&
          I.options.getFacetedRowModel(I, g.id)),
          (g.getFacetedRowModel = () =>
            g._getFacetedRowModel
              ? g._getFacetedRowModel()
              : I.getPreFilteredRowModel()),
          (g._getFacetedUniqueValues =
            I.options.getFacetedUniqueValues &&
            I.options.getFacetedUniqueValues(I, g.id)),
          (g.getFacetedUniqueValues = () =>
            g._getFacetedUniqueValues
              ? g._getFacetedUniqueValues()
              : new Map()),
          (g._getFacetedMinMaxValues =
            I.options.getFacetedMinMaxValues &&
            I.options.getFacetedMinMaxValues(I, g.id)),
          (g.getFacetedMinMaxValues = () => {
            if (g._getFacetedMinMaxValues) return g._getFacetedMinMaxValues();
          });
      },
    },
    Gb = (g, I, e) => {
      var C, l;
      const t =
        e == null || (C = e.toString()) == null ? void 0 : C.toLowerCase();
      return !!(
        !(
          (l = g.getValue(I)) == null ||
          (l = l.toString()) == null ||
          (l = l.toLowerCase()) == null
        ) && l.includes(t)
      );
    };
  Gb.autoRemove = (g) => KI(g);
  const bb = (g, I, e) => {
    var C;
    return !!(
      !((C = g.getValue(I)) == null || (C = C.toString()) == null) &&
      C.includes(e)
    );
  };
  bb.autoRemove = (g) => KI(g);
  const Bb = (g, I, e) => {
    var C;
    return (
      ((C = g.getValue(I)) == null || (C = C.toString()) == null
        ? void 0
        : C.toLowerCase()) === (e == null ? void 0 : e.toLowerCase())
    );
  };
  Bb.autoRemove = (g) => KI(g);
  const pb = (g, I, e) => {
    var C;
    return (C = g.getValue(I)) == null ? void 0 : C.includes(e);
  };
  pb.autoRemove = (g) => KI(g) || !(g != null && g.length);
  const yb = (g, I, e) =>
    !e.some((C) => {
      var l;
      return !((l = g.getValue(I)) != null && l.includes(C));
    });
  yb.autoRemove = (g) => KI(g) || !(g != null && g.length);
  const hb = (g, I, e) =>
    e.some((C) => {
      var l;
      return (l = g.getValue(I)) == null ? void 0 : l.includes(C);
    });
  hb.autoRemove = (g) => KI(g) || !(g != null && g.length);
  const Sb = (g, I, e) => g.getValue(I) === e;
  Sb.autoRemove = (g) => KI(g);
  const Vb = (g, I, e) => g.getValue(I) == e;
  Vb.autoRemove = (g) => KI(g);
  const ba = (g, I, e) => {
    let [C, l] = e;
    const t = g.getValue(I);
    return t >= C && t <= l;
  };
  ba.resolveFilterValue = (g) => {
    let [I, e] = g,
      C = typeof I != "number" ? parseFloat(I) : I,
      l = typeof e != "number" ? parseFloat(e) : e,
      t = I === null || Number.isNaN(C) ? -1 / 0 : C,
      n = e === null || Number.isNaN(l) ? 1 / 0 : l;
    if (t > n) {
      const o = t;
      (t = n), (n = o);
    }
    return [t, n];
  };
  ba.autoRemove = (g) => KI(g) || (KI(g[0]) && KI(g[1]));
  const le = {
    includesString: Gb,
    includesStringSensitive: bb,
    equalsString: Bb,
    arrIncludes: pb,
    arrIncludesAll: yb,
    arrIncludesSome: hb,
    equals: Sb,
    weakEquals: Vb,
    inNumberRange: ba,
  };
  function KI(g) {
    return g == null || g === "";
  }
  const $J = {
    getDefaultColumnDef: () => ({ filterFn: "auto" }),
    getInitialState: (g) => ({ columnFilters: [], ...g }),
    getDefaultOptions: (g) => ({
      onColumnFiltersChange: mI("columnFilters", g),
      filterFromLeafRows: !1,
      maxLeafRowFilterDepth: 100,
    }),
    createColumn: (g, I) => {
      (g.getAutoFilterFn = () => {
        const e = I.getCoreRowModel().flatRows[0],
          C = e == null ? void 0 : e.getValue(g.id);
        return typeof C == "string"
          ? le.includesString
          : typeof C == "number"
          ? le.inNumberRange
          : typeof C == "boolean" || (C !== null && typeof C == "object")
          ? le.equals
          : Array.isArray(C)
          ? le.arrIncludes
          : le.weakEquals;
      }),
        (g.getFilterFn = () => {
          var e, C;
          return rA(g.columnDef.filterFn)
            ? g.columnDef.filterFn
            : g.columnDef.filterFn === "auto"
            ? g.getAutoFilterFn()
            : (e =
                (C = I.options.filterFns) == null
                  ? void 0
                  : C[g.columnDef.filterFn]) != null
            ? e
            : le[g.columnDef.filterFn];
        }),
        (g.getCanFilter = () => {
          var e, C, l;
          return (
            ((e = g.columnDef.enableColumnFilter) != null ? e : !0) &&
            ((C = I.options.enableColumnFilters) != null ? C : !0) &&
            ((l = I.options.enableFilters) != null ? l : !0) &&
            !!g.accessorFn
          );
        }),
        (g.getIsFiltered = () => g.getFilterIndex() > -1),
        (g.getFilterValue = () => {
          var e;
          return (e = I.getState().columnFilters) == null ||
            (e = e.find((C) => C.id === g.id)) == null
            ? void 0
            : e.value;
        }),
        (g.getFilterIndex = () => {
          var e, C;
          return (e =
            (C = I.getState().columnFilters) == null
              ? void 0
              : C.findIndex((l) => l.id === g.id)) != null
            ? e
            : -1;
        }),
        (g.setFilterValue = (e) => {
          I.setColumnFilters((C) => {
            const l = g.getFilterFn(),
              t = C == null ? void 0 : C.find((d) => d.id === g.id),
              n = Je(e, t ? t.value : void 0);
            if (ys(l, n, g)) {
              var o;
              return (o =
                C == null ? void 0 : C.filter((d) => d.id !== g.id)) != null
                ? o
                : [];
            }
            const A = { id: g.id, value: n };
            if (t) {
              var c;
              return (c =
                C == null ? void 0 : C.map((d) => (d.id === g.id ? A : d))) !=
                null
                ? c
                : [];
            }
            return C != null && C.length ? [...C, A] : [A];
          });
        });
    },
    createRow: (g, I) => {
      (g.columnFilters = {}), (g.columnFiltersMeta = {});
    },
    createTable: (g) => {
      (g.setColumnFilters = (I) => {
        const e = g.getAllLeafColumns(),
          C = (l) => {
            var t;
            return (t = Je(I, l)) == null
              ? void 0
              : t.filter((n) => {
                  const o = e.find((A) => A.id === n.id);
                  if (o) {
                    const A = o.getFilterFn();
                    if (ys(A, n.value, o)) return !1;
                  }
                  return !0;
                });
          };
        g.options.onColumnFiltersChange == null ||
          g.options.onColumnFiltersChange(C);
      }),
        (g.resetColumnFilters = (I) => {
          var e, C;
          g.setColumnFilters(
            I
              ? []
              : (e = (C = g.initialState) == null ? void 0 : C.columnFilters) !=
                null
              ? e
              : []
          );
        }),
        (g.getPreFilteredRowModel = () => g.getCoreRowModel()),
        (g.getFilteredRowModel = () => (
          !g._getFilteredRowModel &&
            g.options.getFilteredRowModel &&
            (g._getFilteredRowModel = g.options.getFilteredRowModel(g)),
          g.options.manualFiltering || !g._getFilteredRowModel
            ? g.getPreFilteredRowModel()
            : g._getFilteredRowModel()
        ));
    },
  };
  function ys(g, I, e) {
    return (
      (g && g.autoRemove ? g.autoRemove(I, e) : !1) ||
      typeof I > "u" ||
      (typeof I == "string" && !I)
    );
  }
  const gv = (g, I, e) =>
      e.reduce((C, l) => {
        const t = l.getValue(g);
        return C + (typeof t == "number" ? t : 0);
      }, 0),
    Iv = (g, I, e) => {
      let C;
      return (
        e.forEach((l) => {
          const t = l.getValue(g);
          t != null && (C > t || (C === void 0 && t >= t)) && (C = t);
        }),
        C
      );
    },
    ev = (g, I, e) => {
      let C;
      return (
        e.forEach((l) => {
          const t = l.getValue(g);
          t != null && (C < t || (C === void 0 && t >= t)) && (C = t);
        }),
        C
      );
    },
    Cv = (g, I, e) => {
      let C, l;
      return (
        e.forEach((t) => {
          const n = t.getValue(g);
          n != null &&
            (C === void 0
              ? n >= n && (C = l = n)
              : (C > n && (C = n), l < n && (l = n)));
        }),
        [C, l]
      );
    },
    lv = (g, I) => {
      let e = 0,
        C = 0;
      if (
        (I.forEach((l) => {
          let t = l.getValue(g);
          t != null && (t = +t) >= t && (++e, (C += t));
        }),
        e)
      )
        return C / e;
    },
    tv = (g, I) => {
      if (!I.length) return;
      const e = I.map((t) => t.getValue(g));
      if (!TJ(e)) return;
      if (e.length === 1) return e[0];
      const C = Math.floor(e.length / 2),
        l = e.sort((t, n) => t - n);
      return e.length % 2 !== 0 ? l[C] : (l[C - 1] + l[C]) / 2;
    },
    nv = (g, I) => Array.from(new Set(I.map((e) => e.getValue(g))).values()),
    ov = (g, I) => new Set(I.map((e) => e.getValue(g))).size,
    Av = (g, I) => I.length,
    ac = {
      sum: gv,
      min: Iv,
      max: ev,
      extent: Cv,
      mean: lv,
      median: tv,
      unique: nv,
      uniqueCount: ov,
      count: Av,
    },
    cv = {
      getDefaultColumnDef: () => ({
        aggregatedCell: (g) => {
          var I, e;
          return (I =
            (e = g.getValue()) == null || e.toString == null
              ? void 0
              : e.toString()) != null
            ? I
            : null;
        },
        aggregationFn: "auto",
      }),
      getInitialState: (g) => ({ grouping: [], ...g }),
      getDefaultOptions: (g) => ({
        onGroupingChange: mI("grouping", g),
        groupedColumnMode: "reorder",
      }),
      createColumn: (g, I) => {
        (g.toggleGrouping = () => {
          I.setGrouping((e) =>
            e != null && e.includes(g.id)
              ? e.filter((C) => C !== g.id)
              : [...(e ?? []), g.id]
          );
        }),
          (g.getCanGroup = () => {
            var e, C;
            return (
              ((e = g.columnDef.enableGrouping) != null ? e : !0) &&
              ((C = I.options.enableGrouping) != null ? C : !0) &&
              (!!g.accessorFn || !!g.columnDef.getGroupingValue)
            );
          }),
          (g.getIsGrouped = () => {
            var e;
            return (e = I.getState().grouping) == null
              ? void 0
              : e.includes(g.id);
          }),
          (g.getGroupedIndex = () => {
            var e;
            return (e = I.getState().grouping) == null
              ? void 0
              : e.indexOf(g.id);
          }),
          (g.getToggleGroupingHandler = () => {
            const e = g.getCanGroup();
            return () => {
              e && g.toggleGrouping();
            };
          }),
          (g.getAutoAggregationFn = () => {
            const e = I.getCoreRowModel().flatRows[0],
              C = e == null ? void 0 : e.getValue(g.id);
            if (typeof C == "number") return ac.sum;
            if (Object.prototype.toString.call(C) === "[object Date]")
              return ac.extent;
          }),
          (g.getAggregationFn = () => {
            var e, C;
            if (!g) throw new Error();
            return rA(g.columnDef.aggregationFn)
              ? g.columnDef.aggregationFn
              : g.columnDef.aggregationFn === "auto"
              ? g.getAutoAggregationFn()
              : (e =
                  (C = I.options.aggregationFns) == null
                    ? void 0
                    : C[g.columnDef.aggregationFn]) != null
              ? e
              : ac[g.columnDef.aggregationFn];
          });
      },
      createTable: (g) => {
        (g.setGrouping = (I) =>
          g.options.onGroupingChange == null
            ? void 0
            : g.options.onGroupingChange(I)),
          (g.resetGrouping = (I) => {
            var e, C;
            g.setGrouping(
              I
                ? []
                : (e = (C = g.initialState) == null ? void 0 : C.grouping) !=
                  null
                ? e
                : []
            );
          }),
          (g.getPreGroupedRowModel = () => g.getFilteredRowModel()),
          (g.getGroupedRowModel = () => (
            !g._getGroupedRowModel &&
              g.options.getGroupedRowModel &&
              (g._getGroupedRowModel = g.options.getGroupedRowModel(g)),
            g.options.manualGrouping || !g._getGroupedRowModel
              ? g.getPreGroupedRowModel()
              : g._getGroupedRowModel()
          ));
      },
      createRow: (g, I) => {
        (g.getIsGrouped = () => !!g.groupingColumnId),
          (g.getGroupingValue = (e) => {
            if (g._groupingValuesCache.hasOwnProperty(e))
              return g._groupingValuesCache[e];
            const C = I.getColumn(e);
            return C != null && C.columnDef.getGroupingValue
              ? ((g._groupingValuesCache[e] = C.columnDef.getGroupingValue(
                  g.original
                )),
                g._groupingValuesCache[e])
              : g.getValue(e);
          }),
          (g._groupingValuesCache = {});
      },
      createCell: (g, I, e, C) => {
        (g.getIsGrouped = () =>
          I.getIsGrouped() && I.id === e.groupingColumnId),
          (g.getIsPlaceholder = () => !g.getIsGrouped() && I.getIsGrouped()),
          (g.getIsAggregated = () => {
            var l;
            return (
              !g.getIsGrouped() &&
              !g.getIsPlaceholder() &&
              !!((l = e.subRows) != null && l.length)
            );
          });
      },
    };
  function dv(g, I, e) {
    if (!(I != null && I.length) || !e) return g;
    const C = g.filter((t) => !I.includes(t.id));
    return e === "remove"
      ? C
      : [...I.map((t) => g.find((n) => n.id === t)).filter(Boolean), ...C];
  }
  const iv = {
      getInitialState: (g) => ({ columnOrder: [], ...g }),
      getDefaultOptions: (g) => ({ onColumnOrderChange: mI("columnOrder", g) }),
      createColumn: (g, I) => {
        (g.getIndex = Q(
          (e) => [lt(I, e)],
          (e) => e.findIndex((C) => C.id === g.id),
          L(I.options, "debugColumns")
        )),
          (g.getIsFirstColumn = (e) => {
            var C;
            return ((C = lt(I, e)[0]) == null ? void 0 : C.id) === g.id;
          }),
          (g.getIsLastColumn = (e) => {
            var C;
            const l = lt(I, e);
            return ((C = l[l.length - 1]) == null ? void 0 : C.id) === g.id;
          });
      },
      createTable: (g) => {
        (g.setColumnOrder = (I) =>
          g.options.onColumnOrderChange == null
            ? void 0
            : g.options.onColumnOrderChange(I)),
          (g.resetColumnOrder = (I) => {
            var e;
            g.setColumnOrder(
              I ? [] : (e = g.initialState.columnOrder) != null ? e : []
            );
          }),
          (g._getOrderColumnsFn = Q(
            () => [
              g.getState().columnOrder,
              g.getState().grouping,
              g.options.groupedColumnMode,
            ],
            (I, e, C) => (l) => {
              let t = [];
              if (!(I != null && I.length)) t = l;
              else {
                const n = [...I],
                  o = [...l];
                for (; o.length && n.length; ) {
                  const A = n.shift(),
                    c = o.findIndex((d) => d.id === A);
                  c > -1 && t.push(o.splice(c, 1)[0]);
                }
                t = [...t, ...o];
              }
              return dv(t, e, C);
            },
            L(g.options, "debugTable")
          ));
      },
    },
    rc = () => ({ left: [], right: [] }),
    av = {
      getInitialState: (g) => ({ columnPinning: rc(), ...g }),
      getDefaultOptions: (g) => ({
        onColumnPinningChange: mI("columnPinning", g),
      }),
      createColumn: (g, I) => {
        (g.pin = (e) => {
          const C = g
            .getLeafColumns()
            .map((l) => l.id)
            .filter(Boolean);
          I.setColumnPinning((l) => {
            var t, n;
            if (e === "right") {
              var o, A;
              return {
                left: ((o = l == null ? void 0 : l.left) != null
                  ? o
                  : []
                ).filter((i) => !(C != null && C.includes(i))),
                right: [
                  ...((A = l == null ? void 0 : l.right) != null
                    ? A
                    : []
                  ).filter((i) => !(C != null && C.includes(i))),
                  ...C,
                ],
              };
            }
            if (e === "left") {
              var c, d;
              return {
                left: [
                  ...((c = l == null ? void 0 : l.left) != null
                    ? c
                    : []
                  ).filter((i) => !(C != null && C.includes(i))),
                  ...C,
                ],
                right: ((d = l == null ? void 0 : l.right) != null
                  ? d
                  : []
                ).filter((i) => !(C != null && C.includes(i))),
              };
            }
            return {
              left: ((t = l == null ? void 0 : l.left) != null ? t : []).filter(
                (i) => !(C != null && C.includes(i))
              ),
              right: ((n = l == null ? void 0 : l.right) != null
                ? n
                : []
              ).filter((i) => !(C != null && C.includes(i))),
            };
          });
        }),
          (g.getCanPin = () =>
            g.getLeafColumns().some((C) => {
              var l, t, n;
              return (
                ((l = C.columnDef.enablePinning) != null ? l : !0) &&
                ((t =
                  (n = I.options.enableColumnPinning) != null
                    ? n
                    : I.options.enablePinning) != null
                  ? t
                  : !0)
              );
            })),
          (g.getIsPinned = () => {
            const e = g.getLeafColumns().map((o) => o.id),
              { left: C, right: l } = I.getState().columnPinning,
              t = e.some((o) => (C == null ? void 0 : C.includes(o))),
              n = e.some((o) => (l == null ? void 0 : l.includes(o)));
            return t ? "left" : n ? "right" : !1;
          }),
          (g.getPinnedIndex = () => {
            var e, C;
            const l = g.getIsPinned();
            return l
              ? (e =
                  (C = I.getState().columnPinning) == null || (C = C[l]) == null
                    ? void 0
                    : C.indexOf(g.id)) != null
                ? e
                : -1
              : 0;
          });
      },
      createRow: (g, I) => {
        (g.getCenterVisibleCells = Q(
          () => [
            g._getAllVisibleCells(),
            I.getState().columnPinning.left,
            I.getState().columnPinning.right,
          ],
          (e, C, l) => {
            const t = [...(C ?? []), ...(l ?? [])];
            return e.filter((n) => !t.includes(n.column.id));
          },
          L(I.options, "debugRows")
        )),
          (g.getLeftVisibleCells = Q(
            () => [g._getAllVisibleCells(), I.getState().columnPinning.left],
            (e, C) =>
              (C ?? [])
                .map((t) => e.find((n) => n.column.id === t))
                .filter(Boolean)
                .map((t) => ({ ...t, position: "left" })),
            L(I.options, "debugRows")
          )),
          (g.getRightVisibleCells = Q(
            () => [g._getAllVisibleCells(), I.getState().columnPinning.right],
            (e, C) =>
              (C ?? [])
                .map((t) => e.find((n) => n.column.id === t))
                .filter(Boolean)
                .map((t) => ({ ...t, position: "right" })),
            L(I.options, "debugRows")
          ));
      },
      createTable: (g) => {
        (g.setColumnPinning = (I) =>
          g.options.onColumnPinningChange == null
            ? void 0
            : g.options.onColumnPinningChange(I)),
          (g.resetColumnPinning = (I) => {
            var e, C;
            return g.setColumnPinning(
              I
                ? rc()
                : (e =
                    (C = g.initialState) == null ? void 0 : C.columnPinning) !=
                  null
                ? e
                : rc()
            );
          }),
          (g.getIsSomeColumnsPinned = (I) => {
            var e;
            const C = g.getState().columnPinning;
            if (!I) {
              var l, t;
              return !!(
                ((l = C.left) != null && l.length) ||
                ((t = C.right) != null && t.length)
              );
            }
            return !!((e = C[I]) != null && e.length);
          }),
          (g.getLeftLeafColumns = Q(
            () => [g.getAllLeafColumns(), g.getState().columnPinning.left],
            (I, e) =>
              (e ?? []).map((C) => I.find((l) => l.id === C)).filter(Boolean),
            L(g.options, "debugColumns")
          )),
          (g.getRightLeafColumns = Q(
            () => [g.getAllLeafColumns(), g.getState().columnPinning.right],
            (I, e) =>
              (e ?? []).map((C) => I.find((l) => l.id === C)).filter(Boolean),
            L(g.options, "debugColumns")
          )),
          (g.getCenterLeafColumns = Q(
            () => [
              g.getAllLeafColumns(),
              g.getState().columnPinning.left,
              g.getState().columnPinning.right,
            ],
            (I, e, C) => {
              const l = [...(e ?? []), ...(C ?? [])];
              return I.filter((t) => !l.includes(t.id));
            },
            L(g.options, "debugColumns")
          ));
      },
    },
    kn = { size: 150, minSize: 20, maxSize: Number.MAX_SAFE_INTEGER },
    sc = () => ({
      startOffset: null,
      startSize: null,
      deltaOffset: null,
      deltaPercentage: null,
      isResizingColumn: !1,
      columnSizingStart: [],
    }),
    rv = {
      getDefaultColumnDef: () => kn,
      getInitialState: (g) => ({
        columnSizing: {},
        columnSizingInfo: sc(),
        ...g,
      }),
      getDefaultOptions: (g) => ({
        columnResizeMode: "onEnd",
        columnResizeDirection: "ltr",
        onColumnSizingChange: mI("columnSizing", g),
        onColumnSizingInfoChange: mI("columnSizingInfo", g),
      }),
      createColumn: (g, I) => {
        (g.getSize = () => {
          var e, C, l;
          const t = I.getState().columnSizing[g.id];
          return Math.min(
            Math.max(
              (e = g.columnDef.minSize) != null ? e : kn.minSize,
              (C = t ?? g.columnDef.size) != null ? C : kn.size
            ),
            (l = g.columnDef.maxSize) != null ? l : kn.maxSize
          );
        }),
          (g.getStart = Q(
            (e) => [e, lt(I, e), I.getState().columnSizing],
            (e, C) =>
              C.slice(0, g.getIndex(e)).reduce((l, t) => l + t.getSize(), 0),
            L(I.options, "debugColumns")
          )),
          (g.getAfter = Q(
            (e) => [e, lt(I, e), I.getState().columnSizing],
            (e, C) =>
              C.slice(g.getIndex(e) + 1).reduce((l, t) => l + t.getSize(), 0),
            L(I.options, "debugColumns")
          )),
          (g.resetSize = () => {
            I.setColumnSizing((e) => {
              let { [g.id]: C, ...l } = e;
              return l;
            });
          }),
          (g.getCanResize = () => {
            var e, C;
            return (
              ((e = g.columnDef.enableResizing) != null ? e : !0) &&
              ((C = I.options.enableColumnResizing) != null ? C : !0)
            );
          }),
          (g.getIsResizing = () =>
            I.getState().columnSizingInfo.isResizingColumn === g.id);
      },
      createHeader: (g, I) => {
        (g.getSize = () => {
          let e = 0;
          const C = (l) => {
            if (l.subHeaders.length) l.subHeaders.forEach(C);
            else {
              var t;
              e += (t = l.column.getSize()) != null ? t : 0;
            }
          };
          return C(g), e;
        }),
          (g.getStart = () => {
            if (g.index > 0) {
              const e = g.headerGroup.headers[g.index - 1];
              return e.getStart() + e.getSize();
            }
            return 0;
          }),
          (g.getResizeHandler = (e) => {
            const C = I.getColumn(g.column.id),
              l = C == null ? void 0 : C.getCanResize();
            return (t) => {
              if (
                !C ||
                !l ||
                (t.persist == null || t.persist(),
                uc(t) && t.touches && t.touches.length > 1)
              )
                return;
              const n = g.getSize(),
                o = g
                  ? g
                      .getLeafHeaders()
                      .map((G) => [G.column.id, G.column.getSize()])
                  : [[C.id, C.getSize()]],
                A = uc(t) ? Math.round(t.touches[0].clientX) : t.clientX,
                c = {},
                d = (G, Z) => {
                  typeof Z == "number" &&
                    (I.setColumnSizingInfo((B) => {
                      var y, h;
                      const W =
                          I.options.columnResizeDirection === "rtl" ? -1 : 1,
                        S =
                          (Z -
                            ((y = B == null ? void 0 : B.startOffset) != null
                              ? y
                              : 0)) *
                          W,
                        V = Math.max(
                          S /
                            ((h = B == null ? void 0 : B.startSize) != null
                              ? h
                              : 0),
                          -0.999999
                        );
                      return (
                        B.columnSizingStart.forEach((f) => {
                          let [k, F] = f;
                          c[k] = Math.round(Math.max(F + F * V, 0) * 100) / 100;
                        }),
                        { ...B, deltaOffset: S, deltaPercentage: V }
                      );
                    }),
                    (I.options.columnResizeMode === "onChange" ||
                      G === "end") &&
                      I.setColumnSizing((B) => ({ ...B, ...c })));
                },
                i = (G) => d("move", G),
                r = (G) => {
                  d("end", G),
                    I.setColumnSizingInfo((Z) => ({
                      ...Z,
                      isResizingColumn: !1,
                      startOffset: null,
                      startSize: null,
                      deltaOffset: null,
                      deltaPercentage: null,
                      columnSizingStart: [],
                    }));
                },
                u = e || typeof document < "u" ? document : null,
                b = {
                  moveHandler: (G) => i(G.clientX),
                  upHandler: (G) => {
                    u == null ||
                      u.removeEventListener("mousemove", b.moveHandler),
                      u == null ||
                        u.removeEventListener("mouseup", b.upHandler),
                      r(G.clientX);
                  },
                },
                m = {
                  moveHandler: (G) => (
                    G.cancelable && (G.preventDefault(), G.stopPropagation()),
                    i(G.touches[0].clientX),
                    !1
                  ),
                  upHandler: (G) => {
                    var Z;
                    u == null ||
                      u.removeEventListener("touchmove", m.moveHandler),
                      u == null ||
                        u.removeEventListener("touchend", m.upHandler),
                      G.cancelable && (G.preventDefault(), G.stopPropagation()),
                      r((Z = G.touches[0]) == null ? void 0 : Z.clientX);
                  },
                },
                p = sv() ? { passive: !1 } : !1;
              uc(t)
                ? (u == null ||
                    u.addEventListener("touchmove", m.moveHandler, p),
                  u == null || u.addEventListener("touchend", m.upHandler, p))
                : (u == null ||
                    u.addEventListener("mousemove", b.moveHandler, p),
                  u == null || u.addEventListener("mouseup", b.upHandler, p)),
                I.setColumnSizingInfo((G) => ({
                  ...G,
                  startOffset: A,
                  startSize: n,
                  deltaOffset: 0,
                  deltaPercentage: 0,
                  columnSizingStart: o,
                  isResizingColumn: C.id,
                }));
            };
          });
      },
      createTable: (g) => {
        (g.setColumnSizing = (I) =>
          g.options.onColumnSizingChange == null
            ? void 0
            : g.options.onColumnSizingChange(I)),
          (g.setColumnSizingInfo = (I) =>
            g.options.onColumnSizingInfoChange == null
              ? void 0
              : g.options.onColumnSizingInfoChange(I)),
          (g.resetColumnSizing = (I) => {
            var e;
            g.setColumnSizing(
              I ? {} : (e = g.initialState.columnSizing) != null ? e : {}
            );
          }),
          (g.resetHeaderSizeInfo = (I) => {
            var e;
            g.setColumnSizingInfo(
              I
                ? sc()
                : (e = g.initialState.columnSizingInfo) != null
                ? e
                : sc()
            );
          }),
          (g.getTotalSize = () => {
            var I, e;
            return (I =
              (e = g.getHeaderGroups()[0]) == null
                ? void 0
                : e.headers.reduce((C, l) => C + l.getSize(), 0)) != null
              ? I
              : 0;
          }),
          (g.getLeftTotalSize = () => {
            var I, e;
            return (I =
              (e = g.getLeftHeaderGroups()[0]) == null
                ? void 0
                : e.headers.reduce((C, l) => C + l.getSize(), 0)) != null
              ? I
              : 0;
          }),
          (g.getCenterTotalSize = () => {
            var I, e;
            return (I =
              (e = g.getCenterHeaderGroups()[0]) == null
                ? void 0
                : e.headers.reduce((C, l) => C + l.getSize(), 0)) != null
              ? I
              : 0;
          }),
          (g.getRightTotalSize = () => {
            var I, e;
            return (I =
              (e = g.getRightHeaderGroups()[0]) == null
                ? void 0
                : e.headers.reduce((C, l) => C + l.getSize(), 0)) != null
              ? I
              : 0;
          });
      },
    };
  let fn = null;
  function sv() {
    if (typeof fn == "boolean") return fn;
    let g = !1;
    try {
      const I = {
          get passive() {
            return (g = !0), !1;
          },
        },
        e = () => {};
      window.addEventListener("test", e, I),
        window.removeEventListener("test", e);
    } catch {
      g = !1;
    }
    return (fn = g), fn;
  }
  function uc(g) {
    return g.type === "touchstart";
  }
  const uv = {
    getInitialState: (g) => ({ columnVisibility: {}, ...g }),
    getDefaultOptions: (g) => ({
      onColumnVisibilityChange: mI("columnVisibility", g),
    }),
    createColumn: (g, I) => {
      (g.toggleVisibility = (e) => {
        g.getCanHide() &&
          I.setColumnVisibility((C) => ({
            ...C,
            [g.id]: e ?? !g.getIsVisible(),
          }));
      }),
        (g.getIsVisible = () => {
          var e, C;
          const l = g.columns;
          return (e = l.length
            ? l.some((t) => t.getIsVisible())
            : (C = I.getState().columnVisibility) == null
            ? void 0
            : C[g.id]) != null
            ? e
            : !0;
        }),
        (g.getCanHide = () => {
          var e, C;
          return (
            ((e = g.columnDef.enableHiding) != null ? e : !0) &&
            ((C = I.options.enableHiding) != null ? C : !0)
          );
        }),
        (g.getToggleVisibilityHandler = () => (e) => {
          g.toggleVisibility == null || g.toggleVisibility(e.target.checked);
        });
    },
    createRow: (g, I) => {
      (g._getAllVisibleCells = Q(
        () => [g.getAllCells(), I.getState().columnVisibility],
        (e) => e.filter((C) => C.column.getIsVisible()),
        L(I.options, "debugRows")
      )),
        (g.getVisibleCells = Q(
          () => [
            g.getLeftVisibleCells(),
            g.getCenterVisibleCells(),
            g.getRightVisibleCells(),
          ],
          (e, C, l) => [...e, ...C, ...l],
          L(I.options, "debugRows")
        ));
    },
    createTable: (g) => {
      const I = (e, C) =>
        Q(
          () => [
            C(),
            C()
              .filter((l) => l.getIsVisible())
              .map((l) => l.id)
              .join("_"),
          ],
          (l) =>
            l.filter((t) =>
              t.getIsVisible == null ? void 0 : t.getIsVisible()
            ),
          L(g.options, "debugColumns")
        );
      (g.getVisibleFlatColumns = I("getVisibleFlatColumns", () =>
        g.getAllFlatColumns()
      )),
        (g.getVisibleLeafColumns = I("getVisibleLeafColumns", () =>
          g.getAllLeafColumns()
        )),
        (g.getLeftVisibleLeafColumns = I("getLeftVisibleLeafColumns", () =>
          g.getLeftLeafColumns()
        )),
        (g.getRightVisibleLeafColumns = I("getRightVisibleLeafColumns", () =>
          g.getRightLeafColumns()
        )),
        (g.getCenterVisibleLeafColumns = I("getCenterVisibleLeafColumns", () =>
          g.getCenterLeafColumns()
        )),
        (g.setColumnVisibility = (e) =>
          g.options.onColumnVisibilityChange == null
            ? void 0
            : g.options.onColumnVisibilityChange(e)),
        (g.resetColumnVisibility = (e) => {
          var C;
          g.setColumnVisibility(
            e ? {} : (C = g.initialState.columnVisibility) != null ? C : {}
          );
        }),
        (g.toggleAllColumnsVisible = (e) => {
          var C;
          (e = (C = e) != null ? C : !g.getIsAllColumnsVisible()),
            g.setColumnVisibility(
              g
                .getAllLeafColumns()
                .reduce(
                  (l, t) => ({
                    ...l,
                    [t.id]: e || !(t.getCanHide != null && t.getCanHide()),
                  }),
                  {}
                )
            );
        }),
        (g.getIsAllColumnsVisible = () =>
          !g
            .getAllLeafColumns()
            .some((e) => !(e.getIsVisible != null && e.getIsVisible()))),
        (g.getIsSomeColumnsVisible = () =>
          g
            .getAllLeafColumns()
            .some((e) => (e.getIsVisible == null ? void 0 : e.getIsVisible()))),
        (g.getToggleAllColumnsVisibilityHandler = () => (e) => {
          var C;
          g.toggleAllColumnsVisible(
            (C = e.target) == null ? void 0 : C.checked
          );
        });
    },
  };
  function lt(g, I) {
    return I
      ? I === "center"
        ? g.getCenterVisibleLeafColumns()
        : I === "left"
        ? g.getLeftVisibleLeafColumns()
        : g.getRightVisibleLeafColumns()
      : g.getVisibleLeafColumns();
  }
  const mv = {
      createTable: (g) => {
        (g._getGlobalFacetedRowModel =
          g.options.getFacetedRowModel &&
          g.options.getFacetedRowModel(g, "__global__")),
          (g.getGlobalFacetedRowModel = () =>
            g.options.manualFiltering || !g._getGlobalFacetedRowModel
              ? g.getPreFilteredRowModel()
              : g._getGlobalFacetedRowModel()),
          (g._getGlobalFacetedUniqueValues =
            g.options.getFacetedUniqueValues &&
            g.options.getFacetedUniqueValues(g, "__global__")),
          (g.getGlobalFacetedUniqueValues = () =>
            g._getGlobalFacetedUniqueValues
              ? g._getGlobalFacetedUniqueValues()
              : new Map()),
          (g._getGlobalFacetedMinMaxValues =
            g.options.getFacetedMinMaxValues &&
            g.options.getFacetedMinMaxValues(g, "__global__")),
          (g.getGlobalFacetedMinMaxValues = () => {
            if (g._getGlobalFacetedMinMaxValues)
              return g._getGlobalFacetedMinMaxValues();
          });
      },
    },
    Zv = {
      getInitialState: (g) => ({ globalFilter: void 0, ...g }),
      getDefaultOptions: (g) => ({
        onGlobalFilterChange: mI("globalFilter", g),
        globalFilterFn: "auto",
        getColumnCanGlobalFilter: (I) => {
          var e;
          const C =
            (e = g.getCoreRowModel().flatRows[0]) == null ||
            (e = e._getAllCellsByColumnId()[I.id]) == null
              ? void 0
              : e.getValue();
          return typeof C == "string" || typeof C == "number";
        },
      }),
      createColumn: (g, I) => {
        g.getCanGlobalFilter = () => {
          var e, C, l, t;
          return (
            ((e = g.columnDef.enableGlobalFilter) != null ? e : !0) &&
            ((C = I.options.enableGlobalFilter) != null ? C : !0) &&
            ((l = I.options.enableFilters) != null ? l : !0) &&
            ((t =
              I.options.getColumnCanGlobalFilter == null
                ? void 0
                : I.options.getColumnCanGlobalFilter(g)) != null
              ? t
              : !0) &&
            !!g.accessorFn
          );
        };
      },
      createTable: (g) => {
        (g.getGlobalAutoFilterFn = () => le.includesString),
          (g.getGlobalFilterFn = () => {
            var I, e;
            const { globalFilterFn: C } = g.options;
            return rA(C)
              ? C
              : C === "auto"
              ? g.getGlobalAutoFilterFn()
              : (I = (e = g.options.filterFns) == null ? void 0 : e[C]) != null
              ? I
              : le[C];
          }),
          (g.setGlobalFilter = (I) => {
            g.options.onGlobalFilterChange == null ||
              g.options.onGlobalFilterChange(I);
          }),
          (g.resetGlobalFilter = (I) => {
            g.setGlobalFilter(I ? void 0 : g.initialState.globalFilter);
          });
      },
    },
    Gv = {
      getInitialState: (g) => ({ expanded: {}, ...g }),
      getDefaultOptions: (g) => ({
        onExpandedChange: mI("expanded", g),
        paginateExpandedRows: !0,
      }),
      createTable: (g) => {
        let I = !1,
          e = !1;
        (g._autoResetExpanded = () => {
          var C, l;
          if (!I) {
            g._queue(() => {
              I = !0;
            });
            return;
          }
          if (
            (C =
              (l = g.options.autoResetAll) != null
                ? l
                : g.options.autoResetExpanded) != null
              ? C
              : !g.options.manualExpanding
          ) {
            if (e) return;
            (e = !0),
              g._queue(() => {
                g.resetExpanded(), (e = !1);
              });
          }
        }),
          (g.setExpanded = (C) =>
            g.options.onExpandedChange == null
              ? void 0
              : g.options.onExpandedChange(C)),
          (g.toggleAllRowsExpanded = (C) => {
            C ?? !g.getIsAllRowsExpanded()
              ? g.setExpanded(!0)
              : g.setExpanded({});
          }),
          (g.resetExpanded = (C) => {
            var l, t;
            g.setExpanded(
              C
                ? {}
                : (l = (t = g.initialState) == null ? void 0 : t.expanded) !=
                  null
                ? l
                : {}
            );
          }),
          (g.getCanSomeRowsExpand = () =>
            g
              .getPrePaginationRowModel()
              .flatRows.some((C) => C.getCanExpand())),
          (g.getToggleAllRowsExpandedHandler = () => (C) => {
            C.persist == null || C.persist(), g.toggleAllRowsExpanded();
          }),
          (g.getIsSomeRowsExpanded = () => {
            const C = g.getState().expanded;
            return C === !0 || Object.values(C).some(Boolean);
          }),
          (g.getIsAllRowsExpanded = () => {
            const C = g.getState().expanded;
            return typeof C == "boolean"
              ? C === !0
              : !(
                  !Object.keys(C).length ||
                  g.getRowModel().flatRows.some((l) => !l.getIsExpanded())
                );
          }),
          (g.getExpandedDepth = () => {
            let C = 0;
            return (
              (g.getState().expanded === !0
                ? Object.keys(g.getRowModel().rowsById)
                : Object.keys(g.getState().expanded)
              ).forEach((t) => {
                const n = t.split(".");
                C = Math.max(C, n.length);
              }),
              C
            );
          }),
          (g.getPreExpandedRowModel = () => g.getSortedRowModel()),
          (g.getExpandedRowModel = () => (
            !g._getExpandedRowModel &&
              g.options.getExpandedRowModel &&
              (g._getExpandedRowModel = g.options.getExpandedRowModel(g)),
            g.options.manualExpanding || !g._getExpandedRowModel
              ? g.getPreExpandedRowModel()
              : g._getExpandedRowModel()
          ));
      },
      createRow: (g, I) => {
        (g.toggleExpanded = (e) => {
          I.setExpanded((C) => {
            var l;
            const t = C === !0 ? !0 : !!(C != null && C[g.id]);
            let n = {};
            if (
              (C === !0
                ? Object.keys(I.getRowModel().rowsById).forEach((o) => {
                    n[o] = !0;
                  })
                : (n = C),
              (e = (l = e) != null ? l : !t),
              !t && e)
            )
              return { ...n, [g.id]: !0 };
            if (t && !e) {
              const { [g.id]: o, ...A } = n;
              return A;
            }
            return C;
          });
        }),
          (g.getIsExpanded = () => {
            var e;
            const C = I.getState().expanded;
            return !!((e =
              I.options.getIsRowExpanded == null
                ? void 0
                : I.options.getIsRowExpanded(g)) != null
              ? e
              : C === !0 || (C != null && C[g.id]));
          }),
          (g.getCanExpand = () => {
            var e, C, l;
            return (e =
              I.options.getRowCanExpand == null
                ? void 0
                : I.options.getRowCanExpand(g)) != null
              ? e
              : ((C = I.options.enableExpanding) != null ? C : !0) &&
                  !!((l = g.subRows) != null && l.length);
          }),
          (g.getIsAllParentsExpanded = () => {
            let e = !0,
              C = g;
            for (; e && C.parentId; )
              (C = I.getRow(C.parentId, !0)), (e = C.getIsExpanded());
            return e;
          }),
          (g.getToggleExpandedHandler = () => {
            const e = g.getCanExpand();
            return () => {
              e && g.toggleExpanded();
            };
          });
      },
    },
    fd = 0,
    Yd = 10,
    mc = () => ({ pageIndex: fd, pageSize: Yd }),
    bv = {
      getInitialState: (g) => ({
        ...g,
        pagination: { ...mc(), ...(g == null ? void 0 : g.pagination) },
      }),
      getDefaultOptions: (g) => ({ onPaginationChange: mI("pagination", g) }),
      createTable: (g) => {
        let I = !1,
          e = !1;
        (g._autoResetPageIndex = () => {
          var C, l;
          if (!I) {
            g._queue(() => {
              I = !0;
            });
            return;
          }
          if (
            (C =
              (l = g.options.autoResetAll) != null
                ? l
                : g.options.autoResetPageIndex) != null
              ? C
              : !g.options.manualPagination
          ) {
            if (e) return;
            (e = !0),
              g._queue(() => {
                g.resetPageIndex(), (e = !1);
              });
          }
        }),
          (g.setPagination = (C) => {
            const l = (t) => Je(C, t);
            return g.options.onPaginationChange == null
              ? void 0
              : g.options.onPaginationChange(l);
          }),
          (g.resetPagination = (C) => {
            var l;
            g.setPagination(
              C ? mc() : (l = g.initialState.pagination) != null ? l : mc()
            );
          }),
          (g.setPageIndex = (C) => {
            g.setPagination((l) => {
              let t = Je(C, l.pageIndex);
              const n =
                typeof g.options.pageCount > "u" || g.options.pageCount === -1
                  ? Number.MAX_SAFE_INTEGER
                  : g.options.pageCount - 1;
              return (t = Math.max(0, Math.min(t, n))), { ...l, pageIndex: t };
            });
          }),
          (g.resetPageIndex = (C) => {
            var l, t;
            g.setPageIndex(
              C
                ? fd
                : (l =
                    (t = g.initialState) == null || (t = t.pagination) == null
                      ? void 0
                      : t.pageIndex) != null
                ? l
                : fd
            );
          }),
          (g.resetPageSize = (C) => {
            var l, t;
            g.setPageSize(
              C
                ? Yd
                : (l =
                    (t = g.initialState) == null || (t = t.pagination) == null
                      ? void 0
                      : t.pageSize) != null
                ? l
                : Yd
            );
          }),
          (g.setPageSize = (C) => {
            g.setPagination((l) => {
              const t = Math.max(1, Je(C, l.pageSize)),
                n = l.pageSize * l.pageIndex,
                o = Math.floor(n / t);
              return { ...l, pageIndex: o, pageSize: t };
            });
          }),
          (g.setPageCount = (C) =>
            g.setPagination((l) => {
              var t;
              let n = Je(C, (t = g.options.pageCount) != null ? t : -1);
              return (
                typeof n == "number" && (n = Math.max(-1, n)),
                { ...l, pageCount: n }
              );
            })),
          (g.getPageOptions = Q(
            () => [g.getPageCount()],
            (C) => {
              let l = [];
              return (
                C &&
                  C > 0 &&
                  (l = [...new Array(C)].fill(null).map((t, n) => n)),
                l
              );
            },
            L(g.options, "debugTable")
          )),
          (g.getCanPreviousPage = () => g.getState().pagination.pageIndex > 0),
          (g.getCanNextPage = () => {
            const { pageIndex: C } = g.getState().pagination,
              l = g.getPageCount();
            return l === -1 ? !0 : l === 0 ? !1 : C < l - 1;
          }),
          (g.previousPage = () => g.setPageIndex((C) => C - 1)),
          (g.nextPage = () => g.setPageIndex((C) => C + 1)),
          (g.firstPage = () => g.setPageIndex(0)),
          (g.lastPage = () => g.setPageIndex(g.getPageCount() - 1)),
          (g.getPrePaginationRowModel = () => g.getExpandedRowModel()),
          (g.getPaginationRowModel = () => (
            !g._getPaginationRowModel &&
              g.options.getPaginationRowModel &&
              (g._getPaginationRowModel = g.options.getPaginationRowModel(g)),
            g.options.manualPagination || !g._getPaginationRowModel
              ? g.getPrePaginationRowModel()
              : g._getPaginationRowModel()
          )),
          (g.getPageCount = () => {
            var C;
            return (C = g.options.pageCount) != null
              ? C
              : Math.ceil(g.getRowCount() / g.getState().pagination.pageSize);
          }),
          (g.getRowCount = () => {
            var C;
            return (C = g.options.rowCount) != null
              ? C
              : g.getPrePaginationRowModel().rows.length;
          });
      },
    },
    Zc = () => ({ top: [], bottom: [] }),
    Bv = {
      getInitialState: (g) => ({ rowPinning: Zc(), ...g }),
      getDefaultOptions: (g) => ({ onRowPinningChange: mI("rowPinning", g) }),
      createRow: (g, I) => {
        (g.pin = (e, C, l) => {
          const t = C
              ? g.getLeafRows().map((A) => {
                  let { id: c } = A;
                  return c;
                })
              : [],
            n = l
              ? g.getParentRows().map((A) => {
                  let { id: c } = A;
                  return c;
                })
              : [],
            o = new Set([...n, g.id, ...t]);
          I.setRowPinning((A) => {
            var c, d;
            if (e === "bottom") {
              var i, r;
              return {
                top: ((i = A == null ? void 0 : A.top) != null ? i : []).filter(
                  (m) => !(o != null && o.has(m))
                ),
                bottom: [
                  ...((r = A == null ? void 0 : A.bottom) != null
                    ? r
                    : []
                  ).filter((m) => !(o != null && o.has(m))),
                  ...Array.from(o),
                ],
              };
            }
            if (e === "top") {
              var u, b;
              return {
                top: [
                  ...((u = A == null ? void 0 : A.top) != null ? u : []).filter(
                    (m) => !(o != null && o.has(m))
                  ),
                  ...Array.from(o),
                ],
                bottom: ((b = A == null ? void 0 : A.bottom) != null
                  ? b
                  : []
                ).filter((m) => !(o != null && o.has(m))),
              };
            }
            return {
              top: ((c = A == null ? void 0 : A.top) != null ? c : []).filter(
                (m) => !(o != null && o.has(m))
              ),
              bottom: ((d = A == null ? void 0 : A.bottom) != null
                ? d
                : []
              ).filter((m) => !(o != null && o.has(m))),
            };
          });
        }),
          (g.getCanPin = () => {
            var e;
            const { enableRowPinning: C, enablePinning: l } = I.options;
            return typeof C == "function"
              ? C(g)
              : (e = C ?? l) != null
              ? e
              : !0;
          }),
          (g.getIsPinned = () => {
            const e = [g.id],
              { top: C, bottom: l } = I.getState().rowPinning,
              t = e.some((o) => (C == null ? void 0 : C.includes(o))),
              n = e.some((o) => (l == null ? void 0 : l.includes(o)));
            return t ? "top" : n ? "bottom" : !1;
          }),
          (g.getPinnedIndex = () => {
            var e, C;
            const l = g.getIsPinned();
            if (!l) return -1;
            const t =
              (e = l === "top" ? I.getTopRows() : I.getBottomRows()) == null
                ? void 0
                : e.map((n) => {
                    let { id: o } = n;
                    return o;
                  });
            return (C = t == null ? void 0 : t.indexOf(g.id)) != null ? C : -1;
          });
      },
      createTable: (g) => {
        (g.setRowPinning = (I) =>
          g.options.onRowPinningChange == null
            ? void 0
            : g.options.onRowPinningChange(I)),
          (g.resetRowPinning = (I) => {
            var e, C;
            return g.setRowPinning(
              I
                ? Zc()
                : (e = (C = g.initialState) == null ? void 0 : C.rowPinning) !=
                  null
                ? e
                : Zc()
            );
          }),
          (g.getIsSomeRowsPinned = (I) => {
            var e;
            const C = g.getState().rowPinning;
            if (!I) {
              var l, t;
              return !!(
                ((l = C.top) != null && l.length) ||
                ((t = C.bottom) != null && t.length)
              );
            }
            return !!((e = C[I]) != null && e.length);
          }),
          (g._getPinnedRows = (I, e, C) => {
            var l;
            return (
              (l = g.options.keepPinnedRows) == null || l
                ? (e ?? []).map((n) => {
                    const o = g.getRow(n, !0);
                    return o.getIsAllParentsExpanded() ? o : null;
                  })
                : (e ?? []).map((n) => I.find((o) => o.id === n))
            )
              .filter(Boolean)
              .map((n) => ({ ...n, position: C }));
          }),
          (g.getTopRows = Q(
            () => [g.getRowModel().rows, g.getState().rowPinning.top],
            (I, e) => g._getPinnedRows(I, e, "top"),
            L(g.options, "debugRows")
          )),
          (g.getBottomRows = Q(
            () => [g.getRowModel().rows, g.getState().rowPinning.bottom],
            (I, e) => g._getPinnedRows(I, e, "bottom"),
            L(g.options, "debugRows")
          )),
          (g.getCenterRows = Q(
            () => [
              g.getRowModel().rows,
              g.getState().rowPinning.top,
              g.getState().rowPinning.bottom,
            ],
            (I, e, C) => {
              const l = new Set([...(e ?? []), ...(C ?? [])]);
              return I.filter((t) => !l.has(t.id));
            },
            L(g.options, "debugRows")
          ));
      },
    },
    pv = {
      getInitialState: (g) => ({ rowSelection: {}, ...g }),
      getDefaultOptions: (g) => ({
        onRowSelectionChange: mI("rowSelection", g),
        enableRowSelection: !0,
        enableMultiRowSelection: !0,
        enableSubRowSelection: !0,
      }),
      createTable: (g) => {
        (g.setRowSelection = (I) =>
          g.options.onRowSelectionChange == null
            ? void 0
            : g.options.onRowSelectionChange(I)),
          (g.resetRowSelection = (I) => {
            var e;
            return g.setRowSelection(
              I ? {} : (e = g.initialState.rowSelection) != null ? e : {}
            );
          }),
          (g.toggleAllRowsSelected = (I) => {
            g.setRowSelection((e) => {
              I = typeof I < "u" ? I : !g.getIsAllRowsSelected();
              const C = { ...e },
                l = g.getPreGroupedRowModel().flatRows;
              return (
                I
                  ? l.forEach((t) => {
                      t.getCanSelect() && (C[t.id] = !0);
                    })
                  : l.forEach((t) => {
                      delete C[t.id];
                    }),
                C
              );
            });
          }),
          (g.toggleAllPageRowsSelected = (I) =>
            g.setRowSelection((e) => {
              const C = typeof I < "u" ? I : !g.getIsAllPageRowsSelected(),
                l = { ...e };
              return (
                g.getRowModel().rows.forEach((t) => {
                  Hd(l, t.id, C, !0, g);
                }),
                l
              );
            })),
          (g.getPreSelectedRowModel = () => g.getCoreRowModel()),
          (g.getSelectedRowModel = Q(
            () => [g.getState().rowSelection, g.getCoreRowModel()],
            (I, e) =>
              Object.keys(I).length
                ? Gc(g, e)
                : { rows: [], flatRows: [], rowsById: {} },
            L(g.options, "debugTable")
          )),
          (g.getFilteredSelectedRowModel = Q(
            () => [g.getState().rowSelection, g.getFilteredRowModel()],
            (I, e) =>
              Object.keys(I).length
                ? Gc(g, e)
                : { rows: [], flatRows: [], rowsById: {} },
            L(g.options, "debugTable")
          )),
          (g.getGroupedSelectedRowModel = Q(
            () => [g.getState().rowSelection, g.getSortedRowModel()],
            (I, e) =>
              Object.keys(I).length
                ? Gc(g, e)
                : { rows: [], flatRows: [], rowsById: {} },
            L(g.options, "debugTable")
          )),
          (g.getIsAllRowsSelected = () => {
            const I = g.getFilteredRowModel().flatRows,
              { rowSelection: e } = g.getState();
            let C = !!(I.length && Object.keys(e).length);
            return (
              C && I.some((l) => l.getCanSelect() && !e[l.id]) && (C = !1), C
            );
          }),
          (g.getIsAllPageRowsSelected = () => {
            const I = g
                .getPaginationRowModel()
                .flatRows.filter((l) => l.getCanSelect()),
              { rowSelection: e } = g.getState();
            let C = !!I.length;
            return C && I.some((l) => !e[l.id]) && (C = !1), C;
          }),
          (g.getIsSomeRowsSelected = () => {
            var I;
            const e = Object.keys(
              (I = g.getState().rowSelection) != null ? I : {}
            ).length;
            return e > 0 && e < g.getFilteredRowModel().flatRows.length;
          }),
          (g.getIsSomePageRowsSelected = () => {
            const I = g.getPaginationRowModel().flatRows;
            return g.getIsAllPageRowsSelected()
              ? !1
              : I.filter((e) => e.getCanSelect()).some(
                  (e) => e.getIsSelected() || e.getIsSomeSelected()
                );
          }),
          (g.getToggleAllRowsSelectedHandler = () => (I) => {
            g.toggleAllRowsSelected(I.target.checked);
          }),
          (g.getToggleAllPageRowsSelectedHandler = () => (I) => {
            g.toggleAllPageRowsSelected(I.target.checked);
          });
      },
      createRow: (g, I) => {
        (g.toggleSelected = (e, C) => {
          const l = g.getIsSelected();
          I.setRowSelection((t) => {
            var n;
            if (((e = typeof e < "u" ? e : !l), g.getCanSelect() && l === e))
              return t;
            const o = { ...t };
            return (
              Hd(
                o,
                g.id,
                e,
                (n = C == null ? void 0 : C.selectChildren) != null ? n : !0,
                I
              ),
              o
            );
          });
        }),
          (g.getIsSelected = () => {
            const { rowSelection: e } = I.getState();
            return Ba(g, e);
          }),
          (g.getIsSomeSelected = () => {
            const { rowSelection: e } = I.getState();
            return wd(g, e) === "some";
          }),
          (g.getIsAllSubRowsSelected = () => {
            const { rowSelection: e } = I.getState();
            return wd(g, e) === "all";
          }),
          (g.getCanSelect = () => {
            var e;
            return typeof I.options.enableRowSelection == "function"
              ? I.options.enableRowSelection(g)
              : (e = I.options.enableRowSelection) != null
              ? e
              : !0;
          }),
          (g.getCanSelectSubRows = () => {
            var e;
            return typeof I.options.enableSubRowSelection == "function"
              ? I.options.enableSubRowSelection(g)
              : (e = I.options.enableSubRowSelection) != null
              ? e
              : !0;
          }),
          (g.getCanMultiSelect = () => {
            var e;
            return typeof I.options.enableMultiRowSelection == "function"
              ? I.options.enableMultiRowSelection(g)
              : (e = I.options.enableMultiRowSelection) != null
              ? e
              : !0;
          }),
          (g.getToggleSelectedHandler = () => {
            const e = g.getCanSelect();
            return (C) => {
              var l;
              e &&
                g.toggleSelected((l = C.target) == null ? void 0 : l.checked);
            };
          });
      },
    },
    Hd = (g, I, e, C, l) => {
      var t;
      const n = l.getRow(I, !0);
      e
        ? (n.getCanMultiSelect() || Object.keys(g).forEach((o) => delete g[o]),
          n.getCanSelect() && (g[I] = !0))
        : delete g[I],
        C &&
          (t = n.subRows) != null &&
          t.length &&
          n.getCanSelectSubRows() &&
          n.subRows.forEach((o) => Hd(g, o.id, e, C, l));
    };
  function Gc(g, I) {
    const e = g.getState().rowSelection,
      C = [],
      l = {},
      t = function (n, o) {
        return n
          .map((A) => {
            var c;
            const d = Ba(A, e);
            if (
              (d && (C.push(A), (l[A.id] = A)),
              (c = A.subRows) != null &&
                c.length &&
                (A = { ...A, subRows: t(A.subRows) }),
              d)
            )
              return A;
          })
          .filter(Boolean);
      };
    return { rows: t(I.rows), flatRows: C, rowsById: l };
  }
  function Ba(g, I) {
    var e;
    return (e = I[g.id]) != null ? e : !1;
  }
  function wd(g, I, e) {
    var C;
    if (!((C = g.subRows) != null && C.length)) return !1;
    let l = !0,
      t = !1;
    return (
      g.subRows.forEach((n) => {
        if (
          !(t && !l) &&
          (n.getCanSelect() && (Ba(n, I) ? (t = !0) : (l = !1)),
          n.subRows && n.subRows.length)
        ) {
          const o = wd(n, I);
          o === "all" ? (t = !0) : (o === "some" && (t = !0), (l = !1));
        }
      }),
      l ? "all" : t ? "some" : !1
    );
  }
  const Nd = /([0-9]+)/gm,
    yv = (g, I, e) =>
      Wb(_e(g.getValue(e)).toLowerCase(), _e(I.getValue(e)).toLowerCase()),
    hv = (g, I, e) => Wb(_e(g.getValue(e)), _e(I.getValue(e))),
    Sv = (g, I, e) =>
      pa(_e(g.getValue(e)).toLowerCase(), _e(I.getValue(e)).toLowerCase()),
    Vv = (g, I, e) => pa(_e(g.getValue(e)), _e(I.getValue(e))),
    Wv = (g, I, e) => {
      const C = g.getValue(e),
        l = I.getValue(e);
      return C > l ? 1 : C < l ? -1 : 0;
    },
    Rv = (g, I, e) => pa(g.getValue(e), I.getValue(e));
  function pa(g, I) {
    return g === I ? 0 : g > I ? 1 : -1;
  }
  function _e(g) {
    return typeof g == "number"
      ? isNaN(g) || g === 1 / 0 || g === -1 / 0
        ? ""
        : String(g)
      : typeof g == "string"
      ? g
      : "";
  }
  function Wb(g, I) {
    const e = g.split(Nd).filter(Boolean),
      C = I.split(Nd).filter(Boolean);
    for (; e.length && C.length; ) {
      const l = e.shift(),
        t = C.shift(),
        n = parseInt(l, 10),
        o = parseInt(t, 10),
        A = [n, o].sort();
      if (isNaN(A[0])) {
        if (l > t) return 1;
        if (t > l) return -1;
        continue;
      }
      if (isNaN(A[1])) return isNaN(n) ? -1 : 1;
      if (n > o) return 1;
      if (o > n) return -1;
    }
    return e.length - C.length;
  }
  const Ml = {
      alphanumeric: yv,
      alphanumericCaseSensitive: hv,
      text: Sv,
      textCaseSensitive: Vv,
      datetime: Wv,
      basic: Rv,
    },
    Xv = {
      getInitialState: (g) => ({ sorting: [], ...g }),
      getDefaultColumnDef: () => ({ sortingFn: "auto", sortUndefined: 1 }),
      getDefaultOptions: (g) => ({
        onSortingChange: mI("sorting", g),
        isMultiSortEvent: (I) => I.shiftKey,
      }),
      createColumn: (g, I) => {
        (g.getAutoSortingFn = () => {
          const e = I.getFilteredRowModel().flatRows.slice(10);
          let C = !1;
          for (const l of e) {
            const t = l == null ? void 0 : l.getValue(g.id);
            if (Object.prototype.toString.call(t) === "[object Date]")
              return Ml.datetime;
            if (typeof t == "string" && ((C = !0), t.split(Nd).length > 1))
              return Ml.alphanumeric;
          }
          return C ? Ml.text : Ml.basic;
        }),
          (g.getAutoSortDir = () => {
            const e = I.getFilteredRowModel().flatRows[0];
            return typeof (e == null ? void 0 : e.getValue(g.id)) == "string"
              ? "asc"
              : "desc";
          }),
          (g.getSortingFn = () => {
            var e, C;
            if (!g) throw new Error();
            return rA(g.columnDef.sortingFn)
              ? g.columnDef.sortingFn
              : g.columnDef.sortingFn === "auto"
              ? g.getAutoSortingFn()
              : (e =
                  (C = I.options.sortingFns) == null
                    ? void 0
                    : C[g.columnDef.sortingFn]) != null
              ? e
              : Ml[g.columnDef.sortingFn];
          }),
          (g.toggleSorting = (e, C) => {
            const l = g.getNextSortingOrder(),
              t = typeof e < "u" && e !== null;
            I.setSorting((n) => {
              const o = n == null ? void 0 : n.find((u) => u.id === g.id),
                A = n == null ? void 0 : n.findIndex((u) => u.id === g.id);
              let c = [],
                d,
                i = t ? e : l === "desc";
              if (
                (n != null && n.length && g.getCanMultiSort() && C
                  ? o
                    ? (d = "toggle")
                    : (d = "add")
                  : n != null && n.length && A !== n.length - 1
                  ? (d = "replace")
                  : o
                  ? (d = "toggle")
                  : (d = "replace"),
                d === "toggle" && (t || l || (d = "remove")),
                d === "add")
              ) {
                var r;
                (c = [...n, { id: g.id, desc: i }]),
                  c.splice(
                    0,
                    c.length -
                      ((r = I.options.maxMultiSortColCount) != null
                        ? r
                        : Number.MAX_SAFE_INTEGER)
                  );
              } else
                d === "toggle"
                  ? (c = n.map((u) => (u.id === g.id ? { ...u, desc: i } : u)))
                  : d === "remove"
                  ? (c = n.filter((u) => u.id !== g.id))
                  : (c = [{ id: g.id, desc: i }]);
              return c;
            });
          }),
          (g.getFirstSortDir = () => {
            var e, C;
            return (
              (e =
                (C = g.columnDef.sortDescFirst) != null
                  ? C
                  : I.options.sortDescFirst) != null
                ? e
                : g.getAutoSortDir() === "desc"
            )
              ? "desc"
              : "asc";
          }),
          (g.getNextSortingOrder = (e) => {
            var C, l;
            const t = g.getFirstSortDir(),
              n = g.getIsSorted();
            return n
              ? n !== t &&
                ((C = I.options.enableSortingRemoval) == null || C) &&
                (!(e && (l = I.options.enableMultiRemove) != null) || l)
                ? !1
                : n === "desc"
                ? "asc"
                : "desc"
              : t;
          }),
          (g.getCanSort = () => {
            var e, C;
            return (
              ((e = g.columnDef.enableSorting) != null ? e : !0) &&
              ((C = I.options.enableSorting) != null ? C : !0) &&
              !!g.accessorFn
            );
          }),
          (g.getCanMultiSort = () => {
            var e, C;
            return (e =
              (C = g.columnDef.enableMultiSort) != null
                ? C
                : I.options.enableMultiSort) != null
              ? e
              : !!g.accessorFn;
          }),
          (g.getIsSorted = () => {
            var e;
            const C =
              (e = I.getState().sorting) == null
                ? void 0
                : e.find((l) => l.id === g.id);
            return C ? (C.desc ? "desc" : "asc") : !1;
          }),
          (g.getSortIndex = () => {
            var e, C;
            return (e =
              (C = I.getState().sorting) == null
                ? void 0
                : C.findIndex((l) => l.id === g.id)) != null
              ? e
              : -1;
          }),
          (g.clearSorting = () => {
            I.setSorting((e) =>
              e != null && e.length ? e.filter((C) => C.id !== g.id) : []
            );
          }),
          (g.getToggleSortingHandler = () => {
            const e = g.getCanSort();
            return (C) => {
              e &&
                (C.persist == null || C.persist(),
                g.toggleSorting == null ||
                  g.toggleSorting(
                    void 0,
                    g.getCanMultiSort()
                      ? I.options.isMultiSortEvent == null
                        ? void 0
                        : I.options.isMultiSortEvent(C)
                      : !1
                  ));
            };
          });
      },
      createTable: (g) => {
        (g.setSorting = (I) =>
          g.options.onSortingChange == null
            ? void 0
            : g.options.onSortingChange(I)),
          (g.resetSorting = (I) => {
            var e, C;
            g.setSorting(
              I
                ? []
                : (e = (C = g.initialState) == null ? void 0 : C.sorting) !=
                  null
                ? e
                : []
            );
          }),
          (g.getPreSortedRowModel = () => g.getGroupedRowModel()),
          (g.getSortedRowModel = () => (
            !g._getSortedRowModel &&
              g.options.getSortedRowModel &&
              (g._getSortedRowModel = g.options.getSortedRowModel(g)),
            g.options.manualSorting || !g._getSortedRowModel
              ? g.getPreSortedRowModel()
              : g._getSortedRowModel()
          ));
      },
    },
    Jv = [_J, uv, iv, av, qJ, $J, mv, Zv, Xv, cv, Gv, bv, Bv, pv, rv];
  function vv(g) {
    var I, e;
    const C = [...Jv, ...((I = g._features) != null ? I : [])];
    let l = { _features: C };
    const t = l._features.reduce(
        (r, u) =>
          Object.assign(
            r,
            u.getDefaultOptions == null ? void 0 : u.getDefaultOptions(l)
          ),
        {}
      ),
      n = (r) =>
        l.options.mergeOptions ? l.options.mergeOptions(t, r) : { ...t, ...r };
    let A = { ...{}, ...((e = g.initialState) != null ? e : {}) };
    l._features.forEach((r) => {
      var u;
      A =
        (u = r.getInitialState == null ? void 0 : r.getInitialState(A)) != null
          ? u
          : A;
    });
    const c = [];
    let d = !1;
    const i = {
      _features: C,
      options: { ...t, ...g },
      initialState: A,
      _queue: (r) => {
        c.push(r),
          d ||
            ((d = !0),
            Promise.resolve()
              .then(() => {
                for (; c.length; ) c.shift()();
                d = !1;
              })
              .catch((u) =>
                setTimeout(() => {
                  throw u;
                })
              ));
      },
      reset: () => {
        l.setState(l.initialState);
      },
      setOptions: (r) => {
        const u = Je(r, l.options);
        l.options = n(u);
      },
      getState: () => l.options.state,
      setState: (r) => {
        l.options.onStateChange == null || l.options.onStateChange(r);
      },
      _getRowId: (r, u, b) => {
        var m;
        return (m =
          l.options.getRowId == null ? void 0 : l.options.getRowId(r, u, b)) !=
          null
          ? m
          : `${b ? [b.id, u].join(".") : u}`;
      },
      getCoreRowModel: () => (
        l._getCoreRowModel ||
          (l._getCoreRowModel = l.options.getCoreRowModel(l)),
        l._getCoreRowModel()
      ),
      getRowModel: () => l.getPaginationRowModel(),
      getRow: (r, u) => {
        let b = (u ? l.getPrePaginationRowModel() : l.getRowModel()).rowsById[
          r
        ];
        if (!b && ((b = l.getCoreRowModel().rowsById[r]), !b))
          throw new Error();
        return b;
      },
      _getDefaultColumnDef: Q(
        () => [l.options.defaultColumn],
        (r) => {
          var u;
          return (
            (r = (u = r) != null ? u : {}),
            {
              header: (b) => {
                const m = b.header.column.columnDef;
                return m.accessorKey
                  ? m.accessorKey
                  : m.accessorFn
                  ? m.id
                  : null;
              },
              cell: (b) => {
                var m, p;
                return (m =
                  (p = b.renderValue()) == null || p.toString == null
                    ? void 0
                    : p.toString()) != null
                  ? m
                  : null;
              },
              ...l._features.reduce(
                (b, m) =>
                  Object.assign(
                    b,
                    m.getDefaultColumnDef == null
                      ? void 0
                      : m.getDefaultColumnDef()
                  ),
                {}
              ),
              ...r,
            }
          );
        },
        L(g, "debugColumns")
      ),
      _getColumnDefs: () => l.options.columns,
      getAllColumns: Q(
        () => [l._getColumnDefs()],
        (r) => {
          const u = function (b, m, p) {
            return (
              p === void 0 && (p = 0),
              b.map((G) => {
                const Z = OJ(l, G, p, m),
                  B = G;
                return (Z.columns = B.columns ? u(B.columns, Z, p + 1) : []), Z;
              })
            );
          };
          return u(r);
        },
        L(g, "debugColumns")
      ),
      getAllFlatColumns: Q(
        () => [l.getAllColumns()],
        (r) => r.flatMap((u) => u.getFlatColumns()),
        L(g, "debugColumns")
      ),
      _getAllFlatColumnsById: Q(
        () => [l.getAllFlatColumns()],
        (r) => r.reduce((u, b) => ((u[b.id] = b), u), {}),
        L(g, "debugColumns")
      ),
      getAllLeafColumns: Q(
        () => [l.getAllColumns(), l._getOrderColumnsFn()],
        (r, u) => {
          let b = r.flatMap((m) => m.getLeafColumns());
          return u(b);
        },
        L(g, "debugColumns")
      ),
      getColumn: (r) => l._getAllFlatColumnsById()[r],
    };
    Object.assign(l, i);
    for (let r = 0; r < l._features.length; r++) {
      const u = l._features[r];
      u == null || u.createTable == null || u.createTable(l);
    }
    return l;
  }
  function kv() {
    return (g) =>
      Q(
        () => [g.options.data],
        (I) => {
          const e = { rows: [], flatRows: [], rowsById: {} },
            C = function (l, t, n) {
              t === void 0 && (t = 0);
              const o = [];
              for (let c = 0; c < l.length; c++) {
                const d = Ga(
                  g,
                  g._getRowId(l[c], c, n),
                  l[c],
                  c,
                  t,
                  void 0,
                  n == null ? void 0 : n.id
                );
                if (
                  (e.flatRows.push(d),
                  (e.rowsById[d.id] = d),
                  o.push(d),
                  g.options.getSubRows)
                ) {
                  var A;
                  (d.originalSubRows = g.options.getSubRows(l[c], c)),
                    (A = d.originalSubRows) != null &&
                      A.length &&
                      (d.subRows = C(d.originalSubRows, t + 1, d));
                }
              }
              return o;
            };
          return (e.rows = C(I)), e;
        },
        L(g.options, "debugTable", "getRowModel", () => g._autoResetPageIndex())
      );
  }
  function fv(g) {
    const I = [],
      e = (C) => {
        var l;
        I.push(C),
          (l = C.subRows) != null &&
            l.length &&
            C.getIsExpanded() &&
            C.subRows.forEach(e);
      };
    return (
      g.rows.forEach(e), { rows: I, flatRows: g.flatRows, rowsById: g.rowsById }
    );
  }
  function Rb(g, I, e) {
    return e.options.filterFromLeafRows ? Yv(g, I, e) : Hv(g, I, e);
  }
  function Yv(g, I, e) {
    var C;
    const l = [],
      t = {},
      n = (C = e.options.maxLeafRowFilterDepth) != null ? C : 100,
      o = function (A, c) {
        c === void 0 && (c = 0);
        const d = [];
        for (let r = 0; r < A.length; r++) {
          var i;
          let u = A[r];
          const b = Ga(
            e,
            u.id,
            u.original,
            u.index,
            u.depth,
            void 0,
            u.parentId
          );
          if (
            ((b.columnFilters = u.columnFilters),
            (i = u.subRows) != null && i.length && c < n)
          ) {
            if (
              ((b.subRows = o(u.subRows, c + 1)),
              (u = b),
              I(u) && !b.subRows.length)
            ) {
              d.push(u), (t[u.id] = u), l.push(u);
              continue;
            }
            if (I(u) || b.subRows.length) {
              d.push(u), (t[u.id] = u), l.push(u);
              continue;
            }
          } else (u = b), I(u) && (d.push(u), (t[u.id] = u), l.push(u));
        }
        return d;
      };
    return { rows: o(g), flatRows: l, rowsById: t };
  }
  function Hv(g, I, e) {
    var C;
    const l = [],
      t = {},
      n = (C = e.options.maxLeafRowFilterDepth) != null ? C : 100,
      o = function (A, c) {
        c === void 0 && (c = 0);
        const d = [];
        for (let r = 0; r < A.length; r++) {
          let u = A[r];
          if (I(u)) {
            var i;
            if ((i = u.subRows) != null && i.length && c < n) {
              const m = Ga(
                e,
                u.id,
                u.original,
                u.index,
                u.depth,
                void 0,
                u.parentId
              );
              (m.subRows = o(u.subRows, c + 1)), (u = m);
            }
            d.push(u), l.push(u), (t[u.id] = u);
          }
        }
        return d;
      };
    return { rows: o(g), flatRows: l, rowsById: t };
  }
  function wv() {
    return (g, I) =>
      Q(
        () => [
          g.getPreFilteredRowModel(),
          g.getState().columnFilters,
          g.getState().globalFilter,
          g.getFilteredRowModel(),
        ],
        (e, C, l) => {
          if (!e.rows.length || (!(C != null && C.length) && !l)) return e;
          const t = [
              ...C.map((o) => o.id).filter((o) => o !== I),
              l ? "__global__" : void 0,
            ].filter(Boolean),
            n = (o) => {
              for (let A = 0; A < t.length; A++)
                if (o.columnFilters[t[A]] === !1) return !1;
              return !0;
            };
          return Rb(e.rows, n, g);
        },
        L(g.options, "debugTable")
      );
  }
  function Nv() {
    return (g, I) =>
      Q(
        () => {
          var e;
          return [
            (e = g.getColumn(I)) == null ? void 0 : e.getFacetedRowModel(),
          ];
        },
        (e) => {
          if (!e) return new Map();
          let C = new Map();
          for (let t = 0; t < e.flatRows.length; t++) {
            const n = e.flatRows[t].getUniqueValues(I);
            for (let o = 0; o < n.length; o++) {
              const A = n[o];
              if (C.has(A)) {
                var l;
                C.set(A, ((l = C.get(A)) != null ? l : 0) + 1);
              } else C.set(A, 1);
            }
          }
          return C;
        },
        L(g.options, "debugTable")
      );
  }
  function Kv() {
    return (g) =>
      Q(
        () => [
          g.getPreFilteredRowModel(),
          g.getState().columnFilters,
          g.getState().globalFilter,
        ],
        (I, e, C) => {
          if (!I.rows.length || (!(e != null && e.length) && !C)) {
            for (let r = 0; r < I.flatRows.length; r++)
              (I.flatRows[r].columnFilters = {}),
                (I.flatRows[r].columnFiltersMeta = {});
            return I;
          }
          const l = [],
            t = [];
          (e ?? []).forEach((r) => {
            var u;
            const b = g.getColumn(r.id);
            if (!b) return;
            const m = b.getFilterFn();
            m &&
              l.push({
                id: r.id,
                filterFn: m,
                resolvedValue:
                  (u =
                    m.resolveFilterValue == null
                      ? void 0
                      : m.resolveFilterValue(r.value)) != null
                    ? u
                    : r.value,
              });
          });
          const n = (e ?? []).map((r) => r.id),
            o = g.getGlobalFilterFn(),
            A = g.getAllLeafColumns().filter((r) => r.getCanGlobalFilter());
          C &&
            o &&
            A.length &&
            (n.push("__global__"),
            A.forEach((r) => {
              var u;
              t.push({
                id: r.id,
                filterFn: o,
                resolvedValue:
                  (u =
                    o.resolveFilterValue == null
                      ? void 0
                      : o.resolveFilterValue(C)) != null
                    ? u
                    : C,
              });
            }));
          let c, d;
          for (let r = 0; r < I.flatRows.length; r++) {
            const u = I.flatRows[r];
            if (((u.columnFilters = {}), l.length))
              for (let b = 0; b < l.length; b++) {
                c = l[b];
                const m = c.id;
                u.columnFilters[m] = c.filterFn(u, m, c.resolvedValue, (p) => {
                  u.columnFiltersMeta[m] = p;
                });
              }
            if (t.length) {
              for (let b = 0; b < t.length; b++) {
                d = t[b];
                const m = d.id;
                if (
                  d.filterFn(u, m, d.resolvedValue, (p) => {
                    u.columnFiltersMeta[m] = p;
                  })
                ) {
                  u.columnFilters.__global__ = !0;
                  break;
                }
              }
              u.columnFilters.__global__ !== !0 &&
                (u.columnFilters.__global__ = !1);
            }
          }
          const i = (r) => {
            for (let u = 0; u < n.length; u++)
              if (r.columnFilters[n[u]] === !1) return !1;
            return !0;
          };
          return Rb(I.rows, i, g);
        },
        L(g.options, "debugTable", "getFilteredRowModel", () =>
          g._autoResetPageIndex()
        )
      );
  }
  function Fv(g) {
    return (I) =>
      Q(
        () => [
          I.getState().pagination,
          I.getPrePaginationRowModel(),
          I.options.paginateExpandedRows ? void 0 : I.getState().expanded,
        ],
        (e, C) => {
          if (!C.rows.length) return C;
          const { pageSize: l, pageIndex: t } = e;
          let { rows: n, flatRows: o, rowsById: A } = C;
          const c = l * t,
            d = c + l;
          n = n.slice(c, d);
          let i;
          I.options.paginateExpandedRows
            ? (i = { rows: n, flatRows: o, rowsById: A })
            : (i = fv({ rows: n, flatRows: o, rowsById: A })),
            (i.flatRows = []);
          const r = (u) => {
            i.flatRows.push(u), u.subRows.length && u.subRows.forEach(r);
          };
          return i.rows.forEach(r), i;
        },
        L(I.options, "debugTable")
      );
  }
  function xv() {
    return (g) =>
      Q(
        () => [g.getState().sorting, g.getPreSortedRowModel()],
        (I, e) => {
          if (!e.rows.length || !(I != null && I.length)) return e;
          const C = g.getState().sorting,
            l = [],
            t = C.filter((A) => {
              var c;
              return (c = g.getColumn(A.id)) == null ? void 0 : c.getCanSort();
            }),
            n = {};
          t.forEach((A) => {
            const c = g.getColumn(A.id);
            c &&
              (n[A.id] = {
                sortUndefined: c.columnDef.sortUndefined,
                invertSorting: c.columnDef.invertSorting,
                sortingFn: c.getSortingFn(),
              });
          });
          const o = (A) => {
            const c = A.map((d) => ({ ...d }));
            return (
              c.sort((d, i) => {
                for (let u = 0; u < t.length; u += 1) {
                  var r;
                  const b = t[u],
                    m = n[b.id],
                    p = m.sortUndefined,
                    G = (r = b == null ? void 0 : b.desc) != null ? r : !1;
                  let Z = 0;
                  if (p) {
                    const B = d.getValue(b.id),
                      y = i.getValue(b.id),
                      h = B === void 0,
                      W = y === void 0;
                    if (h || W) {
                      if (p === "first") return h ? -1 : 1;
                      if (p === "last") return h ? 1 : -1;
                      Z = h && W ? 0 : h ? p : -p;
                    }
                  }
                  if ((Z === 0 && (Z = m.sortingFn(d, i, b.id)), Z !== 0))
                    return G && (Z *= -1), m.invertSorting && (Z *= -1), Z;
                }
                return d.index - i.index;
              }),
              c.forEach((d) => {
                var i;
                l.push(d),
                  (i = d.subRows) != null &&
                    i.length &&
                    (d.subRows = o(d.subRows));
              }),
              c
            );
          };
          return { rows: o(e.rows), flatRows: l, rowsById: e.rowsById };
        },
        L(g.options, "debugTable", "getSortedRowModel", () =>
          g._autoResetPageIndex()
        )
      );
  }
  /**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */ function hs(g, I) {
    return g ? (Mv(g) ? a.createElement(g, I) : g) : null;
  }
  function Mv(g) {
    return zv(g) || typeof g == "function" || Ev(g);
  }
  function zv(g) {
    return (
      typeof g == "function" &&
      (() => {
        const I = Object.getPrototypeOf(g);
        return I.prototype && I.prototype.isReactComponent;
      })()
    );
  }
  function Ev(g) {
    return (
      typeof g == "object" &&
      typeof g.$$typeof == "symbol" &&
      ["react.memo", "react.forward_ref"].includes(g.$$typeof.description)
    );
  }
  function Uv(g) {
    const I = {
        state: {},
        onStateChange: () => {},
        renderFallbackValue: null,
        ...g,
      },
      [e] = a.useState(() => ({ current: vv(I) })),
      [C, l] = a.useState(() => e.current.initialState);
    return (
      e.current.setOptions((t) => ({
        ...t,
        ...g,
        state: { ...C, ...g.state },
        onStateChange: (n) => {
          l(n), g.onStateChange == null || g.onStateChange(n);
        },
      })),
      e.current
    );
  }
  const Xb = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("div", {
      className: "relative w-full overflow-auto",
      children: s.jsx("table", {
        ref: e,
        className: O("w-full caption-bottom text-sm", g),
        ...I,
      }),
    })
  );
  Xb.displayName = "Table";
  const Jb = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("thead", { ref: e, className: O("[&_tr]:border-b", g), ...I })
  );
  Jb.displayName = "TableHeader";
  const vb = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("tbody", {
      ref: e,
      className: O("[&_tr:last-child]:border-0", g),
      ...I,
    })
  );
  vb.displayName = "TableBody";
  const Qv = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("tfoot", {
      ref: e,
      className: O(
        "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
        g
      ),
      ...I,
    })
  );
  Qv.displayName = "TableFooter";
  const Pn = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("tr", {
      ref: e,
      className: O(
        "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
        g
      ),
      ...I,
    })
  );
  Pn.displayName = "TableRow";
  const kb = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("th", {
      ref: e,
      className: O(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        g
      ),
      ...I,
    })
  );
  kb.displayName = "TableHead";
  const Kd = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("td", {
      ref: e,
      className: O("p-4 align-middle [&:has([role=checkbox])]:pr-0", g),
      ...I,
    })
  );
  Kd.displayName = "TableCell";
  const Lv = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("caption", {
      ref: e,
      className: O("mt-4 text-sm text-muted-foreground", g),
      ...I,
    })
  );
  Lv.displayName = "TableCaption";
  function Ss(g, [I, e]) {
    return Math.min(e, Math.max(I, g));
  }
  var Dv = "VisuallyHidden",
    fb = a.forwardRef((g, I) =>
      s.jsx(tg.span, {
        ...g,
        ref: I,
        style: {
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...g.style,
        },
      })
    );
  fb.displayName = Dv;
  var Tv = [" ", "Enter", "ArrowUp", "ArrowDown"],
    jv = [" ", "Enter"],
    Cn = "Select",
    [sA, uA, Pv] = Qi(Cn),
    [Wl, wk] = Ot(Cn, [Pv, oA]),
    mA = oA(),
    [Ov, eC] = Wl(Cn),
    [_v, qv] = Wl(Cn),
    Yb = (g) => {
      const {
          __scopeSelect: I,
          children: e,
          open: C,
          defaultOpen: l,
          onOpenChange: t,
          value: n,
          defaultValue: o,
          onValueChange: A,
          dir: c,
          name: d,
          autoComplete: i,
          disabled: r,
          required: u,
          form: b,
        } = g,
        m = mA(I),
        [p, G] = a.useState(null),
        [Z, B] = a.useState(null),
        [y, h] = a.useState(!1),
        W = Li(c),
        [S = !1, V] = rl({ prop: C, defaultProp: l, onChange: t }),
        [f, k] = rl({ prop: n, defaultProp: o, onChange: A }),
        F = a.useRef(null),
        K = p ? b || !!p.closest("form") : !0,
        [P, T] = a.useState(new Set()),
        ng = Array.from(P)
          .map((z) => z.props.value)
          .join(";");
      return s.jsx(ea, {
        ...m,
        children: s.jsxs(Ov, {
          required: u,
          scope: I,
          trigger: p,
          onTriggerChange: G,
          valueNode: Z,
          onValueNodeChange: B,
          valueNodeHasChildren: y,
          onValueNodeHasChildrenChange: h,
          contentId: Ee(),
          value: f,
          onValueChange: k,
          open: S,
          onOpenChange: V,
          dir: W,
          triggerPointerDownPosRef: F,
          disabled: r,
          children: [
            s.jsx(sA.Provider, {
              scope: I,
              children: s.jsx(_v, {
                scope: g.__scopeSelect,
                onNativeOptionAdd: a.useCallback((z) => {
                  T((gg) => new Set(gg).add(z));
                }, []),
                onNativeOptionRemove: a.useCallback((z) => {
                  T((gg) => {
                    const R = new Set(gg);
                    return R.delete(z), R;
                  });
                }, []),
                children: e,
              }),
            }),
            K
              ? s.jsxs(
                  l0,
                  {
                    "aria-hidden": !0,
                    required: u,
                    tabIndex: -1,
                    name: d,
                    autoComplete: i,
                    value: f,
                    onChange: (z) => k(z.target.value),
                    disabled: r,
                    form: b,
                    children: [
                      f === void 0 ? s.jsx("option", { value: "" }) : null,
                      Array.from(P),
                    ],
                  },
                  ng
                )
              : null,
          ],
        }),
      });
    };
  Yb.displayName = Cn;
  var Hb = "SelectTrigger",
    wb = a.forwardRef((g, I) => {
      const { __scopeSelect: e, disabled: C = !1, ...l } = g,
        t = mA(e),
        n = eC(Hb, e),
        o = n.disabled || C,
        A = Gg(I, n.onTriggerChange),
        c = uA(e),
        d = a.useRef("touch"),
        [i, r, u] = t0((m) => {
          const p = c().filter((B) => !B.disabled),
            G = p.find((B) => B.value === n.value),
            Z = n0(p, m, G);
          Z !== void 0 && n.onValueChange(Z.value);
        }),
        b = (m) => {
          o || (n.onOpenChange(!0), u()),
            m &&
              (n.triggerPointerDownPosRef.current = {
                x: Math.round(m.pageX),
                y: Math.round(m.pageY),
              });
        };
      return s.jsx(QZ, {
        asChild: !0,
        ...t,
        children: s.jsx(tg.button, {
          type: "button",
          role: "combobox",
          "aria-controls": n.contentId,
          "aria-expanded": n.open,
          "aria-required": n.required,
          "aria-autocomplete": "none",
          dir: n.dir,
          "data-state": n.open ? "open" : "closed",
          disabled: o,
          "data-disabled": o ? "" : void 0,
          "data-placeholder": C0(n.value) ? "" : void 0,
          ...l,
          ref: A,
          onClick: E(l.onClick, (m) => {
            m.currentTarget.focus(), d.current !== "mouse" && b(m);
          }),
          onPointerDown: E(l.onPointerDown, (m) => {
            d.current = m.pointerType;
            const p = m.target;
            p.hasPointerCapture(m.pointerId) &&
              p.releasePointerCapture(m.pointerId),
              m.button === 0 &&
                m.ctrlKey === !1 &&
                m.pointerType === "mouse" &&
                (b(m), m.preventDefault());
          }),
          onKeyDown: E(l.onKeyDown, (m) => {
            const p = i.current !== "";
            !(m.ctrlKey || m.altKey || m.metaKey) &&
              m.key.length === 1 &&
              r(m.key),
              !(p && m.key === " ") &&
                Tv.includes(m.key) &&
                (b(), m.preventDefault());
          }),
        }),
      });
    });
  wb.displayName = Hb;
  var Nb = "SelectValue",
    Kb = a.forwardRef((g, I) => {
      const {
          __scopeSelect: e,
          className: C,
          style: l,
          children: t,
          placeholder: n = "",
          ...o
        } = g,
        A = eC(Nb, e),
        { onValueNodeHasChildrenChange: c } = A,
        d = t !== void 0,
        i = Gg(I, A.onValueNodeChange);
      return (
        xg(() => {
          c(d);
        }, [c, d]),
        s.jsx(tg.span, {
          ...o,
          ref: i,
          style: { pointerEvents: "none" },
          children: C0(A.value) ? s.jsx(s.Fragment, { children: n }) : t,
        })
      );
    });
  Kb.displayName = Nb;
  var $v = "SelectIcon",
    Fb = a.forwardRef((g, I) => {
      const { __scopeSelect: e, children: C, ...l } = g;
      return s.jsx(tg.span, {
        "aria-hidden": !0,
        ...l,
        ref: I,
        children: C || "",
      });
    });
  Fb.displayName = $v;
  var g2 = "SelectPortal",
    xb = (g) => s.jsx(Ca, { asChild: !0, ...g });
  xb.displayName = g2;
  var yC = "SelectContent",
    Mb = a.forwardRef((g, I) => {
      const e = eC(yC, g.__scopeSelect),
        [C, l] = a.useState();
      if (
        (xg(() => {
          l(new DocumentFragment());
        }, []),
        !e.open)
      ) {
        const t = C;
        return t
          ? jt.createPortal(
              s.jsx(zb, {
                scope: g.__scopeSelect,
                children: s.jsx(sA.Slot, {
                  scope: g.__scopeSelect,
                  children: s.jsx("div", { children: g.children }),
                }),
              }),
              t
            )
          : null;
      }
      return s.jsx(Eb, { ...g, ref: I });
    });
  Mb.displayName = yC;
  var JI = 10,
    [zb, CC] = Wl(yC),
    I2 = "SelectContentImpl",
    Eb = a.forwardRef((g, I) => {
      const {
          __scopeSelect: e,
          position: C = "item-aligned",
          onCloseAutoFocus: l,
          onEscapeKeyDown: t,
          onPointerDownOutside: n,
          side: o,
          sideOffset: A,
          align: c,
          alignOffset: d,
          arrowPadding: i,
          collisionBoundary: r,
          collisionPadding: u,
          sticky: b,
          hideWhenDetached: m,
          avoidCollisions: p,
          ...G
        } = g,
        Z = eC(yC, e),
        [B, y] = a.useState(null),
        [h, W] = a.useState(null),
        S = Gg(I, (M) => y(M)),
        [V, f] = a.useState(null),
        [k, F] = a.useState(null),
        K = uA(e),
        [P, T] = a.useState(!1),
        ng = a.useRef(!1);
      a.useEffect(() => {
        if (B) return gG(B);
      }, [B]),
        SZ();
      const z = a.useCallback(
          (M) => {
            const [cg, ...rg] = K().map((ig) => ig.ref.current),
              [og] = rg.slice(-1),
              dg = document.activeElement;
            for (const ig of M)
              if (
                ig === dg ||
                (ig == null || ig.scrollIntoView({ block: "nearest" }),
                ig === cg && h && (h.scrollTop = 0),
                ig === og && h && (h.scrollTop = h.scrollHeight),
                ig == null || ig.focus(),
                document.activeElement !== dg)
              )
                return;
          },
          [K, h]
        ),
        gg = a.useCallback(() => z([V, B]), [z, V, B]);
      a.useEffect(() => {
        P && gg();
      }, [P, gg]);
      const { onOpenChange: R, triggerPointerDownPosRef: X } = Z;
      a.useEffect(() => {
        if (B) {
          let M = { x: 0, y: 0 };
          const cg = (og) => {
              var dg, ig;
              M = {
                x: Math.abs(
                  Math.round(og.pageX) -
                    (((dg = X.current) == null ? void 0 : dg.x) ?? 0)
                ),
                y: Math.abs(
                  Math.round(og.pageY) -
                    (((ig = X.current) == null ? void 0 : ig.y) ?? 0)
                ),
              };
            },
            rg = (og) => {
              M.x <= 10 && M.y <= 10
                ? og.preventDefault()
                : B.contains(og.target) || R(!1),
                document.removeEventListener("pointermove", cg),
                (X.current = null);
            };
          return (
            X.current !== null &&
              (document.addEventListener("pointermove", cg),
              document.addEventListener("pointerup", rg, {
                capture: !0,
                once: !0,
              })),
            () => {
              document.removeEventListener("pointermove", cg),
                document.removeEventListener("pointerup", rg, { capture: !0 });
            }
          );
        }
      }, [B, R, X]),
        a.useEffect(() => {
          const M = () => R(!1);
          return (
            window.addEventListener("blur", M),
            window.addEventListener("resize", M),
            () => {
              window.removeEventListener("blur", M),
                window.removeEventListener("resize", M);
            }
          );
        }, [R]);
      const [H, U] = t0((M) => {
          const cg = K().filter((dg) => !dg.disabled),
            rg = cg.find((dg) => dg.ref.current === document.activeElement),
            og = n0(cg, M, rg);
          og && setTimeout(() => og.ref.current.focus());
        }),
        Cg = a.useCallback(
          (M, cg, rg) => {
            const og = !ng.current && !rg;
            ((Z.value !== void 0 && Z.value === cg) || og) &&
              (f(M), og && (ng.current = !0));
          },
          [Z.value]
        ),
        $g = a.useCallback(() => (B == null ? void 0 : B.focus()), [B]),
        Rg = a.useCallback(
          (M, cg, rg) => {
            const og = !ng.current && !rg;
            ((Z.value !== void 0 && Z.value === cg) || og) && F(M);
          },
          [Z.value]
        ),
        nI = C === "popper" ? Fd : Ub,
        Vg =
          nI === Fd
            ? {
                side: o,
                sideOffset: A,
                align: c,
                alignOffset: d,
                arrowPadding: i,
                collisionBoundary: r,
                collisionPadding: u,
                sticky: b,
                hideWhenDetached: m,
                avoidCollisions: p,
              }
            : {};
      return s.jsx(zb, {
        scope: e,
        content: B,
        viewport: h,
        onViewportChange: W,
        itemRefCallback: Cg,
        selectedItem: V,
        onItemLeave: $g,
        itemTextRefCallback: Rg,
        focusSelectedItem: gg,
        selectedItemText: k,
        position: C,
        isPositioned: P,
        searchRef: H,
        children: s.jsx(la, {
          as: ZC,
          allowPinchZoom: !0,
          children: s.jsx(Ti, {
            asChild: !0,
            trapped: Z.open,
            onMountAutoFocus: (M) => {
              M.preventDefault();
            },
            onUnmountAutoFocus: E(l, (M) => {
              var cg;
              (cg = Z.trigger) == null || cg.focus({ preventScroll: !0 }),
                M.preventDefault();
            }),
            children: s.jsx(Di, {
              asChild: !0,
              disableOutsidePointerEvents: !0,
              onEscapeKeyDown: t,
              onPointerDownOutside: n,
              onFocusOutside: (M) => M.preventDefault(),
              onDismiss: () => Z.onOpenChange(!1),
              children: s.jsx(nI, {
                role: "listbox",
                id: Z.contentId,
                "data-state": Z.open ? "open" : "closed",
                dir: Z.dir,
                onContextMenu: (M) => M.preventDefault(),
                ...G,
                ...Vg,
                onPlaced: () => T(!0),
                ref: S,
                style: {
                  display: "flex",
                  flexDirection: "column",
                  outline: "none",
                  ...G.style,
                },
                onKeyDown: E(G.onKeyDown, (M) => {
                  const cg = M.ctrlKey || M.altKey || M.metaKey;
                  if (
                    (M.key === "Tab" && M.preventDefault(),
                    !cg && M.key.length === 1 && U(M.key),
                    ["ArrowUp", "ArrowDown", "Home", "End"].includes(M.key))
                  ) {
                    let og = K()
                      .filter((dg) => !dg.disabled)
                      .map((dg) => dg.ref.current);
                    if (
                      (["ArrowUp", "End"].includes(M.key) &&
                        (og = og.slice().reverse()),
                      ["ArrowUp", "ArrowDown"].includes(M.key))
                    ) {
                      const dg = M.target,
                        ig = og.indexOf(dg);
                      og = og.slice(ig + 1);
                    }
                    setTimeout(() => z(og)), M.preventDefault();
                  }
                }),
              }),
            }),
          }),
        }),
      });
    });
  Eb.displayName = I2;
  var e2 = "SelectItemAlignedPosition",
    Ub = a.forwardRef((g, I) => {
      const { __scopeSelect: e, onPlaced: C, ...l } = g,
        t = eC(yC, e),
        n = CC(yC, e),
        [o, A] = a.useState(null),
        [c, d] = a.useState(null),
        i = Gg(I, (S) => d(S)),
        r = uA(e),
        u = a.useRef(!1),
        b = a.useRef(!0),
        {
          viewport: m,
          selectedItem: p,
          selectedItemText: G,
          focusSelectedItem: Z,
        } = n,
        B = a.useCallback(() => {
          if (t.trigger && t.valueNode && o && c && m && p && G) {
            const S = t.trigger.getBoundingClientRect(),
              V = c.getBoundingClientRect(),
              f = t.valueNode.getBoundingClientRect(),
              k = G.getBoundingClientRect();
            if (t.dir !== "rtl") {
              const dg = k.left - V.left,
                ig = f.left - dg,
                oI = S.left - ig,
                EI = S.width + oI,
                Rl = Math.max(EI, V.width),
                Xl = window.innerWidth - JI,
                Jl = Ss(ig, [JI, Math.max(JI, Xl - Rl)]);
              (o.style.minWidth = EI + "px"), (o.style.left = Jl + "px");
            } else {
              const dg = V.right - k.right,
                ig = window.innerWidth - f.right - dg,
                oI = window.innerWidth - S.right - ig,
                EI = S.width + oI,
                Rl = Math.max(EI, V.width),
                Xl = window.innerWidth - JI,
                Jl = Ss(ig, [JI, Math.max(JI, Xl - Rl)]);
              (o.style.minWidth = EI + "px"), (o.style.right = Jl + "px");
            }
            const F = r(),
              K = window.innerHeight - JI * 2,
              P = m.scrollHeight,
              T = window.getComputedStyle(c),
              ng = parseInt(T.borderTopWidth, 10),
              z = parseInt(T.paddingTop, 10),
              gg = parseInt(T.borderBottomWidth, 10),
              R = parseInt(T.paddingBottom, 10),
              X = ng + z + P + R + gg,
              H = Math.min(p.offsetHeight * 5, X),
              U = window.getComputedStyle(m),
              Cg = parseInt(U.paddingTop, 10),
              $g = parseInt(U.paddingBottom, 10),
              Rg = S.top + S.height / 2 - JI,
              nI = K - Rg,
              Vg = p.offsetHeight / 2,
              M = p.offsetTop + Vg,
              cg = ng + z + M,
              rg = X - cg;
            if (cg <= Rg) {
              const dg = F.length > 0 && p === F[F.length - 1].ref.current;
              o.style.bottom = "0px";
              const ig = c.clientHeight - m.offsetTop - m.offsetHeight,
                oI = Math.max(nI, Vg + (dg ? $g : 0) + ig + gg),
                EI = cg + oI;
              o.style.height = EI + "px";
            } else {
              const dg = F.length > 0 && p === F[0].ref.current;
              o.style.top = "0px";
              const oI =
                Math.max(Rg, ng + m.offsetTop + (dg ? Cg : 0) + Vg) + rg;
              (o.style.height = oI + "px"),
                (m.scrollTop = cg - Rg + m.offsetTop);
            }
            (o.style.margin = `${JI}px 0`),
              (o.style.minHeight = H + "px"),
              (o.style.maxHeight = K + "px"),
              C == null || C(),
              requestAnimationFrame(() => (u.current = !0));
          }
        }, [r, t.trigger, t.valueNode, o, c, m, p, G, t.dir, C]);
      xg(() => B(), [B]);
      const [y, h] = a.useState();
      xg(() => {
        c && h(window.getComputedStyle(c).zIndex);
      }, [c]);
      const W = a.useCallback(
        (S) => {
          S && b.current === !0 && (B(), Z == null || Z(), (b.current = !1));
        },
        [B, Z]
      );
      return s.jsx(l2, {
        scope: e,
        contentWrapper: o,
        shouldExpandOnScrollRef: u,
        onScrollButtonChange: W,
        children: s.jsx("div", {
          ref: A,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: y,
          },
          children: s.jsx(tg.div, {
            ...l,
            ref: i,
            style: { boxSizing: "border-box", maxHeight: "100%", ...l.style },
          }),
        }),
      });
    });
  Ub.displayName = e2;
  var C2 = "SelectPopperPosition",
    Fd = a.forwardRef((g, I) => {
      const {
          __scopeSelect: e,
          align: C = "start",
          collisionPadding: l = JI,
          ...t
        } = g,
        n = mA(e);
      return s.jsx(LZ, {
        ...n,
        ...t,
        ref: I,
        align: C,
        collisionPadding: l,
        style: {
          boxSizing: "border-box",
          ...t.style,
          "--radix-select-content-transform-origin":
            "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width":
            "var(--radix-popper-available-width)",
          "--radix-select-content-available-height":
            "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
        },
      });
    });
  Fd.displayName = C2;
  var [l2, ya] = Wl(yC, {}),
    xd = "SelectViewport",
    Qb = a.forwardRef((g, I) => {
      const { __scopeSelect: e, nonce: C, ...l } = g,
        t = CC(xd, e),
        n = ya(xd, e),
        o = Gg(I, t.onViewportChange),
        A = a.useRef(0);
      return s.jsxs(s.Fragment, {
        children: [
          s.jsx("style", {
            dangerouslySetInnerHTML: {
              __html:
                "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
            },
            nonce: C,
          }),
          s.jsx(sA.Slot, {
            scope: e,
            children: s.jsx(tg.div, {
              "data-radix-select-viewport": "",
              role: "presentation",
              ...l,
              ref: o,
              style: {
                position: "relative",
                flex: 1,
                overflow: "hidden auto",
                ...l.style,
              },
              onScroll: E(l.onScroll, (c) => {
                const d = c.currentTarget,
                  { contentWrapper: i, shouldExpandOnScrollRef: r } = n;
                if (r != null && r.current && i) {
                  const u = Math.abs(A.current - d.scrollTop);
                  if (u > 0) {
                    const b = window.innerHeight - JI * 2,
                      m = parseFloat(i.style.minHeight),
                      p = parseFloat(i.style.height),
                      G = Math.max(m, p);
                    if (G < b) {
                      const Z = G + u,
                        B = Math.min(b, Z),
                        y = Z - B;
                      (i.style.height = B + "px"),
                        i.style.bottom === "0px" &&
                          ((d.scrollTop = y > 0 ? y : 0),
                          (i.style.justifyContent = "flex-end"));
                    }
                  }
                }
                A.current = d.scrollTop;
              }),
            }),
          }),
        ],
      });
    });
  Qb.displayName = xd;
  var Lb = "SelectGroup",
    [t2, n2] = Wl(Lb),
    o2 = a.forwardRef((g, I) => {
      const { __scopeSelect: e, ...C } = g,
        l = Ee();
      return s.jsx(t2, {
        scope: e,
        id: l,
        children: s.jsx(tg.div, {
          role: "group",
          "aria-labelledby": l,
          ...C,
          ref: I,
        }),
      });
    });
  o2.displayName = Lb;
  var Db = "SelectLabel",
    Tb = a.forwardRef((g, I) => {
      const { __scopeSelect: e, ...C } = g,
        l = n2(Db, e);
      return s.jsx(tg.div, { id: l.id, ...C, ref: I });
    });
  Tb.displayName = Db;
  var Ko = "SelectItem",
    [A2, jb] = Wl(Ko),
    Pb = a.forwardRef((g, I) => {
      const {
          __scopeSelect: e,
          value: C,
          disabled: l = !1,
          textValue: t,
          ...n
        } = g,
        o = eC(Ko, e),
        A = CC(Ko, e),
        c = o.value === C,
        [d, i] = a.useState(t ?? ""),
        [r, u] = a.useState(!1),
        b = Gg(I, (Z) => {
          var B;
          return (B = A.itemRefCallback) == null ? void 0 : B.call(A, Z, C, l);
        }),
        m = Ee(),
        p = a.useRef("touch"),
        G = () => {
          l || (o.onValueChange(C), o.onOpenChange(!1));
        };
      if (C === "")
        throw new Error(
          "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
        );
      return s.jsx(A2, {
        scope: e,
        value: C,
        disabled: l,
        textId: m,
        isSelected: c,
        onItemTextChange: a.useCallback((Z) => {
          i((B) => B || ((Z == null ? void 0 : Z.textContent) ?? "").trim());
        }, []),
        children: s.jsx(sA.ItemSlot, {
          scope: e,
          value: C,
          disabled: l,
          textValue: d,
          children: s.jsx(tg.div, {
            role: "option",
            "aria-labelledby": m,
            "data-highlighted": r ? "" : void 0,
            "aria-selected": c && r,
            "data-state": c ? "checked" : "unchecked",
            "aria-disabled": l || void 0,
            "data-disabled": l ? "" : void 0,
            tabIndex: l ? void 0 : -1,
            ...n,
            ref: b,
            onFocus: E(n.onFocus, () => u(!0)),
            onBlur: E(n.onBlur, () => u(!1)),
            onClick: E(n.onClick, () => {
              p.current !== "mouse" && G();
            }),
            onPointerUp: E(n.onPointerUp, () => {
              p.current === "mouse" && G();
            }),
            onPointerDown: E(n.onPointerDown, (Z) => {
              p.current = Z.pointerType;
            }),
            onPointerMove: E(n.onPointerMove, (Z) => {
              var B;
              (p.current = Z.pointerType),
                l
                  ? (B = A.onItemLeave) == null || B.call(A)
                  : p.current === "mouse" &&
                    Z.currentTarget.focus({ preventScroll: !0 });
            }),
            onPointerLeave: E(n.onPointerLeave, (Z) => {
              var B;
              Z.currentTarget === document.activeElement &&
                ((B = A.onItemLeave) == null || B.call(A));
            }),
            onKeyDown: E(n.onKeyDown, (Z) => {
              var y;
              (((y = A.searchRef) == null ? void 0 : y.current) !== "" &&
                Z.key === " ") ||
                (jv.includes(Z.key) && G(),
                Z.key === " " && Z.preventDefault());
            }),
          }),
        }),
      });
    });
  Pb.displayName = Ko;
  var jl = "SelectItemText",
    Ob = a.forwardRef((g, I) => {
      const { __scopeSelect: e, className: C, style: l, ...t } = g,
        n = eC(jl, e),
        o = CC(jl, e),
        A = jb(jl, e),
        c = qv(jl, e),
        [d, i] = a.useState(null),
        r = Gg(
          I,
          (G) => i(G),
          A.onItemTextChange,
          (G) => {
            var Z;
            return (Z = o.itemTextRefCallback) == null
              ? void 0
              : Z.call(o, G, A.value, A.disabled);
          }
        ),
        u = d == null ? void 0 : d.textContent,
        b = a.useMemo(
          () =>
            s.jsx(
              "option",
              { value: A.value, disabled: A.disabled, children: u },
              A.value
            ),
          [A.disabled, A.value, u]
        ),
        { onNativeOptionAdd: m, onNativeOptionRemove: p } = c;
      return (
        xg(() => (m(b), () => p(b)), [m, p, b]),
        s.jsxs(s.Fragment, {
          children: [
            s.jsx(tg.span, { id: A.textId, ...t, ref: r }),
            A.isSelected && n.valueNode && !n.valueNodeHasChildren
              ? jt.createPortal(t.children, n.valueNode)
              : null,
          ],
        })
      );
    });
  Ob.displayName = jl;
  var _b = "SelectItemIndicator",
    qb = a.forwardRef((g, I) => {
      const { __scopeSelect: e, ...C } = g;
      return jb(_b, e).isSelected
        ? s.jsx(tg.span, { "aria-hidden": !0, ...C, ref: I })
        : null;
    });
  qb.displayName = _b;
  var Md = "SelectScrollUpButton",
    $b = a.forwardRef((g, I) => {
      const e = CC(Md, g.__scopeSelect),
        C = ya(Md, g.__scopeSelect),
        [l, t] = a.useState(!1),
        n = Gg(I, C.onScrollButtonChange);
      return (
        xg(() => {
          if (e.viewport && e.isPositioned) {
            let o = function () {
              const c = A.scrollTop > 0;
              t(c);
            };
            const A = e.viewport;
            return (
              o(),
              A.addEventListener("scroll", o),
              () => A.removeEventListener("scroll", o)
            );
          }
        }, [e.viewport, e.isPositioned]),
        l
          ? s.jsx(I0, {
              ...g,
              ref: n,
              onAutoScroll: () => {
                const { viewport: o, selectedItem: A } = e;
                o && A && (o.scrollTop = o.scrollTop - A.offsetHeight);
              },
            })
          : null
      );
    });
  $b.displayName = Md;
  var zd = "SelectScrollDownButton",
    g0 = a.forwardRef((g, I) => {
      const e = CC(zd, g.__scopeSelect),
        C = ya(zd, g.__scopeSelect),
        [l, t] = a.useState(!1),
        n = Gg(I, C.onScrollButtonChange);
      return (
        xg(() => {
          if (e.viewport && e.isPositioned) {
            let o = function () {
              const c = A.scrollHeight - A.clientHeight,
                d = Math.ceil(A.scrollTop) < c;
              t(d);
            };
            const A = e.viewport;
            return (
              o(),
              A.addEventListener("scroll", o),
              () => A.removeEventListener("scroll", o)
            );
          }
        }, [e.viewport, e.isPositioned]),
        l
          ? s.jsx(I0, {
              ...g,
              ref: n,
              onAutoScroll: () => {
                const { viewport: o, selectedItem: A } = e;
                o && A && (o.scrollTop = o.scrollTop + A.offsetHeight);
              },
            })
          : null
      );
    });
  g0.displayName = zd;
  var I0 = a.forwardRef((g, I) => {
      const { __scopeSelect: e, onAutoScroll: C, ...l } = g,
        t = CC("SelectScrollButton", e),
        n = a.useRef(null),
        o = uA(e),
        A = a.useCallback(() => {
          n.current !== null &&
            (window.clearInterval(n.current), (n.current = null));
        }, []);
      return (
        a.useEffect(() => () => A(), [A]),
        xg(() => {
          var d;
          const c = o().find((i) => i.ref.current === document.activeElement);
          (d = c == null ? void 0 : c.ref.current) == null ||
            d.scrollIntoView({ block: "nearest" });
        }, [o]),
        s.jsx(tg.div, {
          "aria-hidden": !0,
          ...l,
          ref: I,
          style: { flexShrink: 0, ...l.style },
          onPointerDown: E(l.onPointerDown, () => {
            n.current === null && (n.current = window.setInterval(C, 50));
          }),
          onPointerMove: E(l.onPointerMove, () => {
            var c;
            (c = t.onItemLeave) == null || c.call(t),
              n.current === null && (n.current = window.setInterval(C, 50));
          }),
          onPointerLeave: E(l.onPointerLeave, () => {
            A();
          }),
        })
      );
    }),
    c2 = "SelectSeparator",
    e0 = a.forwardRef((g, I) => {
      const { __scopeSelect: e, ...C } = g;
      return s.jsx(tg.div, { "aria-hidden": !0, ...C, ref: I });
    });
  e0.displayName = c2;
  var Ed = "SelectArrow",
    d2 = a.forwardRef((g, I) => {
      const { __scopeSelect: e, ...C } = g,
        l = mA(e),
        t = eC(Ed, e),
        n = CC(Ed, e);
      return t.open && n.position === "popper"
        ? s.jsx(DZ, { ...l, ...C, ref: I })
        : null;
    });
  d2.displayName = Ed;
  function C0(g) {
    return g === "" || g === void 0;
  }
  var l0 = a.forwardRef((g, I) => {
    const { value: e, ...C } = g,
      l = a.useRef(null),
      t = Gg(I, l),
      n = dZ(e);
    return (
      a.useEffect(() => {
        const o = l.current,
          A = window.HTMLSelectElement.prototype,
          d = Object.getOwnPropertyDescriptor(A, "value").set;
        if (n !== e && d) {
          const i = new Event("change", { bubbles: !0 });
          d.call(o, e), o.dispatchEvent(i);
        }
      }, [n, e]),
      s.jsx(fb, {
        asChild: !0,
        children: s.jsx("select", { ...C, ref: t, defaultValue: e }),
      })
    );
  });
  l0.displayName = "BubbleSelect";
  function t0(g) {
    const I = tI(g),
      e = a.useRef(""),
      C = a.useRef(0),
      l = a.useCallback(
        (n) => {
          const o = e.current + n;
          I(o),
            (function A(c) {
              (e.current = c),
                window.clearTimeout(C.current),
                c !== "" && (C.current = window.setTimeout(() => A(""), 1e3));
            })(o);
        },
        [I]
      ),
      t = a.useCallback(() => {
        (e.current = ""), window.clearTimeout(C.current);
      }, []);
    return (
      a.useEffect(() => () => window.clearTimeout(C.current), []), [e, l, t]
    );
  }
  function n0(g, I, e) {
    const l = I.length > 1 && Array.from(I).every((c) => c === I[0]) ? I[0] : I,
      t = e ? g.indexOf(e) : -1;
    let n = i2(g, Math.max(t, 0));
    l.length === 1 && (n = n.filter((c) => c !== e));
    const A = n.find((c) =>
      c.textValue.toLowerCase().startsWith(l.toLowerCase())
    );
    return A !== e ? A : void 0;
  }
  function i2(g, I) {
    return g.map((e, C) => g[(I + C) % g.length]);
  }
  var a2 = Yb,
    o0 = wb,
    r2 = Kb,
    s2 = Fb,
    u2 = xb,
    A0 = Mb,
    m2 = Qb,
    c0 = Tb,
    d0 = Pb,
    Z2 = Ob,
    G2 = qb,
    i0 = $b,
    a0 = g0,
    r0 = e0;
  const b2 = a2,
    B2 = r2,
    s0 = a.forwardRef(({ className: g, children: I, ...e }, C) =>
      s.jsxs(o0, {
        ref: C,
        className: O(
          "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
          g
        ),
        ...e,
        children: [
          I,
          s.jsx(s2, {
            asChild: !0,
            children: s.jsx(bZ, { className: "h-4 w-4 opacity-50" }),
          }),
        ],
      })
    );
  s0.displayName = o0.displayName;
  const u0 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(i0, {
      ref: e,
      className: O("flex cursor-default items-center justify-center py-1", g),
      ...I,
      children: s.jsx(rS, { className: "h-4 w-4" }),
    })
  );
  u0.displayName = i0.displayName;
  const m0 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(a0, {
      ref: e,
      className: O("flex cursor-default items-center justify-center py-1", g),
      ...I,
      children: s.jsx(bZ, { className: "h-4 w-4" }),
    })
  );
  m0.displayName = a0.displayName;
  const Z0 = a.forwardRef(
    ({ className: g, children: I, position: e = "popper", ...C }, l) =>
      s.jsx(u2, {
        children: s.jsxs(A0, {
          ref: l,
          className: O(
            "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            e === "popper" &&
              "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            g
          ),
          position: e,
          ...C,
          children: [
            s.jsx(u0, {}),
            s.jsx(m2, {
              className: O(
                "p-1",
                e === "popper" &&
                  "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
              ),
              children: I,
            }),
            s.jsx(m0, {}),
          ],
        }),
      })
  );
  Z0.displayName = A0.displayName;
  const p2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(c0, {
      ref: e,
      className: O("py-1.5 pl-8 pr-2 text-sm font-semibold", g),
      ...I,
    })
  );
  p2.displayName = c0.displayName;
  const G0 = a.forwardRef(({ className: g, children: I, ...e }, C) =>
    s.jsxs(d0, {
      ref: C,
      className: O(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        g
      ),
      ...e,
      children: [
        s.jsx("span", {
          className:
            "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
          children: s.jsx(G2, {
            children: s.jsx(Ui, { className: "h-4 w-4" }),
          }),
        }),
        s.jsx(Z2, { children: I }),
      ],
    })
  );
  G0.displayName = d0.displayName;
  const y2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(r0, { ref: e, className: O("-mx-1 my-1 h-px bg-muted", g), ...I })
  );
  y2.displayName = r0.displayName;
  function h2({ table: g }) {
    return s.jsxs("div", {
      className: "flex items-center justify-between px-2",
      children: [
        s.jsxs("div", {
          className: "flex-1 text-sm text-muted-foreground",
          children: [
            g.getFilteredSelectedRowModel().rows.length,
            " of",
            " ",
            g.getFilteredRowModel().rows.length,
            " row(s) selected.",
          ],
        }),
        s.jsxs("div", {
          className: "flex items-center space-x-6 lg:space-x-8",
          children: [
            s.jsxs("div", {
              className: "flex items-center space-x-2",
              children: [
                s.jsx("p", {
                  className: "text-sm font-medium",
                  children: "Rows per page",
                }),
                s.jsxs(b2, {
                  value: `${g.getState().pagination.pageSize}`,
                  onValueChange: (I) => {
                    g.setPageSize(Number(I));
                  },
                  children: [
                    s.jsx(s0, {
                      className: "h-8 w-[70px]",
                      children: s.jsx(B2, {
                        placeholder: g.getState().pagination.pageSize,
                      }),
                    }),
                    s.jsx(Z0, {
                      side: "top",
                      children: [10, 20, 30, 40, 50].map((I) =>
                        s.jsx(G0, { value: `${I}`, children: I }, I)
                      ),
                    }),
                  ],
                }),
              ],
            }),
            s.jsxs("div", {
              className:
                "flex w-[100px] items-center justify-center text-sm font-medium",
              children: [
                "Page ",
                g.getState().pagination.pageIndex + 1,
                " of",
                " ",
                g.getPageCount(),
              ],
            }),
            s.jsxs("div", {
              className: "flex items-center space-x-2",
              children: [
                s.jsxs(fg, {
                  variant: "outline",
                  className: "hidden h-8 w-8 p-0 lg:flex",
                  onClick: () => g.setPageIndex(0),
                  disabled: !g.getCanPreviousPage(),
                  children: [
                    s.jsx("span", {
                      className: "sr-only",
                      children: "Go to first page",
                    }),
                    s.jsx(zS, { className: "h-4 w-4" }),
                  ],
                }),
                s.jsxs(fg, {
                  variant: "outline",
                  className: "h-8 w-8 p-0",
                  onClick: () => g.previousPage(),
                  disabled: !g.getCanPreviousPage(),
                  children: [
                    s.jsx("span", {
                      className: "sr-only",
                      children: "Go to previous page",
                    }),
                    s.jsx(JS, { className: "h-4 w-4" }),
                  ],
                }),
                s.jsxs(fg, {
                  variant: "outline",
                  className: "h-8 w-8 p-0",
                  onClick: () => g.nextPage(),
                  disabled: !g.getCanNextPage(),
                  children: [
                    s.jsx("span", {
                      className: "sr-only",
                      children: "Go to next page",
                    }),
                    s.jsx(kS, { className: "h-4 w-4" }),
                  ],
                }),
                s.jsxs(fg, {
                  variant: "outline",
                  className: "hidden h-8 w-8 p-0 lg:flex",
                  onClick: () => g.setPageIndex(g.getPageCount() - 1),
                  disabled: !g.getCanNextPage(),
                  children: [
                    s.jsx("span", {
                      className: "sr-only",
                      children: "Go to last page",
                    }),
                    s.jsx(US, { className: "h-4 w-4" }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    });
  }
  const b0 = a.forwardRef(({ className: g, type: I, ...e }, C) =>
    s.jsx("input", {
      type: I,
      className: O(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        g
      ),
      ref: C,
      ...e,
    })
  );
  b0.displayName = "Input";
  function S2({ table: g }) {
    return s.jsxs(iA, {
      children: [
        s.jsx(sa, {
          asChild: !0,
          children: s.jsxs(fg, {
            variant: "outline",
            size: "sm",
            className: "ml-auto hidden h-8 lg:flex",
            children: [s.jsx(TS, { className: "mr-2 h-4 w-4" }), "View"],
          }),
        }),
        s.jsxs(In, {
          align: "end",
          className: "w-[150px]",
          children: [
            s.jsx(ma, { children: "Toggle columns" }),
            s.jsx(bC, {}),
            g
              .getAllColumns()
              .filter((I) => typeof I.accessorFn < "u" && I.getCanHide())
              .map((I) =>
                s.jsx(
                  nb,
                  {
                    className: "capitalize",
                    checked: I.getIsVisible(),
                    onCheckedChange: (e) => I.toggleVisibility(!!e),
                    children: I.id,
                  },
                  I.id
                )
              ),
          ],
        }),
      ],
    });
  }
  function V2({ table: g }) {
    var e;
    const I = g.getState().columnFilters.length > 0;
    return s.jsxs("div", {
      className: "flex items-center justify-between",
      children: [
        s.jsxs("div", {
          className: "flex flex-1 items-center space-x-2",
          children: [
            s.jsx(b0, {
              placeholder: "Filter tasks...",
              value:
                ((e = g.getColumn("title")) == null
                  ? void 0
                  : e.getFilterValue()) ?? "",
              onChange: (C) => {
                var l;
                return (l = g.getColumn("title")) == null
                  ? void 0
                  : l.setFilterValue(C.target.value);
              },
              className: "h-8 w-[150px] lg:w-[250px]",
            }),
            I &&
              s.jsxs(fg, {
                variant: "ghost",
                onClick: () => g.resetColumnFilters(),
                className: "h-8 px-2 lg:px-3",
                children: ["Reset", s.jsx(wS, { className: "ml-2 h-4 w-4" })],
              }),
          ],
        }),
        s.jsx(S2, { table: g }),
      ],
    });
  }
  function W2({ columns: g, data: I }) {
    var i;
    const [e, C] = a.useState({}),
      [l, t] = a.useState({}),
      [n, o] = a.useState([]),
      [A, c] = a.useState([]),
      d = Uv({
        data: I,
        columns: g,
        state: {
          sorting: A,
          columnVisibility: l,
          rowSelection: e,
          columnFilters: n,
        },
        enableRowSelection: !0,
        onRowSelectionChange: C,
        onSortingChange: c,
        onColumnFiltersChange: o,
        onColumnVisibilityChange: t,
        getCoreRowModel: kv(),
        getFilteredRowModel: Kv(),
        getPaginationRowModel: Fv(),
        getSortedRowModel: xv(),
        getFacetedRowModel: wv(),
        getFacetedUniqueValues: Nv(),
      });
    return s.jsxs("div", {
      className: "space-y-4",
      children: [
        s.jsx(V2, { table: d }),
        s.jsx("div", {
          className: "rounded-md border",
          children: s.jsxs(Xb, {
            children: [
              s.jsx(Jb, {
                children: d
                  .getHeaderGroups()
                  .map((r) =>
                    s.jsx(
                      Pn,
                      {
                        children: r.headers.map((u) =>
                          s.jsx(
                            kb,
                            {
                              colSpan: u.colSpan,
                              children: u.isPlaceholder
                                ? null
                                : hs(u.column.columnDef.header, u.getContext()),
                            },
                            u.id
                          )
                        ),
                      },
                      r.id
                    )
                  ),
              }),
              s.jsx(vb, {
                children:
                  (i = d.getRowModel().rows) != null && i.length
                    ? d
                        .getRowModel()
                        .rows.map((r) =>
                          s.jsx(
                            Pn,
                            {
                              "data-state": r.getIsSelected() && "selected",
                              children: r
                                .getVisibleCells()
                                .map((u) =>
                                  s.jsx(
                                    Kd,
                                    {
                                      children: hs(
                                        u.column.columnDef.cell,
                                        u.getContext()
                                      ),
                                    },
                                    u.id
                                  )
                                ),
                            },
                            r.id
                          )
                        )
                    : s.jsx(Pn, {
                        children: s.jsx(Kd, {
                          colSpan: g.length,
                          className: "h-24 text-center",
                          children: "No results.",
                        }),
                      }),
              }),
            ],
          }),
        }),
        s.jsx(h2, { table: d }),
      ],
    });
  }
  var ha = "Avatar",
    [R2, Nk] = Ot(ha),
    [X2, B0] = R2(ha),
    p0 = a.forwardRef((g, I) => {
      const { __scopeAvatar: e, ...C } = g,
        [l, t] = a.useState("idle");
      return s.jsx(X2, {
        scope: e,
        imageLoadingStatus: l,
        onImageLoadingStatusChange: t,
        children: s.jsx(tg.span, { ...C, ref: I }),
      });
    });
  p0.displayName = ha;
  var y0 = "AvatarImage",
    h0 = a.forwardRef((g, I) => {
      const {
          __scopeAvatar: e,
          src: C,
          onLoadingStatusChange: l = () => {},
          ...t
        } = g,
        n = B0(y0, e),
        o = J2(C, t.referrerPolicy),
        A = tI((c) => {
          l(c), n.onImageLoadingStatusChange(c);
        });
      return (
        xg(() => {
          o !== "idle" && A(o);
        }, [o, A]),
        o === "loaded" ? s.jsx(tg.img, { ...t, ref: I, src: C }) : null
      );
    });
  h0.displayName = y0;
  var S0 = "AvatarFallback",
    V0 = a.forwardRef((g, I) => {
      const { __scopeAvatar: e, delayMs: C, ...l } = g,
        t = B0(S0, e),
        [n, o] = a.useState(C === void 0);
      return (
        a.useEffect(() => {
          if (C !== void 0) {
            const A = window.setTimeout(() => o(!0), C);
            return () => window.clearTimeout(A);
          }
        }, [C]),
        n && t.imageLoadingStatus !== "loaded"
          ? s.jsx(tg.span, { ...l, ref: I })
          : null
      );
    });
  V0.displayName = S0;
  function J2(g, I) {
    const [e, C] = a.useState("idle");
    return (
      xg(() => {
        if (!g) {
          C("error");
          return;
        }
        let l = !0;
        const t = new window.Image(),
          n = (o) => () => {
            l && C(o);
          };
        return (
          C("loading"),
          (t.onload = n("loaded")),
          (t.onerror = n("error")),
          (t.src = g),
          I && (t.referrerPolicy = I),
          () => {
            l = !1;
          }
        );
      }, [g, I]),
      e
    );
  }
  var W0 = p0,
    R0 = h0,
    X0 = V0;
  const J0 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(W0, {
      ref: e,
      className: O(
        "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
        g
      ),
      ...I,
    })
  );
  J0.displayName = W0.displayName;
  const v0 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(R0, { ref: e, className: O("aspect-square h-full w-full", g), ...I })
  );
  v0.displayName = R0.displayName;
  const k0 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx(X0, {
      ref: e,
      className: O(
        "flex h-full w-full items-center justify-center rounded-full bg-muted",
        g
      ),
      ...I,
    })
  );
  k0.displayName = X0.displayName;
  function v2() {
    return s.jsxs(iA, {
      children: [
        s.jsx(ua, {
          asChild: !0,
          children: s.jsx(fg, {
            variant: "ghost",
            className: "relative h-8 w-8 rounded-full",
            children: s.jsxs(J0, {
              className: "h-9 w-9",
              children: [
                s.jsx(v0, { src: "/avatars/03.png", alt: "@shadcn" }),
                s.jsx(k0, { children: "SC" }),
              ],
            }),
          }),
        }),
        s.jsxs(In, {
          className: "w-56",
          align: "end",
          forceMount: !0,
          children: [
            s.jsx(ma, {
              className: "font-normal",
              children: s.jsxs("div", {
                className: "flex flex-col space-y-1",
                children: [
                  s.jsx("p", {
                    className: "text-sm font-medium leading-none",
                    children: "shadcn",
                  }),
                  s.jsx("p", {
                    className: "text-xs leading-none text-muted-foreground",
                    children: "m@example.com",
                  }),
                ],
              }),
            }),
            s.jsx(bC, {}),
            s.jsxs(FX, {
              children: [
                s.jsxs(dI, {
                  children: ["Profile", s.jsx(jC, { children: "P" })],
                }),
                s.jsxs(dI, {
                  children: ["Billing", s.jsx(jC, { children: "B" })],
                }),
                s.jsxs(dI, {
                  children: ["Settings", s.jsx(jC, { children: "S" })],
                }),
                s.jsx(dI, { children: "New Team" }),
              ],
            }),
            s.jsx(bC, {}),
            s.jsxs(dI, {
              children: ["Log out", s.jsx(jC, { children: "Q" })],
            }),
          ],
        }),
      ],
    });
  }
  function k2(g) {
    return new Promise((I, e) => {
      google.script.run
        .withSuccessHandler((C) => {
          console.log(C), I(C);
        })
        .withFailureHandler((C) => {
          console.log(C), e(C);
        })
        .getSheetData(g);
    });
  }
  function f2() {
    const [g, I] = a.useState([]);
    return (
      a.useEffect(() => {
        k2("Tasks")
          .then((e) => {
            I(JSON.parse(e));
          })
          .catch((e) => {
            console.log(e);
          });
      }, []),
      s.jsx(s.Fragment, {
        children: s.jsxs("div", {
          className: "hidden h-full flex-1 flex-col space-y-8 p-8 md:flex",
          children: [
            s.jsxs("div", {
              className: "flex items-center justify-between space-y-2",
              children: [
                s.jsxs("div", {
                  children: [
                    s.jsx("h2", {
                      className: "text-2xl font-bold tracking-tight",
                      children: "Welcome back!",
                    }),
                    s.jsx("p", {
                      className: "text-muted-foreground",
                      children: "Here's a list of your tasks for this month!",
                    }),
                  ],
                }),
                s.jsx("div", {
                  className: "flex items-center space-x-2",
                  children: s.jsx(v2, {}),
                }),
              ],
            }),
            s.jsx(W2, { data: g, columns: LJ }),
          ],
        }),
      })
    );
  }
  const Y2 = () => s.jsx(s.Fragment, { children: s.jsx(f2, {}) }),
    H2 = () => s.jsx("h2", { children: "Settings" });
  function w2() {
    return s.jsxs("div", {
      className:
        "flex flex-col items-center justify-center text-center min-h-[calc(100vh-4rem)]",
      children: [
        " ",
        s.jsx("h1", {
          className: "text-5xl font-bold text-blue-700 mb-4",
          children: "Seed Inventory System",
        }),
        s.jsx("p", {
          className: "text-xl text-gray-700 mb-8 max-w-2xl",
          children:
            "Efficiently manage and track your seed inventory with precision and ease. Streamline your agricultural operations from storage to planting.",
        }),
        s.jsxs(ho, {
          to: "/tasks",
          children: [
            " ",
            s.jsx(fg, {
              size: "lg",
              className:
                "text-lg px-8 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-md shadow-lg transition duration-300 ease-in-out",
              children: "Get Started ",
            }),
          ],
        }),
      ],
    });
  }
  const Fo = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("div", {
      ref: e,
      className: O(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        g
      ),
      ...I,
    })
  );
  Fo.displayName = "Card";
  const N2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("div", {
      ref: e,
      className: O("flex flex-col space-y-1.5 p-6", g),
      ...I,
    })
  );
  N2.displayName = "CardHeader";
  const K2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("h3", {
      ref: e,
      className: O("text-2xl font-semibold leading-none tracking-tight", g),
      ...I,
    })
  );
  K2.displayName = "CardTitle";
  const F2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("p", {
      ref: e,
      className: O("text-sm text-muted-foreground", g),
      ...I,
    })
  );
  F2.displayName = "CardDescription";
  const x2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("div", { ref: e, className: O("p-6 pt-0", g), ...I })
  );
  x2.displayName = "CardContent";
  const M2 = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("div", {
      ref: e,
      className: O("flex items-center p-6 pt-0", g),
      ...I,
    })
  );
  M2.displayName = "CardFooter";
  const z2 = () =>
      s.jsxs("div", {
        className: "container mx-auto px-4 py-8",
        children: [
          s.jsxs("div", {
            className: "text-center mb-8",
            children: [
              s.jsx("h1", {
                className: "text-4xl font-bold tracking-tight text-primary",
                children: "Main Menu",
              }),
              s.jsx("p", {
                className: "mt-2 text-lg text-gray-600",
                children: "Select an option to manage your seed inventory.",
              }),
            ],
          }),
          s.jsxs("div", {
            className: "grid grid-cols-1 md:grid-cols-2 gap-6 lg:gap-8",
            children: [
              s.jsxs(Fo, {
                className:
                  "p-6 shadow-lg flex flex-col items-center text-center",
                children: [
                  s.jsx("div", {
                    className: "mb-4 text-primary",
                    children: s.jsx("img", {
                      src: "/icons/inventory.svg",
                      alt: "Monitor Inventory Icon",
                      className: "h-12 w-12",
                    }),
                  }),
                  s.jsx("h2", {
                    className: "text-2xl font-bold mb-4",
                    children: "Monitor Inventory",
                  }),
                  s.jsx("p", {
                    className: "mb-6 text-gray-700",
                    children:
                      "View and manage current seed stock, track volumes, and analyze storage data across locations.",
                  }),
                  s.jsx(fg, {
                    asChild: !0,
                    className: "w-full",
                    variant: "outline",
                    children: s.jsx(ho, {
                      to: "/monitor-inventory",
                      children: "Go to Monitor Inventory",
                    }),
                  }),
                ],
              }),
              s.jsxs(Fo, {
                className:
                  "p-6 shadow-lg flex flex-col items-center text-center",
                children: [
                  s.jsx("div", {
                    className: "mb-4 text-primary",
                    children: s.jsx("img", {
                      src: "/icons/scan-qr.svg",
                      alt: "Scan QR Codes Icon",
                      className: "h-12 w-12",
                    }),
                  }),
                  s.jsx("h2", {
                    className: "text-2xl font-bold mb-4",
                    children: "Scan QR Codes",
                  }),
                  s.jsx("p", {
                    className: "mb-6 text-gray-700",
                    children:
                      "Quickly access seed details by scanning QR codes. Ideal for field or warehouse operations.",
                  }),
                  s.jsx(fg, {
                    asChild: !0,
                    className: "w-full",
                    variant: "outline",
                    children: s.jsx(ho, {
                      to: "/scan-qr",
                      children: "Go to Scan QR Codes",
                    }),
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    E2 = Mi(
      "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
      {
        variants: {
          variant: {
            default: "bg-background text-foreground",
            destructive:
              "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
          },
        },
        defaultVariants: { variant: "default" },
      }
    ),
    Sa = a.forwardRef(({ className: g, variant: I, ...e }, C) =>
      s.jsx("div", {
        ref: C,
        role: "alert",
        className: O(E2({ variant: I }), g),
        ...e,
      })
    );
  Sa.displayName = "Alert";
  const Va = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("h5", {
      ref: e,
      className: O("mb-1 font-medium leading-none tracking-tight", g),
      ...I,
    })
  );
  Va.displayName = "AlertTitle";
  const Wa = a.forwardRef(({ className: g, ...I }, e) =>
    s.jsx("div", {
      ref: e,
      className: O("text-sm [&_p]:leading-relaxed", g),
      ...I,
    })
  );
  Wa.displayName = "AlertDescription";
  function Ud() {
    return (
      (Ud = Object.assign
        ? Object.assign.bind()
        : function (g) {
            for (var I = 1; I < arguments.length; I++) {
              var e = arguments[I];
              for (var C in e) ({}).hasOwnProperty.call(e, C) && (g[C] = e[C]);
            }
            return g;
          }),
      Ud.apply(null, arguments)
    );
  }
  function Et(g) {
    "@babel/helpers - typeof";
    return (
      (Et =
        typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
          ? function (I) {
              return typeof I;
            }
          : function (I) {
              return I &&
                typeof Symbol == "function" &&
                I.constructor === Symbol &&
                I !== Symbol.prototype
                ? "symbol"
                : typeof I;
            }),
      Et(g)
    );
  }
  function U2(g, I) {
    if (Et(g) != "object" || !g) return g;
    var e = g[Symbol.toPrimitive];
    if (e !== void 0) {
      var C = e.call(g, I || "default");
      if (Et(C) != "object") return C;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (I === "string" ? String : Number)(g);
  }
  function Q2(g) {
    var I = U2(g, "string");
    return Et(I) == "symbol" ? I : I + "";
  }
  function L2(g, I, e) {
    return (
      (I = Q2(I)) in g
        ? Object.defineProperty(g, I, {
            value: e,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (g[I] = e),
      g
    );
  }
  function D2(g) {
    if (Array.isArray(g)) return g;
  }
  function T2(g, I) {
    var e =
      g == null
        ? null
        : (typeof Symbol < "u" && g[Symbol.iterator]) || g["@@iterator"];
    if (e != null) {
      var C,
        l,
        t,
        n,
        o = [],
        A = !0,
        c = !1;
      try {
        if (((t = (e = e.call(g)).next), I !== 0))
          for (
            ;
            !(A = (C = t.call(e)).done) && (o.push(C.value), o.length !== I);
            A = !0
          );
      } catch (d) {
        (c = !0), (l = d);
      } finally {
        try {
          if (!A && e.return != null && ((n = e.return()), Object(n) !== n))
            return;
        } finally {
          if (c) throw l;
        }
      }
      return o;
    }
  }
  function Vs(g, I) {
    (I == null || I > g.length) && (I = g.length);
    for (var e = 0, C = Array(I); e < I; e++) C[e] = g[e];
    return C;
  }
  function j2(g, I) {
    if (g) {
      if (typeof g == "string") return Vs(g, I);
      var e = {}.toString.call(g).slice(8, -1);
      return (
        e === "Object" && g.constructor && (e = g.constructor.name),
        e === "Map" || e === "Set"
          ? Array.from(g)
          : e === "Arguments" ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)
          ? Vs(g, I)
          : void 0
      );
    }
  }
  function P2() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function O2(g, I) {
    return D2(g) || T2(g, I) || j2(g, I) || P2();
  }
  function _2(g, I) {
    if (g == null) return {};
    var e = {};
    for (var C in g)
      if ({}.hasOwnProperty.call(g, C)) {
        if (I.includes(C)) continue;
        e[C] = g[C];
      }
    return e;
  }
  function q2(g, I) {
    if (g == null) return {};
    var e,
      C,
      l = _2(g, I);
    if (Object.getOwnPropertySymbols) {
      var t = Object.getOwnPropertySymbols(g);
      for (C = 0; C < t.length; C++)
        (e = t[C]),
          I.includes(e) ||
            ({}.propertyIsEnumerable.call(g, e) && (l[e] = g[e]));
    }
    return l;
  }
  var f0 = { exports: {} },
    ag = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var wg = typeof Symbol == "function" && Symbol.for,
    Ra = wg ? Symbol.for("react.element") : 60103,
    Xa = wg ? Symbol.for("react.portal") : 60106,
    ZA = wg ? Symbol.for("react.fragment") : 60107,
    GA = wg ? Symbol.for("react.strict_mode") : 60108,
    bA = wg ? Symbol.for("react.profiler") : 60114,
    BA = wg ? Symbol.for("react.provider") : 60109,
    pA = wg ? Symbol.for("react.context") : 60110,
    Ja = wg ? Symbol.for("react.async_mode") : 60111,
    yA = wg ? Symbol.for("react.concurrent_mode") : 60111,
    hA = wg ? Symbol.for("react.forward_ref") : 60112,
    SA = wg ? Symbol.for("react.suspense") : 60113,
    $2 = wg ? Symbol.for("react.suspense_list") : 60120,
    VA = wg ? Symbol.for("react.memo") : 60115,
    WA = wg ? Symbol.for("react.lazy") : 60116,
    gk = wg ? Symbol.for("react.block") : 60121,
    Ik = wg ? Symbol.for("react.fundamental") : 60117,
    ek = wg ? Symbol.for("react.responder") : 60118,
    Ck = wg ? Symbol.for("react.scope") : 60119;
  function bI(g) {
    if (typeof g == "object" && g !== null) {
      var I = g.$$typeof;
      switch (I) {
        case Ra:
          switch (((g = g.type), g)) {
            case Ja:
            case yA:
            case ZA:
            case bA:
            case GA:
            case SA:
              return g;
            default:
              switch (((g = g && g.$$typeof), g)) {
                case pA:
                case hA:
                case WA:
                case VA:
                case BA:
                  return g;
                default:
                  return I;
              }
          }
        case Xa:
          return I;
      }
    }
  }
  function Y0(g) {
    return bI(g) === yA;
  }
  ag.AsyncMode = Ja;
  ag.ConcurrentMode = yA;
  ag.ContextConsumer = pA;
  ag.ContextProvider = BA;
  ag.Element = Ra;
  ag.ForwardRef = hA;
  ag.Fragment = ZA;
  ag.Lazy = WA;
  ag.Memo = VA;
  ag.Portal = Xa;
  ag.Profiler = bA;
  ag.StrictMode = GA;
  ag.Suspense = SA;
  ag.isAsyncMode = function (g) {
    return Y0(g) || bI(g) === Ja;
  };
  ag.isConcurrentMode = Y0;
  ag.isContextConsumer = function (g) {
    return bI(g) === pA;
  };
  ag.isContextProvider = function (g) {
    return bI(g) === BA;
  };
  ag.isElement = function (g) {
    return typeof g == "object" && g !== null && g.$$typeof === Ra;
  };
  ag.isForwardRef = function (g) {
    return bI(g) === hA;
  };
  ag.isFragment = function (g) {
    return bI(g) === ZA;
  };
  ag.isLazy = function (g) {
    return bI(g) === WA;
  };
  ag.isMemo = function (g) {
    return bI(g) === VA;
  };
  ag.isPortal = function (g) {
    return bI(g) === Xa;
  };
  ag.isProfiler = function (g) {
    return bI(g) === bA;
  };
  ag.isStrictMode = function (g) {
    return bI(g) === GA;
  };
  ag.isSuspense = function (g) {
    return bI(g) === SA;
  };
  ag.isValidElementType = function (g) {
    return (
      typeof g == "string" ||
      typeof g == "function" ||
      g === ZA ||
      g === yA ||
      g === bA ||
      g === GA ||
      g === SA ||
      g === $2 ||
      (typeof g == "object" &&
        g !== null &&
        (g.$$typeof === WA ||
          g.$$typeof === VA ||
          g.$$typeof === BA ||
          g.$$typeof === pA ||
          g.$$typeof === hA ||
          g.$$typeof === Ik ||
          g.$$typeof === ek ||
          g.$$typeof === Ck ||
          g.$$typeof === gk))
    );
  };
  ag.typeOf = bI;
  /*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var Ws = Object.getOwnPropertySymbols,
    lk = Object.prototype.hasOwnProperty,
    tk = Object.prototype.propertyIsEnumerable;
  function nk(g) {
    if (g == null)
      throw new TypeError(
        "Object.assign cannot be called with null or undefined"
      );
    return Object(g);
  }
  function ok() {
    try {
      if (!Object.assign) return !1;
      var g = new String("abc");
      if (((g[5] = "de"), Object.getOwnPropertyNames(g)[0] === "5")) return !1;
      for (var I = {}, e = 0; e < 10; e++) I["_" + String.fromCharCode(e)] = e;
      var C = Object.getOwnPropertyNames(I).map(function (t) {
        return I[t];
      });
      if (C.join("") !== "0123456789") return !1;
      var l = {};
      return (
        "abcdefghijklmnopqrst".split("").forEach(function (t) {
          l[t] = t;
        }),
        Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst"
      );
    } catch {
      return !1;
    }
  }
  ok();
  var Ak = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
    ck = Ak;
  Function.call.bind(Object.prototype.hasOwnProperty);
  var dk = ck;
  function H0() {}
  function w0() {}
  w0.resetWarningCache = H0;
  var ik = function () {
    function g(C, l, t, n, o, A) {
      if (A !== dk) {
        var c = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw ((c.name = "Invariant Violation"), c);
      }
    }
    g.isRequired = g;
    function I() {
      return g;
    }
    var e = {
      array: g,
      bigint: g,
      bool: g,
      func: g,
      number: g,
      object: g,
      string: g,
      symbol: g,
      any: g,
      arrayOf: I,
      element: g,
      elementType: g,
      instanceOf: I,
      node: g,
      objectOf: I,
      oneOf: I,
      oneOfType: I,
      shape: I,
      exact: I,
      checkPropTypes: w0,
      resetWarningCache: H0,
    };
    return (e.PropTypes = e), e;
  };
  f0.exports = ik();
  var HC = f0.exports;
  function ak(g, I) {
    var e = atob(g);
    return e;
  }
  function rk(g, I, e) {
    var C = ak(g),
      l =
        C.indexOf(
          `
`,
          10
        ) + 1,
      t = C.substring(l) + "",
      n = new Blob([t], { type: "application/javascript" });
    return URL.createObjectURL(n);
  }
  function sk(g, I, e) {
    var C;
    return function (t) {
      return (C = C || rk(g)), new Worker(C, t);
    };
  }
  var uk = sk(
      "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewoJJ3VzZSBzdHJpY3QnOwoKCXZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9OwoKCWZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuKSB7CgkJaWYgKG4uX19lc01vZHVsZSkgcmV0dXJuIG47CgkJdmFyIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7CgkJT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbiAoaykgewoJCQl2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7CgkJCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrLCBkLmdldCA/IGQgOiB7CgkJCQllbnVtZXJhYmxlOiB0cnVlLAoJCQkJZ2V0OiBmdW5jdGlvbiAoKSB7CgkJCQkJcmV0dXJuIG5ba107CgkJCQl9CgkJCX0pOwoJCX0pOwoJCXJldHVybiBhOwoJfQoKCXZhciBCaW5hcnlCaXRtYXAkMSA9IHt9OwoKCXZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24kMSA9IHt9OwoKCXZhciBFeGNlcHRpb24kMSA9IHt9OwoKCWZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7CgkgIHZhciBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjsKCSAgc2V0UHJvdG90eXBlT2YgPyBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvdHlwZSkgOiB0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlOwoJfQoJZnVuY3Rpb24gZml4U3RhY2sodGFyZ2V0LCBmbikgewoJICBpZiAoZm4gPT09IHZvaWQgMCkgewoJICAgIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yOwoJICB9CgoJICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTsKCSAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7Cgl9CgoJdmFyIF9fZXh0ZW5kcyRrID0gZnVuY3Rpb24gKCkgewoJICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7CgkgICAgICBfX3Byb3RvX186IFtdCgkgICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICBkLl9fcHJvdG9fXyA9IGI7CgkgICAgfSB8fCBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgZm9yICh2YXIgcCBpbiBiKSB7IGlmIChiLmhhc093blByb3BlcnR5KHApKSB7IGRbcF0gPSBiW3BdOyB9IH0KCSAgICB9OwoKCSAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgfTsKCgkgIHJldHVybiBmdW5jdGlvbiAoZCwgYikgewoJICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgoJICAgIGZ1bmN0aW9uIF9fKCkgewoJICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7CgkgICAgfQoKCSAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgIH07Cgl9KCk7CgoJdmFyIEN1c3RvbUVycm9yID0gZnVuY3Rpb24gKF9zdXBlcikgewoJICBfX2V4dGVuZHMkayhDdXN0b21FcnJvciwgX3N1cGVyKTsKCgkgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UpIHsKCSAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7CgoJICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7CgoJICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ25hbWUnLCB7CgkgICAgICB2YWx1ZTogX25ld1RhcmdldC5uYW1lLAoJICAgICAgZW51bWVyYWJsZTogZmFsc2UsCgkgICAgICBjb25maWd1cmFibGU6IHRydWUKCSAgICB9KTsKCSAgICBmaXhQcm90byhfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpOwoJICAgIGZpeFN0YWNrKF90aGlzKTsKCSAgICByZXR1cm4gX3RoaXM7CgkgIH0KCgkgIHJldHVybiBDdXN0b21FcnJvcjsKCX0oRXJyb3IpOwoKCXZhciBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHsKCSAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzOwoKCSAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7IHMgKz0gYXJndW1lbnRzJDFbaV0ubGVuZ3RoOyB9CgoJICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIHsgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHsgcltrXSA9IGFbal07IH0gfQoKCSAgcmV0dXJuIHI7Cgl9OwoJZnVuY3Rpb24gY3VzdG9tRXJyb3JGYWN0b3J5KGZuLCBwYXJlbnQpIHsKCSAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7CgkgICAgcGFyZW50ID0gRXJyb3I7CgkgIH0KCgkgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKCkgewoJICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50czsKCgkgICAgdmFyIGFyZ3MgPSBbXTsKCgkgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHsKCSAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzJDFbX2ldOwoJICAgIH0KCgkgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSkgeyByZXR1cm4gbmV3IChDdXN0b21FcnJvci5iaW5kLmFwcGx5KEN1c3RvbUVycm9yLCBfX3NwcmVhZEFycmF5cyhbdm9pZCAwXSwgYXJncykpKSgpOyB9CgkgICAgcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3MpOwoJICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHsKCSAgICAgIHZhbHVlOiBmbi5uYW1lIHx8IHBhcmVudC5uYW1lLAoJICAgICAgZW51bWVyYWJsZTogZmFsc2UsCgkgICAgICBjb25maWd1cmFibGU6IHRydWUKCSAgICB9KTsKCSAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTsKCSAgICBmaXhTdGFjayh0aGlzLCBDdXN0b21FcnJvcik7CgkgIH0KCgkgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDdXN0b21FcnJvciwgewoJICAgIHByb3RvdHlwZTogewoJICAgICAgdmFsdWU6IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSwgewoJICAgICAgICBjb25zdHJ1Y3RvcjogewoJICAgICAgICAgIHZhbHVlOiBDdXN0b21FcnJvciwKCSAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKCSAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKCSAgICAgICAgfQoJICAgICAgfSkKCSAgICB9CgkgIH0pOwoJfQoKCXZhciBjdXN0b21FcnJvciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHsKCQlfX3Byb3RvX186IG51bGwsCgkJQ3VzdG9tRXJyb3I6IEN1c3RvbUVycm9yLAoJCWN1c3RvbUVycm9yRmFjdG9yeTogY3VzdG9tRXJyb3JGYWN0b3J5Cgl9KTsKCgl2YXIgcmVxdWlyZSQkMCA9IC8qQF9fUFVSRV9fKi9nZXRBdWdtZW50ZWROYW1lc3BhY2UoY3VzdG9tRXJyb3IpOwoKCXZhciBfX2V4dGVuZHMkaiA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGNlcHRpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIHRzX2N1c3RvbV9lcnJvcl8xID0gcmVxdWlyZSQkMDsKCS8qKgoJICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLgoJICovCgl2YXIgRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikgewoJICAgIF9fZXh0ZW5kcyRqKEV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICAvKioKCSAgICAgKiBBbGxvd3MgRXhjZXB0aW9uIHRvIGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5CgkgICAgICogd2l0aCBzb21lIG1lc3NhZ2UgYW5kIHByb3RvdHlwZSBkZWZpbml0aW9uLgoJICAgICAqLwoJICAgIGZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlKSB7CgkgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IHVuZGVmaW5lZDsgfQoJICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzOwoJICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKCSAgICAgICAgcmV0dXJuIF90aGlzOwoJICAgIH0KCSAgICBFeGNlcHRpb24ucHJvdG90eXBlLmdldEtpbmQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHZhciBleCA9IHRoaXMuY29uc3RydWN0b3I7CgkgICAgICAgIHJldHVybiBleC5raW5kOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogSXQncyB0eXBlZCBhcyBzdHJpbmcgc28gaXQgY2FuIGJlIGV4dGVuZGVkIGFuZCBvdmVycmlkZW4uCgkgICAgICovCgkgICAgRXhjZXB0aW9uLmtpbmQgPSAnRXhjZXB0aW9uJzsKCSAgICByZXR1cm4gRXhjZXB0aW9uOwoJfSh0c19jdXN0b21fZXJyb3JfMS5DdXN0b21FcnJvcikpOwoJRXhjZXB0aW9uJDEuZGVmYXVsdCA9IEV4Y2VwdGlvbjsKCgl2YXIgX19leHRlbmRzJGkgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBFeGNlcHRpb25fMSQ5ID0gRXhjZXB0aW9uJDE7CgkvKioKCSAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi4KCSAqLwoJdmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkaShJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24sIF9zdXBlcik7CgkgICAgZnVuY3Rpb24gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCkgewoJICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7CgkgICAgfQoJICAgIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbic7CgkgICAgcmV0dXJuIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjsKCX0oRXhjZXB0aW9uXzEkOS5kZWZhdWx0KSk7CglJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24kMS5kZWZhdWx0ID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluYXJ5Qml0bWFwJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSRhID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJDE7Cgl2YXIgQmluYXJ5Qml0bWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIEJpbmFyeUJpdG1hcChiaW5hcml6ZXIpIHsKCSAgICAgICAgdGhpcy5iaW5hcml6ZXIgPSBiaW5hcml6ZXI7CgkgICAgICAgIGlmIChiaW5hcml6ZXIgPT09IG51bGwpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSRhLmRlZmF1bHQoJ0JpbmFyaXplciBtdXN0IGJlIG5vbi1udWxsLicpOwoJICAgICAgICB9CgkgICAgfQoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gVGhlIHdpZHRoIG9mIHRoZSBiaXRtYXAuCgkgICAgICovCgkgICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldFdpZHRoKCk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIFRoZSBoZWlnaHQgb2YgdGhlIGJpdG1hcC4KCSAgICAgKi8KCSAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEhlaWdodCgpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQ29udmVydHMgb25lIHJvdyBvZiBsdW1pbmFuY2UgZGF0YSB0byAxIGJpdCBkYXRhLiBNYXkgYWN0dWFsbHkgZG8gdGhlIGNvbnZlcnNpb24sIG9yIHJldHVybgoJICAgICAqIGNhY2hlZCBkYXRhLiBDYWxsZXJzIHNob3VsZCBhc3N1bWUgdGhpcyBtZXRob2QgaXMgZXhwZW5zaXZlIGFuZCBjYWxsIGl0IGFzIHNlbGRvbSBhcyBwb3NzaWJsZS4KCSAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZGVjb2RpbmcgMUQgYmFyY29kZXMgYW5kIG1heSBjaG9vc2UgdG8gYXBwbHkgc2hhcnBlbmluZy4KCSAgICAgKgoJICAgICAqIEBwYXJhbSB5IFRoZSByb3cgdG8gZmV0Y2gsIHdoaWNoIG11c3QgYmUgaW4gWzAsIGJpdG1hcCBoZWlnaHQpCgkgICAgICogQHBhcmFtIHJvdyBBbiBvcHRpb25hbCBwcmVhbGxvY2F0ZWQgYXJyYXkuIElmIG51bGwgb3IgdG9vIHNtYWxsLCBpdCB3aWxsIGJlIGlnbm9yZWQuCgkgICAgICogICAgICAgICAgICBJZiB1c2VkLCB0aGUgQmluYXJpemVyIHdpbGwgY2FsbCBCaXRBcnJheS5jbGVhcigpLiBBbHdheXMgdXNlIHRoZSByZXR1cm5lZCBvYmplY3QuCgkgICAgICogQHJldHVybiBUaGUgYXJyYXkgb2YgYml0cyBmb3IgdGhpcyByb3cgKHRydWUgbWVhbnMgYmxhY2spLgoJICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcm93IGNhbid0IGJlIGJpbmFyaXplZAoJICAgICAqLwoJICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuZ2V0QmxhY2tSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEJsYWNrUm93KHksIHJvdyk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBDb252ZXJ0cyBhIDJEIGFycmF5IG9mIGx1bWluYW5jZSBkYXRhIHRvIDEgYml0LiBBcyBhYm92ZSwgYXNzdW1lIHRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZQoJICAgICAqIGFuZCBkbyBub3QgY2FsbCBpdCByZXBlYXRlZGx5LiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZGVjb2RpbmcgMkQgYmFyY29kZXMgYW5kIG1heSBvcgoJICAgICAqIG1heSBub3QgYXBwbHkgc2hhcnBlbmluZy4gVGhlcmVmb3JlLCBhIHJvdyBmcm9tIHRoaXMgbWF0cml4IG1heSBub3QgYmUgaWRlbnRpY2FsIHRvIG9uZQoJICAgICAqIGZldGNoZWQgdXNpbmcgZ2V0QmxhY2tSb3coKSwgc28gZG9uJ3QgbWl4IGFuZCBtYXRjaCBiZXR3ZWVuIHRoZW0uCgkgICAgICoKCSAgICAgKiBAcmV0dXJuIFRoZSAyRCBhcnJheSBvZiBiaXRzIGZvciB0aGUgaW1hZ2UgKHRydWUgbWVhbnMgYmxhY2spLgoJICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgaW1hZ2UgY2FuJ3QgYmUgYmluYXJpemVkIHRvIG1ha2UgYSBtYXRyaXgKCSAgICAgKi8KCSAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmdldEJsYWNrTWF0cml4ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICAvLyBUaGUgbWF0cml4IGlzIGNyZWF0ZWQgb24gZGVtYW5kIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHJlcXVlc3RlZCwgdGhlbiBjYWNoZWQuIFRoZXJlIGFyZSB0d28KCSAgICAgICAgLy8gcmVhc29ucyBmb3IgdGhpczoKCSAgICAgICAgLy8gMS4gVGhpcyB3b3JrIHdpbGwgbmV2ZXIgYmUgZG9uZSBpZiB0aGUgY2FsbGVyIG9ubHkgaW5zdGFsbHMgMUQgUmVhZGVyIG9iamVjdHMsIG9yIGlmIGEKCSAgICAgICAgLy8gICAgMUQgUmVhZGVyIGZpbmRzIGEgYmFyY29kZSBiZWZvcmUgdGhlIDJEIFJlYWRlcnMgcnVuLgoJICAgICAgICAvLyAyLiBUaGlzIHdvcmsgd2lsbCBvbmx5IGJlIGRvbmUgb25jZSBldmVuIGlmIHRoZSBjYWxsZXIgaW5zdGFsbHMgbXVsdGlwbGUgMkQgUmVhZGVycy4KCSAgICAgICAgaWYgKHRoaXMubWF0cml4ID09PSBudWxsIHx8IHRoaXMubWF0cml4ID09PSB1bmRlZmluZWQpIHsKCSAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5iaW5hcml6ZXIuZ2V0QmxhY2tNYXRyaXgoKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBiaXRtYXAgY2FuIGJlIGNyb3BwZWQuCgkgICAgICovCgkgICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5pc0Nyb3BTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5pc0Nyb3BTdXBwb3J0ZWQoKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggY3JvcHBlZCBpbWFnZSBkYXRhLiBJbXBsZW1lbnRhdGlvbnMgbWF5IGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlCgkgICAgICogb3JpZ2luYWwgZGF0YSByYXRoZXIgdGhhbiBhIGNvcHkuIE9ubHkgY2FsbGFibGUgaWYgaXNDcm9wU3VwcG9ydGVkKCkgaXMgdHJ1ZS4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IGNvb3JkaW5hdGUsIHdoaWNoIG11c3QgYmUgaW4gWzAsZ2V0V2lkdGgoKSkKCSAgICAgKiBAcGFyYW0gdG9wIFRoZSB0b3AgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRIZWlnaHQoKSkKCSAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC4KCSAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB0byBjcm9wLgoJICAgICAqIEByZXR1cm4gQSBjcm9wcGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuCgkgICAgICovCgkgICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7CgkgICAgICAgIHZhciBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5jcm9wKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7CgkgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIGJpdG1hcCBzdXBwb3J0cyBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi4KCSAgICAgKi8KCSAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmlzUm90YXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkuaXNSb3RhdGVTdXBwb3J0ZWQoKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS4KCSAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS4KCSAgICAgKgoJICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuCgkgICAgICovCgkgICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpOwoJICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA0NSBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuCgkgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuCgkgICAgICoKCSAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LgoJICAgICAqLwoJICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCk7CgkgICAgICAgIHJldHVybiBuZXcgQmluYXJ5Qml0bWFwKHRoaXMuYmluYXJpemVyLmNyZWF0ZUJpbmFyaXplcihuZXdTb3VyY2UpKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxhY2tNYXRyaXgoKS50b1N0cmluZygpOwoJICAgICAgICB9CgkgICAgICAgIGNhdGNoIChlIC8qOiBOb3RGb3VuZEV4Y2VwdGlvbiovKSB7CgkgICAgICAgICAgICByZXR1cm4gJyc7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIHJldHVybiBCaW5hcnlCaXRtYXA7Cgl9KCkpOwoJdmFyIF9kZWZhdWx0JDMgPSBCaW5hcnlCaXRtYXAkMS5kZWZhdWx0ID0gQmluYXJ5Qml0bWFwOwoKCXZhciBIeWJyaWRCaW5hcml6ZXIkMSA9IHt9OwoKCXZhciBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIkMSA9IHt9OwoKCXZhciBCaW5hcml6ZXIkMSA9IHt9OwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluYXJpemVyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qKgoJICogVGhpcyBjbGFzcyBoaWVyYXJjaHkgcHJvdmlkZXMgYSBzZXQgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGx1bWluYW5jZSBkYXRhIHRvIDEgYml0IGRhdGEuCgkgKiBJdCBhbGxvd3MgdGhlIGFsZ29yaXRobSB0byB2YXJ5IHBvbHltb3JwaGljYWxseSwgZm9yIGV4YW1wbGUgYWxsb3dpbmcgYSB2ZXJ5IGV4cGVuc2l2ZQoJICogdGhyZXNob2xkaW5nIHRlY2huaXF1ZSBmb3Igc2VydmVycyBhbmQgYSBmYXN0IG9uZSBmb3IgbW9iaWxlLiBJdCBhbHNvIHBlcm1pdHMgdGhlIGltcGxlbWVudGF0aW9uCgkgKiB0byB2YXJ5LCBlLmcuIGEgSk5JIHZlcnNpb24gZm9yIEFuZHJvaWQgYW5kIGEgSmF2YSBmYWxsYmFjayB2ZXJzaW9uIGZvciBvdGhlciBwbGF0Zm9ybXMuCgkgKgoJICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikKCSAqLwoJdmFyIEJpbmFyaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBCaW5hcml6ZXIoc291cmNlKSB7CgkgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlOwoJICAgIH0KCSAgICBCaW5hcml6ZXIucHJvdG90eXBlLmdldEx1bWluYW5jZVNvdXJjZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlOwoJICAgIH07CgkgICAgQmluYXJpemVyLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldFdpZHRoKCk7CgkgICAgfTsKCSAgICBCaW5hcml6ZXIucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldEhlaWdodCgpOwoJICAgIH07CgkgICAgcmV0dXJuIEJpbmFyaXplcjsKCX0oKSk7CglCaW5hcml6ZXIkMS5kZWZhdWx0ID0gQmluYXJpemVyOwoKCXZhciBCaXRBcnJheSQxID0ge307CgoJdmFyIEFycmF5cyQxID0ge307CgoJdmFyIFN5c3RlbSQxID0ge307CgoJT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5c3RlbSQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgU3lzdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIFN5c3RlbSgpIHsKCSAgICB9CgkgICAgLy8gcHVibGljIHN0YXRpYyB2b2lkIGFycmF5Y29weShPYmplY3Qgc3JjLCBpbnQgc3JjUG9zLCBPYmplY3QgZGVzdCwgaW50IGRlc3RQb3MsIGludCBsZW5ndGgpCgkgICAgLyoqCgkgICAgICogTWFrZXMgYSBjb3B5IG9mIGEgYXJyYXkuCgkgICAgICovCgkgICAgU3lzdGVtLmFycmF5Y29weSA9IGZ1bmN0aW9uIChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7CgkgICAgICAgIC8vIFRPRE86IGJldHRlciB1c2Ugc3BsaXQgb3Igc2V0PwoJICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHsKCSAgICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107CgkgICAgICAgIH0KCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuCgkgICAgICovCgkgICAgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTsKCSAgICB9OwoJICAgIHJldHVybiBTeXN0ZW07Cgl9KCkpOwoJU3lzdGVtJDEuZGVmYXVsdCA9IFN5c3RlbTsKCgl2YXIgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJDEgPSB7fTsKCgl2YXIgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiQxID0ge307CgoJdmFyIF9fZXh0ZW5kcyRoID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKCSAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHwKCSAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9OwoJICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICB9OwoJICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH0KCSAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpOwoJICAgIH07Cgl9KSgpOwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIEV4Y2VwdGlvbl8xJDggPSBFeGNlcHRpb24kMTsKCS8qKgoJICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLgoJICovCgl2YXIgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkaChJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLCBfc3VwZXIpOwoJICAgIGZ1bmN0aW9uIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oKSB7CgkgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpczsKCSAgICB9CgkgICAgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5raW5kID0gJ0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nOwoJICAgIHJldHVybiBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uOwoJfShFeGNlcHRpb25fMSQ4LmRlZmF1bHQpKTsKCUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24kMS5kZWZhdWx0ID0gSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjsKCgl2YXIgX19leHRlbmRzJGcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEgPSBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJDE7CgkvKioKCSAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi4KCSAqLwoJdmFyIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkZyhBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24sIF9zdXBlcik7CgkgICAgZnVuY3Rpb24gQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKGluZGV4LCBtZXNzYWdlKSB7CgkgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gdW5kZWZpbmVkOyB9CgkgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IHVuZGVmaW5lZDsgfQoJICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzOwoJICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4OwoJICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKCSAgICAgICAgcmV0dXJuIF90aGlzOwoJICAgIH0KCSAgICBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ua2luZCA9ICdBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nOwoJICAgIHJldHVybiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb247Cgl9KEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMS5kZWZhdWx0KSk7CglBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24kMS5kZWZhdWx0ID0gQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uOwoKCXZhciBfX3ZhbHVlcyQ3ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7CgkgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7CgkgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7CgkgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSAibnVtYmVyIikgcmV0dXJuIHsKCSAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkgewoJICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDsKCSAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gIk9iamVjdCBpcyBub3QgaXRlcmFibGUuIiA6ICJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuIik7Cgl9OwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5cyQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgU3lzdGVtXzEkNSA9IFN5c3RlbSQxOwoJdmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDkgPSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24kMTsKCXZhciBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMSA9IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiQxOwoJdmFyIEFycmF5cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBBcnJheXMoKSB7CgkgICAgfQoJICAgIC8qKgoJICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXkKCSAgICAgKiBvZiBpbnRzLgoJICAgICAqCgkgICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZAoJICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5CgkgICAgICovCgkgICAgQXJyYXlzLmZpbGwgPSBmdW5jdGlvbiAoYSwgdmFsKSB7CgkgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKQoJICAgICAgICAgICAgYVtpXSA9IHZhbDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQKCSAgICAgKiByYW5nZSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5IG9mIGludHMuICBUaGUgcmFuZ2UgdG8gYmUgZmlsbGVkCgkgICAgICogZXh0ZW5kcyBmcm9tIGluZGV4IHtAY29kZSBmcm9tSW5kZXh9LCBpbmNsdXNpdmUsIHRvIGluZGV4CgkgICAgICoge0Bjb2RlIHRvSW5kZXh9LCBleGNsdXNpdmUuICAoSWYge0Bjb2RlIGZyb21JbmRleD09dG9JbmRleH0sIHRoZQoJICAgICAqIHJhbmdlIHRvIGJlIGZpbGxlZCBpcyBlbXB0eS4pCgkgICAgICoKCSAgICAgKiBAcGFyYW0gYSB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkCgkgICAgICogQHBhcmFtIGZyb21JbmRleCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgKGluY2x1c2l2ZSkgdG8gYmUKCSAgICAgKiAgICAgICAgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZQoJICAgICAqIEBwYXJhbSB0b0luZGV4IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IChleGNsdXNpdmUpIHRvIGJlCgkgICAgICogICAgICAgIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUKCSAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheQoJICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPiB0b0luZGV4fQoJICAgICAqIEB0aHJvd3MgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPCAwfSBvcgoJICAgICAqICAgICAgICAge0Bjb2RlIHRvSW5kZXggPiBhLmxlbmd0aH0KCSAgICAgKi8KCSAgICBBcnJheXMuZmlsbFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBmcm9tSW5kZXgsIHRvSW5kZXgsIHZhbCkgewoJICAgICAgICBBcnJheXMucmFuZ2VDaGVjayhhLmxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KTsKCSAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKykKCSAgICAgICAgICAgIGFbaV0gPSB2YWw7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBDaGVja3MgdGhhdCB7QGNvZGUgZnJvbUluZGV4fSBhbmQge0Bjb2RlIHRvSW5kZXh9IGFyZSBpbgoJICAgICAqIHRoZSByYW5nZSBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGV5IGFyZW4ndC4KCSAgICAgKi8KCSAgICBBcnJheXMucmFuZ2VDaGVjayA9IGZ1bmN0aW9uIChhcnJheUxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KSB7CgkgICAgICAgIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkOS5kZWZhdWx0KCdmcm9tSW5kZXgoJyArIGZyb21JbmRleCArICcpID4gdG9JbmRleCgnICsgdG9JbmRleCArICcpJyk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGZyb21JbmRleCA8IDApIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMS5kZWZhdWx0KGZyb21JbmRleCk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHRvSW5kZXggPiBhcnJheUxlbmd0aCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbl8xLmRlZmF1bHQodG9JbmRleCk7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIEFycmF5cy5hc0xpc3QgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHZhciBhcmdzID0gW107CgkgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7CgkgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGFyZ3M7CgkgICAgfTsKCSAgICBBcnJheXMuY3JlYXRlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHMsIHZhbHVlKSB7CgkgICAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByb3dzIH0pOwoJICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29scyB9KS5maWxsKHZhbHVlKTsgfSk7CgkgICAgfTsKCSAgICBBcnJheXMuY3JlYXRlSW50MzJBcnJheSA9IGZ1bmN0aW9uIChyb3dzLCBjb2xzLCB2YWx1ZSkgewoJICAgICAgICB2YXIgYXJyID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTsKCSAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIEludDMyQXJyYXkuZnJvbSh7IGxlbmd0aDogY29scyB9KS5maWxsKHZhbHVlKTsgfSk7CgkgICAgfTsKCSAgICBBcnJheXMuZXF1YWxzID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsKCSAgICAgICAgaWYgKCFmaXJzdCkgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIGlmICghc2Vjb25kKSB7CgkgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKCFmaXJzdC5sZW5ndGgpIHsKCSAgICAgICAgICAgIHJldHVybiBmYWxzZTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoIXNlY29uZC5sZW5ndGgpIHsKCSAgICAgICAgICAgIHJldHVybiBmYWxzZTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoZmlyc3QubGVuZ3RoICE9PSBzZWNvbmQubGVuZ3RoKSB7CgkgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgIH0KCSAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gZmlyc3QubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykgewoJICAgICAgICAgICAgaWYgKGZpcnN0W2ldICE9PSBzZWNvbmRbaV0pIHsKCSAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRydWU7CgkgICAgfTsKCSAgICBBcnJheXMuaGFzaENvZGUgPSBmdW5jdGlvbiAoYSkgewoJICAgICAgICB2YXIgZV8xLCBfYTsKCSAgICAgICAgaWYgKGEgPT09IG51bGwpIHsKCSAgICAgICAgICAgIHJldHVybiAwOwoJICAgICAgICB9CgkgICAgICAgIHZhciByZXN1bHQgPSAxOwoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgZm9yICh2YXIgYV8xID0gX192YWx1ZXMkNyhhKSwgYV8xXzEgPSBhXzEubmV4dCgpOyAhYV8xXzEuZG9uZTsgYV8xXzEgPSBhXzEubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBhXzFfMS52YWx1ZTsKCSAgICAgICAgICAgICAgICByZXN1bHQgPSAzMSAqIHJlc3VsdCArIGVsZW1lbnQ7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH0KCSAgICAgICAgZmluYWxseSB7CgkgICAgICAgICAgICB0cnkgewoJICAgICAgICAgICAgICAgIGlmIChhXzFfMSAmJiAhYV8xXzEuZG9uZSAmJiAoX2EgPSBhXzEucmV0dXJuKSkgX2EuY2FsbChhXzEpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiByZXN1bHQ7CgkgICAgfTsKCSAgICBBcnJheXMuZmlsbFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoYSwgdmFsdWUpIHsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGEubGVuZ3RoOyBpKyspIHsKCSAgICAgICAgICAgIGFbaV0gPSB2YWx1ZTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgQXJyYXlzLmNvcHlPZiA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7CgkgICAgICAgIHJldHVybiBvcmlnaW5hbC5zbGljZSgwLCBuZXdMZW5ndGgpOwoJICAgIH07CgkgICAgQXJyYXlzLmNvcHlPZlVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAob3JpZ2luYWwsIG5ld0xlbmd0aCkgewoJICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoIDw9IG5ld0xlbmd0aCkgewoJICAgICAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTsKCSAgICAgICAgICAgIG5ld0FycmF5LnNldChvcmlnaW5hbCk7CgkgICAgICAgICAgICByZXR1cm4gbmV3QXJyYXk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnNsaWNlKDAsIG5ld0xlbmd0aCk7CgkgICAgfTsKCSAgICBBcnJheXMuY29weU9mUmFuZ2UgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGZyb20sIHRvKSB7CgkgICAgICAgIHZhciBuZXdMZW5ndGggPSB0byAtIGZyb207CgkgICAgICAgIHZhciBjb3B5ID0gbmV3IEludDMyQXJyYXkobmV3TGVuZ3RoKTsKCSAgICAgICAgU3lzdGVtXzEkNS5kZWZhdWx0LmFycmF5Y29weShvcmlnaW5hbCwgZnJvbSwgY29weSwgMCwgbmV3TGVuZ3RoKTsKCSAgICAgICAgcmV0dXJuIGNvcHk7CgkgICAgfTsKCSAgICAvKgoJICAgICogUmV0dXJucyB0aGUgaW5kZXggb2Ygb2YgdGhlIGVsZW1lbnQgaW4gYSBzb3J0ZWQgYXJyYXkgb3IgKC1uLTEpIHdoZXJlIG4gaXMgdGhlIGluc2VydGlvbiBwb2ludAoJICAgICogZm9yIHRoZSBuZXcgZWxlbWVudC4KCSAgICAqIFBhcmFtZXRlcnM6CgkgICAgKiAgICAgYXIgLSBBIHNvcnRlZCBhcnJheQoJICAgICogICAgIGVsIC0gQW4gZWxlbWVudCB0byBzZWFyY2ggZm9yCgkgICAgKiAgICAgY29tcGFyYXRvciAtIEEgY29tcGFyYXRvciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHRha2VzIHR3byBhcmd1bWVudHM6IChhLCBiKSBhbmQgcmV0dXJuczoKCSAgICAqICAgICAgICBhIG5lZ2F0aXZlIG51bWJlciAgaWYgYSBpcyBsZXNzIHRoYW4gYjsKCSAgICAqICAgICAgICAwIGlmIGEgaXMgZXF1YWwgdG8gYjsKCSAgICAqICAgICAgICBhIHBvc2l0aXZlIG51bWJlciBvZiBhIGlzIGdyZWF0ZXIgdGhhbiBiLgoJICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2F0ZSBlbGVtZW50cy4gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgZXF1YWwgZWxlbWVudHMgaW4gdGhlIGFycmF5LAoJICAgICogdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSB0aGUgaW5kZXggb2YgYW55IG9uZSBvZiB0aGUgZXF1YWwgZWxlbWVudHMuCgkgICAgKgoJICAgICogaHR0cDovL2pzZmlkZGxlLm5ldC9hcnl6aG92L3BrZnN0NTUwLwoJICAgICovCgkgICAgQXJyYXlzLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uIChhciwgZWwsIGNvbXBhcmF0b3IpIHsKCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY29tcGFyYXRvcikgewoJICAgICAgICAgICAgY29tcGFyYXRvciA9IEFycmF5cy5udW1iZXJDb21wYXJhdG9yOwoJICAgICAgICB9CgkgICAgICAgIHZhciBtID0gMDsKCSAgICAgICAgdmFyIG4gPSBhci5sZW5ndGggLSAxOwoJICAgICAgICB3aGlsZSAobSA8PSBuKSB7CgkgICAgICAgICAgICB2YXIgayA9IChuICsgbSkgPj4gMTsKCSAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGVsLCBhcltrXSk7CgkgICAgICAgICAgICBpZiAoY21wID4gMCkgewoJICAgICAgICAgICAgICAgIG0gPSBrICsgMTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHsKCSAgICAgICAgICAgICAgICBuID0gayAtIDE7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICByZXR1cm4gazsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gLW0gLSAxOwoJICAgIH07CgkgICAgQXJyYXlzLm51bWJlckNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikgewoJICAgICAgICByZXR1cm4gYSAtIGI7CgkgICAgfTsKCSAgICByZXR1cm4gQXJyYXlzOwoJfSgpKTsKCUFycmF5cyQxLmRlZmF1bHQgPSBBcnJheXM7CgoJdmFyIEludGVnZXIkMSA9IHt9OwoKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlZ2VyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qKgoJICogUG9ueWZpbGwgZm9yIEphdmEncyBJbnRlZ2VyIGNsYXNzLgoJICovCgl2YXIgSW50ZWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBJbnRlZ2VyKCkgewoJICAgIH0KCSAgICBJbnRlZ2VyLm51bWJlck9mVHJhaWxpbmdaZXJvcyA9IGZ1bmN0aW9uIChpKSB7CgkgICAgICAgIHZhciB5OwoJICAgICAgICBpZiAoaSA9PT0gMCkKCSAgICAgICAgICAgIHJldHVybiAzMjsKCSAgICAgICAgdmFyIG4gPSAzMTsKCSAgICAgICAgeSA9IGkgPDwgMTY7CgkgICAgICAgIGlmICh5ICE9PSAwKSB7CgkgICAgICAgICAgICBuIC09IDE2OwoJICAgICAgICAgICAgaSA9IHk7CgkgICAgICAgIH0KCSAgICAgICAgeSA9IGkgPDwgODsKCSAgICAgICAgaWYgKHkgIT09IDApIHsKCSAgICAgICAgICAgIG4gLT0gODsKCSAgICAgICAgICAgIGkgPSB5OwoJICAgICAgICB9CgkgICAgICAgIHkgPSBpIDw8IDQ7CgkgICAgICAgIGlmICh5ICE9PSAwKSB7CgkgICAgICAgICAgICBuIC09IDQ7CgkgICAgICAgICAgICBpID0geTsKCSAgICAgICAgfQoJICAgICAgICB5ID0gaSA8PCAyOwoJICAgICAgICBpZiAoeSAhPT0gMCkgewoJICAgICAgICAgICAgbiAtPSAyOwoJICAgICAgICAgICAgaSA9IHk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIG4gLSAoKGkgPDwgMSkgPj4+IDMxKTsKCSAgICB9OwoJICAgIEludGVnZXIubnVtYmVyT2ZMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiAoaSkgewoJICAgICAgICAvLyBIRCwgRmlndXJlIDUtNgoJICAgICAgICBpZiAoaSA9PT0gMCkgewoJICAgICAgICAgICAgcmV0dXJuIDMyOwoJICAgICAgICB9CgkgICAgICAgIHZhciBuID0gMTsKCSAgICAgICAgaWYgKGkgPj4+IDE2ID09PSAwKSB7CgkgICAgICAgICAgICBuICs9IDE2OwoJICAgICAgICAgICAgaSA8PD0gMTY7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGkgPj4+IDI0ID09PSAwKSB7CgkgICAgICAgICAgICBuICs9IDg7CgkgICAgICAgICAgICBpIDw8PSA4OwoJICAgICAgICB9CgkgICAgICAgIGlmIChpID4+PiAyOCA9PT0gMCkgewoJICAgICAgICAgICAgbiArPSA0OwoJICAgICAgICAgICAgaSA8PD0gNDsKCSAgICAgICAgfQoJICAgICAgICBpZiAoaSA+Pj4gMzAgPT09IDApIHsKCSAgICAgICAgICAgIG4gKz0gMjsKCSAgICAgICAgICAgIGkgPDw9IDI7CgkgICAgICAgIH0KCSAgICAgICAgbiAtPSBpID4+PiAzMTsKCSAgICAgICAgcmV0dXJuIG47CgkgICAgfTsKCSAgICBJbnRlZ2VyLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKGkpIHsKCSAgICAgICAgcmV0dXJuIGkudG9TdHJpbmcoMTYpOwoJICAgIH07CgkgICAgSW50ZWdlci50b0JpbmFyeVN0cmluZyA9IGZ1bmN0aW9uIChpbnROdW1iZXIpIHsKCSAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJzZUludChTdHJpbmcoaW50TnVtYmVyKSwgMikpOwoJICAgIH07CgkgICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIG9uZS1iaXRzIGluIHRoZSB0d28ncyBjb21wbGVtZW50IGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZS4gVGhpcyBmdW5jdGlvbiBpcyBzb21ldGltZXMgcmVmZXJyZWQgdG8gYXMgdGhlIHBvcHVsYXRpb24gY291bnQuCgkgICAgLy8gUmV0dXJuczoKCSAgICAvLyB0aGUgbnVtYmVyIG9mIG9uZS1iaXRzIGluIHRoZSB0d28ncyBjb21wbGVtZW50IGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZS4KCSAgICBJbnRlZ2VyLmJpdENvdW50ID0gZnVuY3Rpb24gKGkpIHsKCSAgICAgICAgLy8gSEQsIEZpZ3VyZSA1LTIKCSAgICAgICAgaSA9IGkgLSAoKGkgPj4+IDEpICYgMHg1NTU1NTU1NSk7CgkgICAgICAgIGkgPSAoaSAmIDB4MzMzMzMzMzMpICsgKChpID4+PiAyKSAmIDB4MzMzMzMzMzMpOwoJICAgICAgICBpID0gKGkgKyAoaSA+Pj4gNCkpICYgMHgwZjBmMGYwZjsKCSAgICAgICAgaSA9IGkgKyAoaSA+Pj4gOCk7CgkgICAgICAgIGkgPSBpICsgKGkgPj4+IDE2KTsKCSAgICAgICAgcmV0dXJuIGkgJiAweDNmOwoJICAgIH07CgkgICAgSW50ZWdlci50cnVuY0RpdmlzaW9uID0gZnVuY3Rpb24gKGRpdmlkZW5kLCBkaXZpc29yKSB7CgkgICAgICAgIHJldHVybiBNYXRoLnRydW5jKGRpdmlkZW5kIC8gZGl2aXNvcik7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBDb252ZXJ0cyBBIHN0cmluZyB0byBhbiBpbnRlZ2VyLgoJICAgICAqIEBwYXJhbSBzIEEgc3RyaW5nIHRvIGNvbnZlcnQgaW50byBhIG51bWJlci4KCSAgICAgKiBAcGFyYW0gcmFkaXggQSB2YWx1ZSBiZXR3ZWVuIDIgYW5kIDM2IHRoYXQgc3BlY2lmaWVzIHRoZSBiYXNlIG9mIHRoZSBudW1iZXIgaW4gbnVtU3RyaW5nLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzdXBwbGllZCwgc3RyaW5ncyB3aXRoIGEgcHJlZml4IG9mICcweCcgYXJlIGNvbnNpZGVyZWQgaGV4YWRlY2ltYWwuIEFsbCBvdGhlciBzdHJpbmdzIGFyZSBjb25zaWRlcmVkIGRlY2ltYWwuCgkgICAgICovCgkgICAgSW50ZWdlci5wYXJzZUludCA9IGZ1bmN0aW9uIChudW0sIHJhZGl4KSB7CgkgICAgICAgIGlmIChyYWRpeCA9PT0gdm9pZCAwKSB7IHJhZGl4ID0gdW5kZWZpbmVkOyB9CgkgICAgICAgIHJldHVybiBwYXJzZUludChudW0sIHJhZGl4KTsKCSAgICB9OwoJICAgIEludGVnZXIuTUlOX1ZBTFVFXzMyX0JJVFMgPSAtMjE0NzQ4MzY0ODsKCSAgICBJbnRlZ2VyLk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOwoJICAgIHJldHVybiBJbnRlZ2VyOwoJfSgpKTsKCUludGVnZXIkMS5kZWZhdWx0ID0gSW50ZWdlcjsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpdEFycmF5JDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJLyppbXBvcnQgamF2YS51dGlsLkFycmF5czsqLwoJdmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDggPSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24kMTsKCXZhciBBcnJheXNfMSQxID0gQXJyYXlzJDE7Cgl2YXIgSW50ZWdlcl8xJDIgPSBJbnRlZ2VyJDE7Cgl2YXIgU3lzdGVtXzEkNCA9IFN5c3RlbSQxOwoJLyoqCgkgKiA8cD5BIHNpbXBsZSwgZmFzdCBhcnJheSBvZiBiaXRzLCByZXByZXNlbnRlZCBjb21wYWN0bHkgYnkgYW4gYXJyYXkgb2YgaW50cyBpbnRlcm5hbGx5LjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgQml0QXJyYXkgLyppbXBsZW1lbnRzIENsb25lYWJsZSovID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHsKCSAgICAvLyAgIHRoaXMuc2l6ZSA9IDAKCSAgICAvLyAgIHRoaXMuYml0cyA9IG5ldyBJbnQzMkFycmF5KDEpCgkgICAgLy8gfQoJICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihzaXplPzogbnVtYmVyIC8qaW50Ki8pIHsKCSAgICAvLyAgIGlmICh1bmRlZmluZWQgPT09IHNpemUpIHsKCSAgICAvLyAgICAgdGhpcy5zaXplID0gMAoJICAgIC8vICAgfSBlbHNlIHsKCSAgICAvLyAgICAgdGhpcy5zaXplID0gc2l6ZQoJICAgIC8vICAgfQoJICAgIC8vICAgdGhpcy5iaXRzID0gdGhpcy5tYWtlQXJyYXkoc2l6ZSkKCSAgICAvLyB9CgkgICAgLy8gRm9yIHRlc3Rpbmcgb25seQoJICAgIGZ1bmN0aW9uIEJpdEFycmF5KHNpemUgLyppbnQqLywgYml0cykgewoJICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzaXplKSB7CgkgICAgICAgICAgICB0aGlzLnNpemUgPSAwOwoJICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3IEludDMyQXJyYXkoMSk7CgkgICAgICAgIH0KCSAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICB0aGlzLnNpemUgPSBzaXplOwoJICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7CgkgICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gQml0QXJyYXkubWFrZUFycmF5KHNpemUpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0czsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgIH0KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTsKCSAgICB9OwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXRTaXplSW5CeXRlcyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuc2l6ZSArIDcpIC8gOCk7CgkgICAgfTsKCSAgICBCaXRBcnJheS5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSAvKmludCovKSB7CgkgICAgICAgIGlmIChzaXplID4gdGhpcy5iaXRzLmxlbmd0aCAqIDMyKSB7CgkgICAgICAgICAgICB2YXIgbmV3Qml0cyA9IEJpdEFycmF5Lm1ha2VBcnJheShzaXplKTsKCSAgICAgICAgICAgIFN5c3RlbV8xJDQuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5iaXRzLCAwLCBuZXdCaXRzLCAwLCB0aGlzLmJpdHMubGVuZ3RoKTsKCSAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBpIGJpdCB0byBnZXQKCSAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGJpdCBpIGlzIHNldAoJICAgICAqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSAvKmludCovKSB7CgkgICAgICAgIHJldHVybiAodGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gJiAoMSA8PCAoaSAmIDB4MUYpKSkgIT09IDA7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBTZXRzIGJpdCBpLgoJICAgICAqCgkgICAgICogQHBhcmFtIGkgYml0IHRvIHNldAoJICAgICAqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaSAvKmludCovKSB7CgkgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIHw9IDEgPDwgKGkgJiAweDFGKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEZsaXBzIGJpdCBpLgoJICAgICAqCgkgICAgICogQHBhcmFtIGkgYml0IHRvIHNldAoJICAgICAqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gKGkgLyppbnQqLykgewoJICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSBePSAxIDw8IChpICYgMHgxRik7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gZnJvbSBmaXJzdCBiaXQgdG8gY2hlY2sKCSAgICAgKiBAcmV0dXJuIGluZGV4IG9mIGZpcnN0IGJpdCB0aGF0IGlzIHNldCwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gaW5kZXgsIG9yIHNpemUgaWYgbm9uZSBhcmUgc2V0CgkgICAgICogIGF0IG9yIGJleW9uZCB0aGlzIGdpdmVuIGluZGV4CgkgICAgICogQHNlZSAjZ2V0TmV4dFVuc2V0KGludCkKCSAgICAgKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuZ2V0TmV4dFNldCA9IGZ1bmN0aW9uIChmcm9tIC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7CgkgICAgICAgIGlmIChmcm9tID49IHNpemUpIHsKCSAgICAgICAgICAgIHJldHVybiBzaXplOwoJICAgICAgICB9CgkgICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzOwoJICAgICAgICB2YXIgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTsKCSAgICAgICAgdmFyIGN1cnJlbnRCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTsKCSAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3QKCSAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpOwoJICAgICAgICB2YXIgbGVuZ3RoID0gYml0cy5sZW5ndGg7CgkgICAgICAgIHdoaWxlIChjdXJyZW50Qml0cyA9PT0gMCkgewoJICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7CgkgICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHJlc3VsdCA9IChiaXRzT2Zmc2V0ICogMzIpICsgSW50ZWdlcl8xJDIuZGVmYXVsdC5udW1iZXJPZlRyYWlsaW5nWmVyb3MoY3VycmVudEJpdHMpOwoJICAgICAgICByZXR1cm4gcmVzdWx0ID4gc2l6ZSA/IHNpemUgOiByZXN1bHQ7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gZnJvbSBpbmRleCB0byBzdGFydCBsb29raW5nIGZvciB1bnNldCBiaXQKCSAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgdW5zZXQgYml0LCBvciB7QGNvZGUgc2l6ZX0gaWYgbm9uZSBhcmUgdW5zZXQgdW50aWwgdGhlIGVuZAoJICAgICAqIEBzZWUgI2dldE5leHRTZXQoaW50KQoJICAgICAqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXROZXh0VW5zZXQgPSBmdW5jdGlvbiAoZnJvbSAvKmludCovKSB7CgkgICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplOwoJICAgICAgICBpZiAoZnJvbSA+PSBzaXplKSB7CgkgICAgICAgICAgICByZXR1cm4gc2l6ZTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0czsKCSAgICAgICAgdmFyIGJpdHNPZmZzZXQgPSBNYXRoLmZsb29yKGZyb20gLyAzMik7CgkgICAgICAgIHZhciBjdXJyZW50Qml0cyA9IH5iaXRzW2JpdHNPZmZzZXRdOwoJICAgICAgICAvLyBtYXNrIG9mZiBsZXNzZXIgYml0cyBmaXJzdAoJICAgICAgICBjdXJyZW50Qml0cyAmPSB+KCgxIDw8IChmcm9tICYgMHgxRikpIC0gMSk7CgkgICAgICAgIHZhciBsZW5ndGggPSBiaXRzLmxlbmd0aDsKCSAgICAgICAgd2hpbGUgKGN1cnJlbnRCaXRzID09PSAwKSB7CgkgICAgICAgICAgICBpZiAoKytiaXRzT2Zmc2V0ID09PSBsZW5ndGgpIHsKCSAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHJlc3VsdCA9IChiaXRzT2Zmc2V0ICogMzIpICsgSW50ZWdlcl8xJDIuZGVmYXVsdC5udW1iZXJPZlRyYWlsaW5nWmVyb3MoY3VycmVudEJpdHMpOwoJICAgICAgICByZXR1cm4gcmVzdWx0ID4gc2l6ZSA/IHNpemUgOiByZXN1bHQ7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBTZXRzIGEgYmxvY2sgb2YgMzIgYml0cywgc3RhcnRpbmcgYXQgYml0IGkuCgkgICAgICoKCSAgICAgKiBAcGFyYW0gaSBmaXJzdCBiaXQgdG8gc2V0CgkgICAgICogQHBhcmFtIG5ld0JpdHMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgbmV4dCAzMiBiaXRzLiBOb3RlIGFnYWluIHRoYXQgdGhlIGxlYXN0LXNpZ25pZmljYW50IGJpdAoJICAgICAqIGNvcnJlc3BvbmRzIHRvIGJpdCBpLCB0aGUgbmV4dC1sZWFzdC1zaWduaWZpY2FudCB0byBpKzEsIGFuZCBzbyBvbi4KCSAgICAgKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuc2V0QnVsayA9IGZ1bmN0aW9uIChpIC8qaW50Ki8sIG5ld0JpdHMgLyppbnQqLykgewoJICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSA9IG5ld0JpdHM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBTZXRzIGEgcmFuZ2Ugb2YgYml0cy4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBvZiByYW5nZSwgaW5jbHVzaXZlLgoJICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmUKCSAgICAgKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQgLyppbnQqLywgZW5kIC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ4LmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoZW5kID09PSBzdGFydCkgewoJICAgICAgICAgICAgcmV0dXJuOwoJICAgICAgICB9CgkgICAgICAgIGVuZC0tOyAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlCgkgICAgICAgIHZhciBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7CgkgICAgICAgIHZhciBsYXN0SW50ID0gTWF0aC5mbG9vcihlbmQgLyAzMik7CgkgICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzOwoJICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RJbnQ7IGkgPD0gbGFzdEludDsgaSsrKSB7CgkgICAgICAgICAgICB2YXIgZmlyc3RCaXQgPSBpID4gZmlyc3RJbnQgPyAwIDogc3RhcnQgJiAweDFGOwoJICAgICAgICAgICAgdmFyIGxhc3RCaXQgPSBpIDwgbGFzdEludCA/IDMxIDogZW5kICYgMHgxRjsKCSAgICAgICAgICAgIC8vIE9uZXMgZnJvbSBmaXJzdEJpdCB0byBsYXN0Qml0LCBpbmNsdXNpdmUKCSAgICAgICAgICAgIHZhciBtYXNrID0gKDIgPDwgbGFzdEJpdCkgLSAoMSA8PCBmaXJzdEJpdCk7CgkgICAgICAgICAgICBiaXRzW2ldIHw9IG1hc2s7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIC8qKgoJICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuCgkgICAgICovCgkgICAgQml0QXJyYXkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgbWF4ID0gdGhpcy5iaXRzLmxlbmd0aDsKCSAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpKyspIHsKCSAgICAgICAgICAgIGJpdHNbaV0gPSAwOwoJICAgICAgICB9CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBFZmZpY2llbnQgbWV0aG9kIHRvIGNoZWNrIGlmIGEgcmFuZ2Ugb2YgYml0cyBpcyBzZXQsIG9yIG5vdCBzZXQuCgkgICAgICoKCSAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgb2YgcmFuZ2UsIGluY2x1c2l2ZS4KCSAgICAgKiBAcGFyYW0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlCgkgICAgICogQHBhcmFtIHZhbHVlIGlmIHRydWUsIGNoZWNrcyB0aGF0IGJpdHMgaW4gcmFuZ2UgYXJlIHNldCwgb3RoZXJ3aXNlIGNoZWNrcyB0aGF0IHRoZXkgYXJlIG5vdCBzZXQKCSAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGFsbCBiaXRzIGFyZSBzZXQgb3Igbm90IHNldCBpbiByYW5nZSwgYWNjb3JkaW5nIHRvIHZhbHVlIGFyZ3VtZW50CgkgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydCBvciB0aGUgcmFuZ2UgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgYXJyYXkKCSAgICAgKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuaXNSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCAvKmludCovLCBlbmQgLyppbnQqLywgdmFsdWUpIHsKCSAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ4LmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoZW5kID09PSBzdGFydCkgewoJICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHJhbmdlIG1hdGNoZXMKCSAgICAgICAgfQoJICAgICAgICBlbmQtLTsgLy8gd2lsbCBiZSBlYXNpZXIgdG8gdHJlYXQgdGhpcyBhcyB0aGUgbGFzdCBhY3R1YWxseSBzZXQgYml0IC0tIGluY2x1c2l2ZQoJICAgICAgICB2YXIgZmlyc3RJbnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gMzIpOwoJICAgICAgICB2YXIgbGFzdEludCA9IE1hdGguZmxvb3IoZW5kIC8gMzIpOwoJICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0czsKCSAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0SW50OyBpIDw9IGxhc3RJbnQ7IGkrKykgewoJICAgICAgICAgICAgdmFyIGZpcnN0Qml0ID0gaSA+IGZpcnN0SW50ID8gMCA6IHN0YXJ0ICYgMHgxRjsKCSAgICAgICAgICAgIHZhciBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7CgkgICAgICAgICAgICAvLyBPbmVzIGZyb20gZmlyc3RCaXQgdG8gbGFzdEJpdCwgaW5jbHVzaXZlCgkgICAgICAgICAgICB2YXIgbWFzayA9ICgyIDw8IGxhc3RCaXQpIC0gKDEgPDwgZmlyc3RCaXQpICYgMHhGRkZGRkZGRjsKCSAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiAmIDB4RkZGRkZGRkYgYWRkZWQgdG8gZGlzY2FyZCBhbnl0aGluZyBhZnRlciAzMiBiaXRzLCBhcyBFUyBoYXMgNTMgYml0cwoJICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGlmIHdlJ3JlIGxvb2tpbmcgZm9yIDFzIGFuZCB0aGUgbWFza2VkIGJpdHNbaV0gaXNuJ3QgYWxsIDFzIChpczogdGhhdCwKCSAgICAgICAgICAgIC8vIGVxdWFscyB0aGUgbWFzaywgb3Igd2UncmUgbG9va2luZyBmb3IgMHMgYW5kIHRoZSBtYXNrZWQgcG9ydGlvbiBpcyBub3QgYWxsIDBzCgkgICAgICAgICAgICBpZiAoKGJpdHNbaV0gJiBtYXNrKSAhPT0gKHZhbHVlID8gbWFzayA6IDApKSB7CgkgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiB0cnVlOwoJICAgIH07CgkgICAgQml0QXJyYXkucHJvdG90eXBlLmFwcGVuZEJpdCA9IGZ1bmN0aW9uIChiaXQpIHsKCSAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLnNpemUgKyAxKTsKCSAgICAgICAgaWYgKGJpdCkgewoJICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IodGhpcy5zaXplIC8gMzIpXSB8PSAxIDw8ICh0aGlzLnNpemUgJiAweDFGKTsKCSAgICAgICAgfQoJICAgICAgICB0aGlzLnNpemUrKzsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEFwcGVuZHMgdGhlIGxlYXN0LXNpZ25pZmljYW50IGJpdHMsIGZyb20gdmFsdWUsIGluIG9yZGVyIGZyb20gbW9zdC1zaWduaWZpY2FudCB0bwoJICAgICAqIGxlYXN0LXNpZ25pZmljYW50LiBGb3IgZXhhbXBsZSwgYXBwZW5kaW5nIDYgYml0cyBmcm9tIDB4MDAwMDAxRSB3aWxsIGFwcGVuZCB0aGUgYml0cwoJICAgICAqIDAsIDEsIDEsIDEsIDEsIDAgaW4gdGhhdCBvcmRlci4KCSAgICAgKgoJICAgICAqIEBwYXJhbSB2YWx1ZSB7QGNvZGUgaW50fSBjb250YWluaW5nIGJpdHMgdG8gYXBwZW5kCgkgICAgICogQHBhcmFtIG51bUJpdHMgYml0cyBmcm9tIHZhbHVlIHRvIGFwcGVuZAoJICAgICAqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5hcHBlbmRCaXRzID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8sIG51bUJpdHMgLyppbnQqLykgewoJICAgICAgICBpZiAobnVtQml0cyA8IDAgfHwgbnVtQml0cyA+IDMyKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkOC5kZWZhdWx0KCdOdW0gYml0cyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMzInKTsKCSAgICAgICAgfQoJICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIG51bUJpdHMpOwoJICAgICAgICAvLyBjb25zdCBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDsKCSAgICAgICAgZm9yICh2YXIgbnVtQml0c0xlZnQgPSBudW1CaXRzOyBudW1CaXRzTGVmdCA+IDA7IG51bUJpdHNMZWZ0LS0pIHsKCSAgICAgICAgICAgIHRoaXMuYXBwZW5kQml0KCgodmFsdWUgPj4gKG51bUJpdHNMZWZ0IC0gMSkpICYgMHgwMSkgPT09IDEpOwoJICAgICAgICB9CgkgICAgfTsKCSAgICBCaXRBcnJheS5wcm90b3R5cGUuYXBwZW5kQml0QXJyYXkgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgICAgICAgdmFyIG90aGVyU2l6ZSA9IG90aGVyLnNpemU7CgkgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5zaXplICsgb3RoZXJTaXplKTsKCSAgICAgICAgLy8gY29uc3QgYXBwZW5kQml0ID0gdGhpcy5hcHBlbmRCaXQ7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJTaXplOyBpKyspIHsKCSAgICAgICAgICAgIHRoaXMuYXBwZW5kQml0KG90aGVyLmdldChpKSk7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDguZGVmYXVsdCgnU2l6ZXMgZG9uXCd0IG1hdGNoJyk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7CgkgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGJpdHMubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykgewoJICAgICAgICAgICAgLy8gVGhlIGxhc3QgaW50IGNvdWxkIGJlIGluY29tcGxldGUgKGkuZS4gbm90IGhhdmUgMzIgYml0cyBpbgoJICAgICAgICAgICAgLy8gaXQpIGJ1dCB0aGVyZSBpcyBubyBwcm9ibGVtIHNpbmNlIDAgWE9SIDAgPT0gMC4KCSAgICAgICAgICAgIGJpdHNbaV0gXj0gb3RoZXIuYml0c1tpXTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgLyoqCgkgICAgICoKCSAgICAgKiBAcGFyYW0gYml0T2Zmc2V0IGZpcnN0IGJpdCB0byBzdGFydCB3cml0aW5nCgkgICAgICogQHBhcmFtIGFycmF5IGFycmF5IHRvIHdyaXRlIGludG8uIEJ5dGVzIGFyZSB3cml0dGVuIG1vc3Qtc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdC4gVGhpcyBpcyB0aGUgb3Bwb3NpdGUKCSAgICAgKiAgb2YgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLCB3aGljaCBpcyBleHBvc2VkIGJ5IHtAbGluayAjZ2V0Qml0QXJyYXkoKX0KCSAgICAgKiBAcGFyYW0gb2Zmc2V0IHBvc2l0aW9uIGluIGFycmF5IHRvIHN0YXJ0IHdyaXRpbmcKCSAgICAgKiBAcGFyYW0gbnVtQnl0ZXMgaG93IG1hbnkgYnl0ZXMgdG8gd3JpdGUKCSAgICAgKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIChiaXRPZmZzZXQgLyppbnQqLywgYXJyYXksIG9mZnNldCAvKmludCovLCBudW1CeXRlcyAvKmludCovKSB7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQnl0ZXM7IGkrKykgewoJICAgICAgICAgICAgdmFyIHRoZUJ5dGUgPSAwOwoJICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHsKCSAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoYml0T2Zmc2V0KSkgewoJICAgICAgICAgICAgICAgICAgICB0aGVCeXRlIHw9IDEgPDwgKDcgLSBqKTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgYml0T2Zmc2V0Kys7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBpXSA9IC8qKGJ5dGUpKi8gdGhlQnl0ZTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiB1bmRlcmx5aW5nIGFycmF5IG9mIGludHMuIFRoZSBmaXJzdCBlbGVtZW50IGhvbGRzIHRoZSBmaXJzdCAzMiBiaXRzLCBhbmQgdGhlIGxlYXN0CgkgICAgICogICAgICAgICBzaWduaWZpY2FudCBiaXQgaXMgYml0IDAuCgkgICAgICovCgkgICAgQml0QXJyYXkucHJvdG90eXBlLmdldEJpdEFycmF5ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5iaXRzOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogUmV2ZXJzZXMgYWxsIGJpdHMgaW4gdGhlIGFycmF5LgoJICAgICAqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgbmV3Qml0cyA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYml0cy5sZW5ndGgpOwoJICAgICAgICAvLyByZXZlcnNlIGFsbCBpbnQncyBmaXJzdAoJICAgICAgICB2YXIgbGVuID0gTWF0aC5mbG9vcigodGhpcy5zaXplIC0gMSkgLyAzMik7CgkgICAgICAgIHZhciBvbGRCaXRzTGVuID0gbGVuICsgMTsKCSAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7CgkgICAgICAgICAgICB2YXIgeCA9IGJpdHNbaV07CgkgICAgICAgICAgICB4ID0gKCh4ID4+IDEpICYgMHg1NTU1NTU1NSkgfCAoKHggJiAweDU1NTU1NTU1KSA8PCAxKTsKCSAgICAgICAgICAgIHggPSAoKHggPj4gMikgJiAweDMzMzMzMzMzKSB8ICgoeCAmIDB4MzMzMzMzMzMpIDw8IDIpOwoJICAgICAgICAgICAgeCA9ICgoeCA+PiA0KSAmIDB4MGYwZjBmMGYpIHwgKCh4ICYgMHgwZjBmMGYwZikgPDwgNCk7CgkgICAgICAgICAgICB4ID0gKCh4ID4+IDgpICYgMHgwMGZmMDBmZikgfCAoKHggJiAweDAwZmYwMGZmKSA8PCA4KTsKCSAgICAgICAgICAgIHggPSAoKHggPj4gMTYpICYgMHgwMDAwZmZmZikgfCAoKHggJiAweDAwMDBmZmZmKSA8PCAxNik7CgkgICAgICAgICAgICBuZXdCaXRzW2xlbiAtIGldID0gLyooaW50KSovIHg7CgkgICAgICAgIH0KCSAgICAgICAgLy8gbm93IGNvcnJlY3QgdGhlIGludCdzIGlmIHRoZSBiaXQgc2l6ZSBpc24ndCBhIG11bHRpcGxlIG9mIDMyCgkgICAgICAgIGlmICh0aGlzLnNpemUgIT09IG9sZEJpdHNMZW4gKiAzMikgewoJICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSBvbGRCaXRzTGVuICogMzIgLSB0aGlzLnNpemU7CgkgICAgICAgICAgICB2YXIgY3VycmVudEludCA9IG5ld0JpdHNbMF0gPj4+IGxlZnRPZmZzZXQ7CgkgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9sZEJpdHNMZW47IGkrKykgewoJICAgICAgICAgICAgICAgIHZhciBuZXh0SW50ID0gbmV3Qml0c1tpXTsKCSAgICAgICAgICAgICAgICBjdXJyZW50SW50IHw9IG5leHRJbnQgPDwgKDMyIC0gbGVmdE9mZnNldCk7CgkgICAgICAgICAgICAgICAgbmV3Qml0c1tpIC0gMV0gPSBjdXJyZW50SW50OwoJICAgICAgICAgICAgICAgIGN1cnJlbnRJbnQgPSBuZXh0SW50ID4+PiBsZWZ0T2Zmc2V0OwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgbmV3Qml0c1tvbGRCaXRzTGVuIC0gMV0gPSBjdXJyZW50SW50OwoJICAgICAgICB9CgkgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7CgkgICAgfTsKCSAgICBCaXRBcnJheS5tYWtlQXJyYXkgPSBmdW5jdGlvbiAoc2l6ZSAvKmludCovKSB7CgkgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShNYXRoLmZsb29yKChzaXplICsgMzEpIC8gMzIpKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHsKCSAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEJpdEFycmF5KSkgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIHZhciBvdGhlciA9IG87CgkgICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IG90aGVyLnNpemUgJiYgQXJyYXlzXzEkMS5kZWZhdWx0LmVxdWFscyh0aGlzLmJpdHMsIG90aGVyLmJpdHMpOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEJpdEFycmF5LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIDMxICogdGhpcy5zaXplICsgQXJyYXlzXzEkMS5kZWZhdWx0Lmhhc2hDb2RlKHRoaXMuYml0cyk7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgQml0QXJyYXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgcmVzdWx0ID0gJyc7CgkgICAgICAgIGZvciAodmFyIGkgPSAwLCBzaXplID0gdGhpcy5zaXplOyBpIDwgc2l6ZTsgaSsrKSB7CgkgICAgICAgICAgICBpZiAoKGkgJiAweDA3KSA9PT0gMCkgewoJICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXQoaSkgPyAnWCcgOiAnLic7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHJlc3VsdDsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBCaXRBcnJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiBuZXcgQml0QXJyYXkodGhpcy5zaXplLCB0aGlzLmJpdHMuc2xpY2UoKSk7CgkgICAgfTsKCSAgICByZXR1cm4gQml0QXJyYXk7Cgl9KCkpOwoJQml0QXJyYXkkMS5kZWZhdWx0ID0gQml0QXJyYXk7CgoJdmFyIEJpdE1hdHJpeCQxID0ge307CgoJdmFyIFN0cmluZ0J1aWxkZXIkMSA9IHt9OwoKCXZhciBTdHJpbmdVdGlscyQxID0ge307CgoJdmFyIERlY29kZUhpbnRUeXBlJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KERlY29kZUhpbnRUeXBlJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovCgkvKioKCSAqIEVuY2Fwc3VsYXRlcyBhIHR5cGUgb2YgaGludCB0aGF0IGEgY2FsbGVyIG1heSBwYXNzIHRvIGEgYmFyY29kZSByZWFkZXIgdG8gaGVscCBpdAoJICogbW9yZSBxdWlja2x5IG9yIGFjY3VyYXRlbHkgZGVjb2RlIGl0LiBJdCBpcyB1cCB0byBpbXBsZW1lbnRhdGlvbnMgdG8gZGVjaWRlIHdoYXQsCgkgKiBpZiBhbnl0aGluZywgdG8gZG8gd2l0aCB0aGUgaW5mb3JtYXRpb24gdGhhdCBpcyBzdXBwbGllZC4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikKCSAqIEBzZWUgUmVhZGVyI2RlY29kZShCaW5hcnlCaXRtYXAsamF2YS51dGlsLk1hcCkKCSAqLwoJdmFyIERlY29kZUhpbnRUeXBlOwoJKGZ1bmN0aW9uIChEZWNvZGVIaW50VHlwZSkgewoJICAgIC8qKgoJICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoaW50LiBNYXBzIHRvIGFuIHVuc3BlY2lmaWVkIHtAbGluayBPYmplY3R9LgoJICAgICAqLwoJICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlWyJPVEhFUiJdID0gMF0gPSAiT1RIRVIiOyAvKihPYmplY3QuY2xhc3MpKi8KCSAgICAvKioKCSAgICAgKiBJbWFnZSBpcyBhIHB1cmUgbW9ub2Nocm9tZSBpbWFnZSBvZiBhIGJhcmNvZGUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsKCSAgICAgKiB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uCgkgICAgICovCgkgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbIlBVUkVfQkFSQ09ERSJdID0gMV0gPSAiUFVSRV9CQVJDT0RFIjsgLyooVm9pZC5jbGFzcykqLwoJICAgIC8qKgoJICAgICAqIEltYWdlIGlzIGtub3duIHRvIGJlIG9mIG9uZSBvZiBhIGZldyBwb3NzaWJsZSBmb3JtYXRzLgoJICAgICAqIE1hcHMgdG8gYSB7QGxpbmsgTGlzdH0gb2Yge0BsaW5rIEJhcmNvZGVGb3JtYXR9cy4KCSAgICAgKi8KCSAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVsiUE9TU0lCTEVfRk9STUFUUyJdID0gMl0gPSAiUE9TU0lCTEVfRk9STUFUUyI7IC8qKExpc3QuY2xhc3MpKi8KCSAgICAvKioKCSAgICAgKiBTcGVuZCBtb3JlIHRpbWUgdG8gdHJ5IHRvIGZpbmQgYSBiYXJjb2RlOyBvcHRpbWl6ZSBmb3IgYWNjdXJhY3ksIG5vdCBzcGVlZC4KCSAgICAgKiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87IHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS4KCSAgICAgKi8KCSAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVsiVFJZX0hBUkRFUiJdID0gM10gPSAiVFJZX0hBUkRFUiI7IC8qKFZvaWQuY2xhc3MpKi8KCSAgICAvKioKCSAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZW4gZGVjb2RpbmcsIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUgU3RyaW5nKQoJICAgICAqLwoJICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlWyJDSEFSQUNURVJfU0VUIl0gPSA0XSA9ICJDSEFSQUNURVJfU0VUIjsgLyooU3RyaW5nLmNsYXNzKSovCgkgICAgLyoqCgkgICAgICogQWxsb3dlZCBsZW5ndGhzIG9mIGVuY29kZWQgZGF0YSAtLSByZWplY3QgYW55dGhpbmcgZWxzZS4gTWFwcyB0byBhbiB7QGNvZGUgSW50MzJBcnJheX0uCgkgICAgICovCgkgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbIkFMTE9XRURfTEVOR1RIUyJdID0gNV0gPSAiQUxMT1dFRF9MRU5HVEhTIjsgLyooSW50MzJBcnJheS5jbGFzcykqLwoJICAgIC8qKgoJICAgICAqIEFzc3VtZSBDb2RlIDM5IGNvZGVzIGVtcGxveSBhIGNoZWNrIGRpZ2l0LiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87CgkgICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LgoJICAgICAqLwoJICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlWyJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVCJdID0gNl0gPSAiQVNTVU1FX0NPREVfMzlfQ0hFQ0tfRElHSVQiOyAvKihWb2lkLmNsYXNzKSovCgkgICAgLyoqCgkgICAgICogQXNzdW1lIHRoZSBiYXJjb2RlIGlzIGJlaW5nIHByb2Nlc3NlZCBhcyBhIEdTMSBiYXJjb2RlLCBhbmQgbW9kaWZ5IGJlaGF2aW9yIGFzIG5lZWRlZC4KCSAgICAgKiBGb3IgZXhhbXBsZSB0aGlzIGFmZmVjdHMgRk5DMSBoYW5kbGluZyBmb3IgQ29kZSAxMjggKGFrYSBHUzEtMTI4KS4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvOwoJICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS4KCSAgICAgKi8KCSAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVsiQVNTVU1FX0dTMSJdID0gN10gPSAiQVNTVU1FX0dTMSI7IC8qKFZvaWQuY2xhc3MpKi8KCSAgICAvKioKCSAgICAgKiBJZiB0cnVlLCByZXR1cm4gdGhlIHN0YXJ0IGFuZCBlbmQgZGlnaXRzIGluIGEgQ29kYWJhciBiYXJjb2RlIGluc3RlYWQgb2Ygc3RyaXBwaW5nIHRoZW0uIFRoZXkKCSAgICAgKiBhcmUgYWxwaGEsIHdoZXJlYXMgdGhlIHJlc3QgYXJlIG51bWVyaWMuIEJ5IGRlZmF1bHQsIHRoZXkgYXJlIHN0cmlwcGVkLCBidXQgdGhpcyBjYXVzZXMgdGhlbQoJICAgICAqIHRvIG5vdCBiZS4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvOyB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uCgkgICAgICovCgkgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbIlJFVFVSTl9DT0RBQkFSX1NUQVJUX0VORCJdID0gOF0gPSAiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EIjsgLyooVm9pZC5jbGFzcykqLwoJICAgIC8qKgoJICAgICAqIFRoZSBjYWxsZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQgdmlhIGNhbGxiYWNrIHdoZW4gYSBwb3NzaWJsZSB7QGxpbmsgUmVzdWx0UG9pbnR9CgkgICAgICogaXMgZm91bmQuIE1hcHMgdG8gYSB7QGxpbmsgUmVzdWx0UG9pbnRDYWxsYmFja30uCgkgICAgICovCgkgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbIk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLIl0gPSA5XSA9ICJORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyI7IC8qKFJlc3VsdFBvaW50Q2FsbGJhY2suY2xhc3MpKi8KCSAgICAvKioKCSAgICAgKiBBbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzIGZvciBFQU4gb3IgVVBDIGJhcmNvZGVzLiBPdGhlciBmb3JtYXRzIHdpbGwgaWdub3JlIHRoaXMuCgkgICAgICogTWFwcyB0byBhbiB7QGNvZGUgSW50MzJBcnJheX0gb2YgdGhlIGFsbG93ZWQgZXh0ZW5zaW9uIGxlbmd0aHMsIGZvciBleGFtcGxlIFsyXSwgWzVdLCBvciBbMiwgNV0uCgkgICAgICogSWYgaXQgaXMgb3B0aW9uYWwgdG8gaGF2ZSBhbiBleHRlbnNpb24sIGRvIG5vdCBzZXQgdGhpcyBoaW50LiBJZiB0aGlzIGlzIHNldCwKCSAgICAgKiBhbmQgYSBVUEMgb3IgRUFOIGJhcmNvZGUgaXMgZm91bmQgYnV0IGFuIGV4dGVuc2lvbiBpcyBub3QsIHRoZW4gbm8gcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQKCSAgICAgKiBhdCBhbGwuCgkgICAgICovCgkgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbIkFMTE9XRURfRUFOX0VYVEVOU0lPTlMiXSA9IDEwXSA9ICJBTExPV0VEX0VBTl9FWFRFTlNJT05TIjsgLyooSW50MzJBcnJheS5jbGFzcykqLwoJICAgIC8vIEVuZCBvZiBlbnVtZXJhdGlvbiB2YWx1ZXMuCgkgICAgLyoqCgkgICAgICogRGF0YSB0eXBlIHRoZSBoaW50IGlzIGV4cGVjdGluZy4KCSAgICAgKiBBbW9uZyB0aGUgcG9zc2libGUgdmFsdWVzIHRoZSB7QGxpbmsgVm9pZH0gc3RhbmRzIG91dCBhcyBiZWluZyB1c2VkIGZvcgoJICAgICAqIGhpbnRzIHRoYXQgZG8gbm90IGV4cGVjdCBhIHZhbHVlIHRvIGJlIHN1cHBsaWVkIChmbGFnIGhpbnRzKS4gU3VjaCBoaW50cwoJICAgICAqIHdpbGwgcG9zc2libHkgaGF2ZSB0aGVpciB2YWx1ZSBpZ25vcmVkLCBvciByZXBsYWNlZCBieSBhCgkgICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0uIEhpbnQgc3VwcGxpZXJzIHNob3VsZCBwcm9iYWJseSB1c2UKCSAgICAgKiB7QGxpbmsgQm9vbGVhbiNUUlVFfSBhcyBkaXJlY3RlZCBieSB0aGUgYWN0dWFsIGhpbnQgZG9jdW1lbnRhdGlvbi4KCSAgICAgKi8KCSAgICAvLyBwcml2YXRlIHZhbHVlVHlwZTogQ2xhc3M8Pz4KCSAgICAvLyBEZWNvZGVIaW50VHlwZSh2YWx1ZVR5cGU6IENsYXNzPD8+KSB7CgkgICAgLy8gICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZQoJICAgIC8vIH0KCSAgICAvLyBwdWJsaWMgZ2V0VmFsdWVUeXBlKCk6IENsYXNzPD8+IHsKCSAgICAvLyAgIHJldHVybiB2YWx1ZVR5cGUKCSAgICAvLyB9Cgl9KShEZWNvZGVIaW50VHlwZSB8fCAoRGVjb2RlSGludFR5cGUgPSB7fSkpOwoJRGVjb2RlSGludFR5cGUkMS5kZWZhdWx0ID0gRGVjb2RlSGludFR5cGU7CgoJdmFyIENoYXJhY3RlclNldEVDSSA9IHt9OwoKCXZhciBGb3JtYXRFeGNlcHRpb24kMSA9IHt9OwoKCXZhciBfX2V4dGVuZHMkZiA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtYXRFeGNlcHRpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIEV4Y2VwdGlvbl8xJDcgPSBFeGNlcHRpb24kMTsKCS8qKgoJICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLgoJICovCgl2YXIgRm9ybWF0RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikgewoJICAgIF9fZXh0ZW5kcyRmKEZvcm1hdEV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBGb3JtYXRFeGNlcHRpb24oKSB7CgkgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpczsKCSAgICB9CgkgICAgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEV4Y2VwdGlvbigpOwoJICAgIH07CgkgICAgRm9ybWF0RXhjZXB0aW9uLmtpbmQgPSAnRm9ybWF0RXhjZXB0aW9uJzsKCSAgICByZXR1cm4gRm9ybWF0RXhjZXB0aW9uOwoJfShFeGNlcHRpb25fMSQ3LmRlZmF1bHQpKTsKCUZvcm1hdEV4Y2VwdGlvbiQxLmRlZmF1bHQgPSBGb3JtYXRFeGNlcHRpb247CgoJKGZ1bmN0aW9uIChleHBvcnRzKSB7CgkvKgoJICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fdmFsdWVzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7CgkgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7CgkgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7CgkgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSAibnVtYmVyIikgcmV0dXJuIHsKCSAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkgewoJICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDsKCSAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gIk9iamVjdCBpcyBub3QgaXRlcmFibGUuIiA6ICJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuIik7Cgl9OwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCWV4cG9ydHMuQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IHZvaWQgMDsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJdmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gRm9ybWF0RXhjZXB0aW9uJDE7CgkvKmltcG9ydCBqYXZhLnV0aWwuSGFzaE1hcDsqLwoJLyppbXBvcnQgamF2YS51dGlsLk1hcDsqLwoJdmFyIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnM7CgkoZnVuY3Rpb24gKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMpIHsKCSAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbIkNwNDM3Il0gPSAwXSA9ICJDcDQzNyI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzEiXSA9IDFdID0gIklTTzg4NTlfMSI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzIiXSA9IDJdID0gIklTTzg4NTlfMiI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzMiXSA9IDNdID0gIklTTzg4NTlfMyI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzQiXSA9IDRdID0gIklTTzg4NTlfNCI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzUiXSA9IDVdID0gIklTTzg4NTlfNSI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzYiXSA9IDZdID0gIklTTzg4NTlfNiI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzciXSA9IDddID0gIklTTzg4NTlfNyI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzgiXSA9IDhdID0gIklTTzg4NTlfOCI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzkiXSA9IDldID0gIklTTzg4NTlfOSI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzEwIl0gPSAxMF0gPSAiSVNPODg1OV8xMCI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzExIl0gPSAxMV0gPSAiSVNPODg1OV8xMSI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzEzIl0gPSAxMl0gPSAiSVNPODg1OV8xMyI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzE0Il0gPSAxM10gPSAiSVNPODg1OV8xNCI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzE1Il0gPSAxNF0gPSAiSVNPODg1OV8xNSI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJJU084ODU5XzE2Il0gPSAxNV0gPSAiSVNPODg1OV8xNiI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJTSklTIl0gPSAxNl0gPSAiU0pJUyI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJDcDEyNTAiXSA9IDE3XSA9ICJDcDEyNTAiOwoJICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1siQ3AxMjUxIl0gPSAxOF0gPSAiQ3AxMjUxIjsKCSAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbIkNwMTI1MiJdID0gMTldID0gIkNwMTI1MiI7CgkgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzWyJDcDEyNTYiXSA9IDIwXSA9ICJDcDEyNTYiOwoJICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1siVW5pY29kZUJpZ1VubWFya2VkIl0gPSAyMV0gPSAiVW5pY29kZUJpZ1VubWFya2VkIjsKCSAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbIlVURjgiXSA9IDIyXSA9ICJVVEY4IjsKCSAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbIkFTQ0lJIl0gPSAyM10gPSAiQVNDSUkiOwoJICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1siQmlnNSJdID0gMjRdID0gIkJpZzUiOwoJICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1siR0IxODAzMCJdID0gMjVdID0gIkdCMTgwMzAiOwoJICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1siRVVDX0tSIl0gPSAyNl0gPSAiRVVDX0tSIjsKCX0pKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgPSBleHBvcnRzLkNoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgfHwgKGV4cG9ydHMuQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IHt9KSk7CgkvKioKCSAqIEVuY2Fwc3VsYXRlcyBhIENoYXJhY3RlciBTZXQgRUNJLCBhY2NvcmRpbmcgdG8gIkV4dGVuZGVkIENoYW5uZWwgSW50ZXJwcmV0YXRpb25zIiA1LjMuMS4xCgkgKiBvZiBJU08gMTgwMDQuCgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIENoYXJhY3RlclNldEVDSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBDaGFyYWN0ZXJTZXRFQ0kodmFsdWVJZGVudGlmaWVyLCB2YWx1ZXNQYXJhbSwgbmFtZSkgewoJICAgICAgICB2YXIgZV8xLCBfYTsKCSAgICAgICAgdmFyIG90aGVyRW5jb2RpbmdOYW1lcyA9IFtdOwoJICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykgewoJICAgICAgICAgICAgb3RoZXJFbmNvZGluZ05hbWVzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMudmFsdWVJZGVudGlmaWVyID0gdmFsdWVJZGVudGlmaWVyOwoJICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOwoJICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1BhcmFtID09PSAnbnVtYmVyJykgewoJICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBJbnQzMkFycmF5LmZyb20oW3ZhbHVlc1BhcmFtXSk7CgkgICAgICAgIH0KCSAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlc1BhcmFtOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzOwoJICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVfSURFTlRJRklFUl9UT19FQ0kuc2V0KHZhbHVlSWRlbnRpZmllciwgdGhpcyk7CgkgICAgICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSS5zZXQobmFtZSwgdGhpcyk7CgkgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlczsKCSAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykgewoJICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV07CgkgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSS5zZXQodiwgdGhpcyk7CgkgICAgICAgIH0KCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIGZvciAodmFyIG90aGVyRW5jb2RpbmdOYW1lc18xID0gX192YWx1ZXMob3RoZXJFbmNvZGluZ05hbWVzKSwgb3RoZXJFbmNvZGluZ05hbWVzXzFfMSA9IG90aGVyRW5jb2RpbmdOYW1lc18xLm5leHQoKTsgIW90aGVyRW5jb2RpbmdOYW1lc18xXzEuZG9uZTsgb3RoZXJFbmNvZGluZ05hbWVzXzFfMSA9IG90aGVyRW5jb2RpbmdOYW1lc18xLm5leHQoKSkgewoJICAgICAgICAgICAgICAgIHZhciBvdGhlck5hbWUgPSBvdGhlckVuY29kaW5nTmFtZXNfMV8xLnZhbHVlOwoJICAgICAgICAgICAgICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSS5zZXQob3RoZXJOYW1lLCB0aGlzKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfQoJICAgICAgICBmaW5hbGx5IHsKCSAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgaWYgKG90aGVyRW5jb2RpbmdOYW1lc18xXzEgJiYgIW90aGVyRW5jb2RpbmdOYW1lc18xXzEuZG9uZSAmJiAoX2EgPSBvdGhlckVuY29kaW5nTmFtZXNfMS5yZXR1cm4pKSBfYS5jYWxsKG90aGVyRW5jb2RpbmdOYW1lc18xKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH0KCSAgICAgICAgfQoJICAgIH0KCSAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWU6IG51bWJlciAvKmludCovKSB7CgkgICAgLy8gICB0aGlzKG5ldyBJbnQzMkFycmF5IHt2YWx1ZX0pCgkgICAgLy8gfQoJICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZTogbnVtYmVyIC8qaW50Ki8sIFN0cmluZy4uLiBvdGhlckVuY29kaW5nTmFtZXMpIHsKCSAgICAvLyAgIHRoaXMudmFsdWVzID0gbmV3IEludDMyQXJyYXkge3ZhbHVlfQoJICAgIC8vICAgdGhpcy5vdGhlckVuY29kaW5nTmFtZXMgPSBvdGhlckVuY29kaW5nTmFtZXMKCSAgICAvLyB9CgkgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlczogSW50MzJBcnJheSwgU3RyaW5nLi4uIG90aGVyRW5jb2RpbmdOYW1lcykgewoJICAgIC8vICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXMKCSAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzCgkgICAgLy8gfQoJICAgIENoYXJhY3RlclNldEVDSS5wcm90b3R5cGUuZ2V0VmFsdWVJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUlkZW50aWZpZXI7CgkgICAgfTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLm5hbWU7CgkgICAgfTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gdmFsdWUgY2hhcmFjdGVyIHNldCBFQ0kgdmFsdWUKCSAgICAgKiBAcmV0dXJuIHtAY29kZSBDaGFyYWN0ZXJTZXRFQ0l9IHJlcHJlc2VudGluZyBFQ0kgb2YgZ2l2ZW4gdmFsdWUsIG9yIG51bGwgaWYgaXQgaXMgbGVnYWwgYnV0CgkgICAgICogICB1bnN1cHBvcnRlZAoJICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIEVDSSB2YWx1ZSBpcyBpbnZhbGlkCgkgICAgICovCgkgICAgQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLykgewoJICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDkwMCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2luY29yZWN0IHZhbHVlJyk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGNoYXJhY3RlclNldCA9IENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJLmdldCh2YWx1ZSk7CgkgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2luY29yZWN0IHZhbHVlJyk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGNoYXJhY3RlclNldDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBuYW1lIGNoYXJhY3RlciBzZXQgRUNJIGVuY29kaW5nIG5hbWUKCSAgICAgKiBAcmV0dXJuIENoYXJhY3RlclNldEVDSSByZXByZXNlbnRpbmcgRUNJIGZvciBjaGFyYWN0ZXIgZW5jb2RpbmcsIG9yIG51bGwgaWYgaXQgaXMgbGVnYWwKCSAgICAgKiAgIGJ1dCB1bnN1cHBvcnRlZAoJICAgICAqLwoJICAgIENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkgewoJICAgICAgICB2YXIgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLmdldChuYW1lKTsKCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2hhcmFjdGVyU2V0KSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgnaW5jb3JlY3QgdmFsdWUnKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0OwoJICAgIH07CgkgICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykgewoJICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQ2hhcmFjdGVyU2V0RUNJKSkgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIHZhciBvdGhlciA9IG87CgkgICAgICAgIHJldHVybiB0aGlzLmdldE5hbWUoKSA9PT0gb3RoZXIuZ2V0TmFtZSgpOwoJICAgIH07CgkgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFX0lERU5USUZJRVJfVE9fRUNJID0gbmV3IE1hcCgpOwoJICAgIENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJID0gbmV3IE1hcCgpOwoJICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSSA9IG5ldyBNYXAoKTsKCSAgICAvLyBFbnVtIG5hbWUgaXMgYSBKYXZhIGVuY29kaW5nIHZhbGlkIGZvciBqYXZhLmxhbmcgYW5kIGphdmEuaW8KCSAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0aGUgbWFpbiBsYWJlbCBmb3IgSVNPIGFzIHRoZSBUZXh0RW5jb2RlciBkaWQgbm90IHJlY29nbml6ZWQgdGhlbSBpbiB0aGUgZm9ybSBmcm9tIGphdmEKCSAgICAvLyAoZWcgSVNPODg1OV8xIG11c3QgYmUgSVNPODg1OTEgb3IgSVNPODg1OS0xIG9yIElTTy04ODU5LTEpCgkgICAgLy8gbGF0ZXIgb246IHdlbGwsIGV4Y2VwdCAxNiB3aWNoIGRvZXMgbm90IHdvcmsgd2l0aCBJU084ODU5MTYgc28gdXNlZCBJU08tODg1OS0xIGZvcm0gZm9yIGRlZmF1bHQKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3A0MzcgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3A0MzcsIEludDMyQXJyYXkuZnJvbShbMCwgMl0pLCAnQ3A0MzcnKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMSwgSW50MzJBcnJheS5mcm9tKFsxLCAzXSksICdJU08tODg1OS0xJywgJ0lTTzg4NTkxJywgJ0lTTzg4NTlfMScpOwoJICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzIgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8yLCA0LCAnSVNPLTg4NTktMicsICdJU084ODU5MicsICdJU084ODU5XzInKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8zID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMywgNSwgJ0lTTy04ODU5LTMnLCAnSVNPODg1OTMnLCAnSVNPODg1OV8zJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzQsIDYsICdJU08tODg1OS00JywgJ0lTTzg4NTk0JywgJ0lTTzg4NTlfNCcpOwoJICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV81LCA3LCAnSVNPLTg4NTktNScsICdJU084ODU5NScsICdJU084ODU5XzUnKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV82ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNiwgOCwgJ0lTTy04ODU5LTYnLCAnSVNPODg1OTYnLCAnSVNPODg1OV82Jyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzcsIDksICdJU08tODg1OS03JywgJ0lTTzg4NTk3JywgJ0lTTzg4NTlfNycpOwoJICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV84LCAxMCwgJ0lTTy04ODU5LTgnLCAnSVNPODg1OTgnLCAnSVNPODg1OV84Jyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfOSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzksIDExLCAnSVNPLTg4NTktOScsICdJU084ODU5OScsICdJU084ODU5XzknKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEwLCAxMiwgJ0lTTy04ODU5LTEwJywgJ0lTTzg4NTkxMCcsICdJU084ODU5XzEwJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTEgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMSwgMTMsICdJU08tODg1OS0xMScsICdJU084ODU5MTEnLCAnSVNPODg1OV8xMScpOwoJICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzEzID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTMsIDE1LCAnSVNPLTg4NTktMTMnLCAnSVNPODg1OTEzJywgJ0lTTzg4NTlfMTMnKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE0LCAxNiwgJ0lTTy04ODU5LTE0JywgJ0lTTzg4NTkxNCcsICdJU084ODU5XzE0Jyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNSwgMTcsICdJU08tODg1OS0xNScsICdJU084ODU5MTUnLCAnSVNPODg1OV8xNScpOwoJICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE2ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTYsIDE4LCAnSVNPLTg4NTktMTYnLCAnSVNPODg1OTE2JywgJ0lTTzg4NTlfMTYnKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5TSklTLCAyMCwgJ1NKSVMnLCAnU2hpZnRfSklTJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTAsIDIxLCAnQ3AxMjUwJywgJ3dpbmRvd3MtMTI1MCcpOwoJICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTEgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUxLCAyMiwgJ0NwMTI1MScsICd3aW5kb3dzLTEyNTEnKTsKCSAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUyID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MiwgMjMsICdDcDEyNTInLCAnd2luZG93cy0xMjUyJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1NiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTYsIDI0LCAnQ3AxMjU2JywgJ3dpbmRvd3MtMTI1NicpOwoJICAgIENoYXJhY3RlclNldEVDSS5Vbmljb2RlQmlnVW5tYXJrZWQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVW5pY29kZUJpZ1VubWFya2VkLCAyNSwgJ1VuaWNvZGVCaWdVbm1hcmtlZCcsICdVVEYtMTZCRScsICdVbmljb2RlQmlnJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLlVURjggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVVRGOCwgMjYsICdVVEY4JywgJ1VURi04Jyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLkFTQ0lJID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkFTQ0lJLCBJbnQzMkFycmF5LmZyb20oWzI3LCAxNzBdKSwgJ0FTQ0lJJywgJ1VTLUFTQ0lJJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLkJpZzUgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQmlnNSwgMjgsICdCaWc1Jyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLkdCMTgwMzAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuR0IxODAzMCwgMjksICdHQjE4MDMwJywgJ0dCMjMxMicsICdFVUNfQ04nLCAnR0JLJyk7CgkgICAgQ2hhcmFjdGVyU2V0RUNJLkVVQ19LUiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5FVUNfS1IsIDMwLCAnRVVDX0tSJywgJ0VVQy1LUicpOwoJICAgIHJldHVybiBDaGFyYWN0ZXJTZXRFQ0k7Cgl9KCkpOwoJZXhwb3J0cy5kZWZhdWx0ID0gQ2hhcmFjdGVyU2V0RUNJOwoKCX0oQ2hhcmFjdGVyU2V0RUNJKSk7CgoJdmFyIFN0cmluZ0VuY29kaW5nJDEgPSB7fTsKCgl2YXIgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24kMSA9IHt9OwoKCXZhciBfX2V4dGVuZHMkZSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgRXhjZXB0aW9uXzEkNiA9IEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uCgkgKi8KCXZhciBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkZShVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbigpIHsKCSAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoJICAgIH0KCSAgICBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbi5raW5kID0gJ1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uJzsKCSAgICByZXR1cm4gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb247Cgl9KEV4Y2VwdGlvbl8xJDYuZGVmYXVsdCkpOwoJVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24kMS5kZWZhdWx0ID0gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb247CgoJT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZ0VuY29kaW5nJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xJDEgPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiQxOwoJdmFyIENoYXJhY3RlclNldEVDSV8xJDIgPSBDaGFyYWN0ZXJTZXRFQ0k7CgkvKioKCSAqIFJlc3BvbnNpYmxlIGZvciBlbi9kZWNvZGluZyBzdHJpbmdzLgoJICovCgl2YXIgU3RyaW5nRW5jb2RpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gU3RyaW5nRW5jb2RpbmcoKSB7CgkgICAgfQoJICAgIC8qKgoJICAgICAqIERlY29kZXMgc29tZSBVaW50OEFycmF5IHRvIGEgc3RyaW5nIGZvcm1hdC4KCSAgICAgKi8KCSAgICBTdHJpbmdFbmNvZGluZy5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMsIGVuY29kaW5nKSB7CgkgICAgICAgIHZhciBlbmNvZGluZ05hbWUgPSB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyk7CgkgICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHsKCSAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURlY29kZXIoYnl0ZXMsIGVuY29kaW5nTmFtZSk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gSW5jcmVhc2VzIGJyb3dzZXIgc3VwcG9ydC4KCSAgICAgICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zaG91bGREZWNvZGVPbkZhbGxiYWNrKGVuY29kaW5nTmFtZSkpIHsKCSAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZhbGxiYWNrKGJ5dGVzLCBlbmNvZGluZ05hbWUpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmdOYW1lKS5kZWNvZGUoYnl0ZXMpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQ2hlY2tzIGlmIHRoZSBkZWNvZGluZyBtZXRob2Qgc2hvdWxkIHVzZSB0aGUgZmFsbGJhY2sgZm9yIGRlY29kaW5nCgkgICAgICogb25jZSBOb2RlIFRleHREZWNvZGVyIGRvZXNuJ3Qgc3VwcG9ydCBhbGwgZW5jb2RpbmcgZm9ybWF0cy4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBlbmNvZGluZ05hbWUKCSAgICAgKi8KCSAgICBTdHJpbmdFbmNvZGluZy5zaG91bGREZWNvZGVPbkZhbGxiYWNrID0gZnVuY3Rpb24gKGVuY29kaW5nTmFtZSkgewoJICAgICAgICByZXR1cm4gIVN0cmluZ0VuY29kaW5nLmlzQnJvd3NlcigpICYmIGVuY29kaW5nTmFtZSA9PT0gJ0lTTy04ODU5LTEnOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogRW5jb2RlcyBzb21lIHN0cmluZyBpbnRvIGEgVWludDhBcnJheS4KCSAgICAgKi8KCSAgICBTdHJpbmdFbmNvZGluZy5lbmNvZGUgPSBmdW5jdGlvbiAocywgZW5jb2RpbmcpIHsKCSAgICAgICAgdmFyIGVuY29kaW5nTmFtZSA9IHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKTsKCSAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2RlcikgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRW5jb2RlcihzLCBlbmNvZGluZ05hbWUpOwoJICAgICAgICB9CgkgICAgICAgIC8vIEluY3JlYXNlcyBicm93c2VyIHN1cHBvcnQuCgkgICAgICAgIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7CgkgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVGYWxsYmFjayhzKTsKCSAgICAgICAgfQoJICAgICAgICAvLyBUZXh0RW5jb2RlciBvbmx5IGVuY29kZXMgdG8gVVRGOCBieSBkZWZhdWx0IGFzIHNwZWNpZmllZCBieSBlbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcKCSAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTsKCSAgICB9OwoJICAgIFN0cmluZ0VuY29kaW5nLmlzQnJvd3NlciA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IFdpbmRvd10nKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgdGhlIHN0cmluZyB2YWx1ZSBmcm9tIHNvbWUgZW5jb2RpbmcgY2hhcmFjdGVyIHNldC4KCSAgICAgKi8KCSAgICBTdHJpbmdFbmNvZGluZy5lbmNvZGluZ05hbWUgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHsKCSAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycKCSAgICAgICAgICAgID8gZW5jb2RpbmcKCSAgICAgICAgICAgIDogZW5jb2RpbmcuZ2V0TmFtZSgpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogUmV0dXJucyBjaGFyYWN0ZXIgc2V0IGZyb20gc29tZSBlbmNvZGluZyBjaGFyYWN0ZXIgc2V0LgoJICAgICAqLwoJICAgIFN0cmluZ0VuY29kaW5nLmVuY29kaW5nQ2hhcmFjdGVyU2V0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7CgkgICAgICAgIGlmIChlbmNvZGluZyBpbnN0YW5jZW9mIENoYXJhY3RlclNldEVDSV8xJDIuZGVmYXVsdCkgewoJICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBDaGFyYWN0ZXJTZXRFQ0lfMSQyLmRlZmF1bHQuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlOYW1lKGVuY29kaW5nKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJ1bnMgYSBmYWxsYmFjayBmb3IgdGhlIG5hdGl2ZSBkZWNvZGluZyBmdW5jaW9uLgoJICAgICAqLwoJICAgIFN0cmluZ0VuY29kaW5nLmRlY29kZUZhbGxiYWNrID0gZnVuY3Rpb24gKGJ5dGVzLCBlbmNvZGluZykgewoJICAgICAgICB2YXIgY2hhcmFjdGVyU2V0ID0gdGhpcy5lbmNvZGluZ0NoYXJhY3RlclNldChlbmNvZGluZyk7CgkgICAgICAgIGlmIChTdHJpbmdFbmNvZGluZy5pc0RlY29kZUZhbGxiYWNrU3VwcG9ydGVkKGNoYXJhY3RlclNldCkpIHsKCSAgICAgICAgICAgIHZhciBzID0gJyc7CgkgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBieXRlcy5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIGggPSBieXRlc1tpXS50b1N0cmluZygxNik7CgkgICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikgewoJICAgICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgcyArPSAnJScgKyBoOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzKTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMSQyLmRlZmF1bHQuVW5pY29kZUJpZ1VubWFya2VkKSkgewoJICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpOwoJICAgICAgICB9CgkgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xJDEuZGVmYXVsdCgiRW5jb2RpbmcgIiArIHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKSArICIgbm90IHN1cHBvcnRlZCBieSBmYWxsYmFjay4iKTsKCSAgICB9OwoJICAgIFN0cmluZ0VuY29kaW5nLmlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoY2hhcmFjdGVyU2V0KSB7CgkgICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSV8xJDIuZGVmYXVsdC5VVEY4KSB8fAoJICAgICAgICAgICAgY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMSQyLmRlZmF1bHQuSVNPODg1OV8xKSB8fAoJICAgICAgICAgICAgY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMSQyLmRlZmF1bHQuQVNDSUkpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogUnVucyBhIGZhbGxiYWNrIGZvciB0aGUgbmF0aXZlIGVuY29kaW5nIGZ1bmNpb24uCgkgICAgICoKCSAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzE5Mjg0NS80MzY3NjgzCgkgICAgICovCgkgICAgU3RyaW5nRW5jb2RpbmcuZW5jb2RlRmFsbGJhY2sgPSBmdW5jdGlvbiAocykgewoJICAgICAgICB2YXIgZW5jb2RlZFVSSXN0cmluZyA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSk7CgkgICAgICAgIHZhciBjaGFyTGlzdCA9IGVuY29kZWRVUklzdHJpbmcuc3BsaXQoJycpOwoJICAgICAgICB2YXIgdWludEFycmF5ID0gW107CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckxpc3QubGVuZ3RoOyBpKyspIHsKCSAgICAgICAgICAgIHVpbnRBcnJheS5wdXNoKGNoYXJMaXN0W2ldLmNoYXJDb2RlQXQoMCkpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh1aW50QXJyYXkpOwoJICAgIH07CgkgICAgcmV0dXJuIFN0cmluZ0VuY29kaW5nOwoJfSgpKTsKCVN0cmluZ0VuY29kaW5nJDEuZGVmYXVsdCA9IFN0cmluZ0VuY29kaW5nOwoKCS8qCgkgKiBDb3B5cmlnaHQgKEMpIDIwMTAgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZ1V0aWxzJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJLyppbXBvcnQgamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0OyovCgkvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovCgl2YXIgRGVjb2RlSGludFR5cGVfMSQzID0gRGVjb2RlSGludFR5cGUkMTsKCXZhciBDaGFyYWN0ZXJTZXRFQ0lfMSQxID0gQ2hhcmFjdGVyU2V0RUNJOwoJdmFyIFN0cmluZ0VuY29kaW5nXzEkMSA9IFN0cmluZ0VuY29kaW5nJDE7CgkvKioKCSAqIENvbW1vbiBzdHJpbmctcmVsYXRlZCBmdW5jdGlvbnMuCgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqIEBhdXRob3IgQWxleCBEdXByZQoJICovCgl2YXIgU3RyaW5nVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gU3RyaW5nVXRpbHMoKSB7CgkgICAgfQoJICAgIC8vIFNISUZUX0pJUy5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpIHx8CgkgICAgLy8gRVVDX0pQLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyk7CgkgICAgU3RyaW5nVXRpbHMuY2FzdEFzTm9uVXRmOENoYXIgPSBmdW5jdGlvbiAoY29kZSwgZW5jb2RpbmcpIHsKCSAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSBudWxsOyB9CgkgICAgICAgIC8vIElTTyA4ODU5LTEgaXMgdGhlIEphdmEgZGVmYXVsdCBhcyBVVEYtOCBpcyBKYXZhU2NyaXB0cwoJICAgICAgICAvLyB5b3UgY2FuIHNlZSB0aGlzIG1ldGhvZCBhcyBhIEphdmEgdmVyc2lvbiBvZiBTdHJpbmcuZnJvbUNoYXJDb2RlCgkgICAgICAgIHZhciBlID0gZW5jb2RpbmcgPyBlbmNvZGluZy5nZXROYW1lKCkgOiB0aGlzLklTTzg4NTkxOwoJICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpCgkgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZ18xJDEuZGVmYXVsdC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoW2NvZGVdKSwgZSk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gYnl0ZXMgYnl0ZXMgZW5jb2RpbmcgYSBzdHJpbmcsIHdob3NlIGVuY29kaW5nIHNob3VsZCBiZSBndWVzc2VkCgkgICAgICogQHBhcmFtIGhpbnRzIGRlY29kZSBoaW50cyBpZiBhcHBsaWNhYmxlCgkgICAgICogQHJldHVybiBuYW1lIG9mIGd1ZXNzZWQgZW5jb2Rpbmc7IGF0IHRoZSBtb21lbnQgd2lsbCBvbmx5IGd1ZXNzIG9uZSBvZjoKCSAgICAgKiAge0BsaW5rICNTSElGVF9KSVN9LCB7QGxpbmsgI1VURjh9LCB7QGxpbmsgI0lTTzg4NTkxfSwgb3IgdGhlIHBsYXRmb3JtCgkgICAgICogIGRlZmF1bHQgZW5jb2RpbmcgaWYgbm9uZSBvZiB0aGVzZSBjYW4gcG9zc2libHkgYmUgY29ycmVjdAoJICAgICAqLwoJICAgIFN0cmluZ1V0aWxzLmd1ZXNzRW5jb2RpbmcgPSBmdW5jdGlvbiAoYnl0ZXMsIGhpbnRzKSB7CgkgICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEkMy5kZWZhdWx0LkNIQVJBQ1RFUl9TRVQpKSB7CgkgICAgICAgICAgICByZXR1cm4gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEkMy5kZWZhdWx0LkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gRm9yIG5vdywgbWVyZWx5IHRyaWVzIHRvIGRpc3Rpbmd1aXNoIElTTy04ODU5LTEsIFVURi04IGFuZCBTaGlmdF9KSVMsCgkgICAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBieSBmYXIgdGhlIG1vc3QgY29tbW9uIGVuY29kaW5ncy4KCSAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDsKCSAgICAgICAgdmFyIGNhbkJlSVNPODg1OTEgPSB0cnVlOwoJICAgICAgICB2YXIgY2FuQmVTaGlmdEpJUyA9IHRydWU7CgkgICAgICAgIHZhciBjYW5CZVVURjggPSB0cnVlOwoJICAgICAgICB2YXIgdXRmOEJ5dGVzTGVmdCA9IDA7CgkgICAgICAgIC8vIGludCB1dGY4TG93Q2hhcnMgPSAwCgkgICAgICAgIHZhciB1dGYyQnl0ZXNDaGFycyA9IDA7CgkgICAgICAgIHZhciB1dGYzQnl0ZXNDaGFycyA9IDA7CgkgICAgICAgIHZhciB1dGY0Qnl0ZXNDaGFycyA9IDA7CgkgICAgICAgIHZhciBzamlzQnl0ZXNMZWZ0ID0gMDsKCSAgICAgICAgLy8gaW50IHNqaXNMb3dDaGFycyA9IDAKCSAgICAgICAgdmFyIHNqaXNLYXRha2FuYUNoYXJzID0gMDsKCSAgICAgICAgLy8gaW50IHNqaXNEb3VibGVCeXRlc0NoYXJzID0gMAoJICAgICAgICB2YXIgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7CgkgICAgICAgIHZhciBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDsKCSAgICAgICAgdmFyIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSAwOwoJICAgICAgICB2YXIgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA9IDA7CgkgICAgICAgIC8vIGludCBpc29Mb3dDaGFycyA9IDAKCSAgICAgICAgLy8gaW50IGlzb0hpZ2hDaGFycyA9IDAKCSAgICAgICAgdmFyIGlzb0hpZ2hPdGhlciA9IDA7CgkgICAgICAgIHZhciB1dGY4Ym9tID0gYnl0ZXMubGVuZ3RoID4gMyAmJgoJICAgICAgICAgICAgYnl0ZXNbMF0gPT09IC8qKGJ5dGUpICovIDB4RUYgJiYKCSAgICAgICAgICAgIGJ5dGVzWzFdID09PSAvKihieXRlKSAqLyAweEJCICYmCgkgICAgICAgICAgICBieXRlc1syXSA9PT0gLyooYnl0ZSkgKi8gMHhCRjsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgKGNhbkJlSVNPODg1OTEgfHwgY2FuQmVTaGlmdEpJUyB8fCBjYW5CZVVURjgpOyBpKyspIHsKCSAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJ5dGVzW2ldICYgMHhGRjsKCSAgICAgICAgICAgIC8vIFVURi04IHN0dWZmCgkgICAgICAgICAgICBpZiAoY2FuQmVVVEY4KSB7CgkgICAgICAgICAgICAgICAgaWYgKHV0ZjhCeXRlc0xlZnQgPiAwKSB7CgkgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0LS07CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZhbHVlICYgMHg4MCkgIT09IDApIHsKCSAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4NDApID09PSAwKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKzsKCSAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDIwKSA9PT0gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjJCeXRlc0NoYXJzKys7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MTApID09PSAwKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjNCeXRlc0NoYXJzKys7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDA4KSA9PT0gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmNEJ5dGVzQ2hhcnMrKzsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHsKCSAgICAgICAgICAgICAgICAvLyB1dGY4TG93Q2hhcnMrKwoJICAgICAgICAgICAgICAgIC8vIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIC8vIElTTy04ODU5LTEgc3R1ZmYKCSAgICAgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxKSB7CgkgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMHg3RiAmJiB2YWx1ZSA8IDB4QTApIHsKCSAgICAgICAgICAgICAgICAgICAgY2FuQmVJU084ODU5MSA9IGZhbHNlOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4OUYpIHsKCSAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHhDMCB8fCB2YWx1ZSA9PT0gMHhENyB8fCB2YWx1ZSA9PT0gMHhGNykgewoJICAgICAgICAgICAgICAgICAgICAgICAgaXNvSGlnaE90aGVyKys7CgkgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgIC8vIGlzb0hpZ2hDaGFycysrCgkgICAgICAgICAgICAgICAgICAgIC8vIH0KCSAgICAgICAgICAgICAgICB9IC8vIGVsc2UgewoJICAgICAgICAgICAgICAgIC8vIGlzb0xvd0NoYXJzKysKCSAgICAgICAgICAgICAgICAvLyB9CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICAvLyBTaGlmdF9KSVMgc3R1ZmYKCSAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7CgkgICAgICAgICAgICAgICAgaWYgKHNqaXNCeXRlc0xlZnQgPiAwKSB7CgkgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4NDAgfHwgdmFsdWUgPT09IDB4N0YgfHwgdmFsdWUgPiAweEZDKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgICAgICBzamlzQnl0ZXNMZWZ0LS07CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IDB4ODAgfHwgdmFsdWUgPT09IDB4QTAgfHwgdmFsdWUgPiAweEVGKSB7CgkgICAgICAgICAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPiAweEEwICYmIHZhbHVlIDwgMHhFMCkgewoJICAgICAgICAgICAgICAgICAgICBzamlzS2F0YWthbmFDaGFycysrOwoJICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDsKCSAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCsrOwoJICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA+IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGgpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg3RikgewoJICAgICAgICAgICAgICAgICAgICBzamlzQnl0ZXNMZWZ0Kys7CgkgICAgICAgICAgICAgICAgICAgIC8vIHNqaXNEb3VibGVCeXRlc0NoYXJzKysKCSAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7CgkgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGgrKzsKCSAgICAgICAgICAgICAgICAgICAgaWYgKHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPiBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aDsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0xvd0NoYXJzKysKCSAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7CgkgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBpZiAoY2FuQmVVVEY4ICYmIHV0ZjhCeXRlc0xlZnQgPiAwKSB7CgkgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUyAmJiBzamlzQnl0ZXNMZWZ0ID4gMCkgewoJICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIC8vIEVhc3kgLS0gaWYgdGhlcmUgaXMgQk9NIG9yIGF0IGxlYXN0IDEgdmFsaWQgbm90LXNpbmdsZSBieXRlIGNoYXJhY3RlciAoYW5kIG5vIGV2aWRlbmNlIGl0IGNhbid0IGJlIFVURi04KSwgZG9uZQoJICAgICAgICBpZiAoY2FuQmVVVEY4ICYmICh1dGY4Ym9tIHx8IHV0ZjJCeXRlc0NoYXJzICsgdXRmM0J5dGVzQ2hhcnMgKyB1dGY0Qnl0ZXNDaGFycyA+IDApKSB7CgkgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODsKCSAgICAgICAgfQoJICAgICAgICAvLyBFYXN5IC0tIGlmIGFzc3VtaW5nIFNoaWZ0X0pJUyBvciBhdCBsZWFzdCAzIHZhbGlkIGNvbnNlY3V0aXZlIG5vdC1hc2NpaSBjaGFyYWN0ZXJzIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUpLCBkb25lCgkgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIChTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTIHx8IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPj0gMyB8fCBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID49IDMpKSB7CgkgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuU0hJRlRfSklTOwoJICAgICAgICB9CgkgICAgICAgIC8vIERpc3Rpbmd1aXNoaW5nIFNoaWZ0X0pJUyBhbmQgSVNPLTg4NTktMSBjYW4gYmUgYSBsaXR0bGUgdG91Z2ggZm9yIHNob3J0IHdvcmRzLiBUaGUgY3J1ZGUgaGV1cmlzdGljIGlzOgoJICAgICAgICAvLyAtIElmIHdlIHNhdwoJICAgICAgICAvLyAgIC0gb25seSB0d28gY29uc2VjdXRpdmUga2F0YWthbmEgY2hhcnMgaW4gdGhlIHdob2xlIHRleHQsIG9yCgkgICAgICAgIC8vICAgLSBhdCBsZWFzdCAxMCUgb2YgYnl0ZXMgdGhhdCBjb3VsZCBiZSAidXBwZXIiIG5vdC1hbHBoYW51bWVyaWMgTGF0aW4xLAoJICAgICAgICAvLyAtIHRoZW4gd2UgY29uY2x1ZGUgU2hpZnRfSklTLCBlbHNlIElTTy04ODU5LTEKCSAgICAgICAgaWYgKGNhbkJlSVNPODg1OTEgJiYgY2FuQmVTaGlmdEpJUykgewoJICAgICAgICAgICAgcmV0dXJuIChzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID09PSAyICYmIHNqaXNLYXRha2FuYUNoYXJzID09PSAyKSB8fCBpc29IaWdoT3RoZXIgKiAxMCA+PSBsZW5ndGgKCSAgICAgICAgICAgICAgICA/IFN0cmluZ1V0aWxzLlNISUZUX0pJUyA6IFN0cmluZ1V0aWxzLklTTzg4NTkxOwoJICAgICAgICB9CgkgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IGluIG9yZGVyIElTTy04ODU5LTEsIFNoaWZ0IEpJUywgVVRGLTggYW5kIGZhbGwgYmFjayB0byBkZWZhdWx0IHBsYXRmb3JtIGVuY29kaW5nCgkgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxKSB7CgkgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuSVNPODg1OTE7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMpIHsKCSAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5TSElGVF9KSVM7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGNhbkJlVVRGOCkgewoJICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlVURjg7CgkgICAgICAgIH0KCSAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0YWtlIGEgd2lsZCBndWVzcyB3aXRoIHBsYXRmb3JtIGVuY29kaW5nCgkgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5QTEFURk9STV9ERUZBVUxUX0VOQ09ESU5HOwoJICAgIH07CgkgICAgLyoqCgkgICAgICoKCSAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzQzOTcxMS80MzY3NjgzCgkgICAgICoKCSAgICAgKiBAcGFyYW0gYXBwZW5kIFRoZSBuZXcgc3RyaW5nIHRvIGFwcGVuZC4KCSAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWV0cyB2YWx1ZXMgdG8gYmUgZm9ybWF0ZWQuCgkgICAgICovCgkgICAgU3RyaW5nVXRpbHMuZm9ybWF0ID0gZnVuY3Rpb24gKGFwcGVuZCkgewoJICAgICAgICB2YXIgYXJncyA9IFtdOwoJICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykgewoJICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgaSA9IC0xOwoJICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhleHAsIHAwLCBwMSwgcDIsIHAzLCBwNCkgewoJICAgICAgICAgICAgaWYgKGV4cCA9PT0gJyUlJykKCSAgICAgICAgICAgICAgICByZXR1cm4gJyUnOwoJICAgICAgICAgICAgaWYgKGFyZ3NbKytpXSA9PT0gdW5kZWZpbmVkKQoJICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7CgkgICAgICAgICAgICBleHAgPSBwMiA/IHBhcnNlSW50KHAyLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7CgkgICAgICAgICAgICB2YXIgYmFzZSA9IHAzID8gcGFyc2VJbnQocDMuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDsKCSAgICAgICAgICAgIHZhciB2YWw7CgkgICAgICAgICAgICBzd2l0Y2ggKHA0KSB7CgkgICAgICAgICAgICAgICAgY2FzZSAncyc6CgkgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZ3NbaV07CgkgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgIGNhc2UgJ2MnOgoJICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmdzW2ldWzBdOwoJICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICBjYXNlICdmJzoKCSAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b0ZpeGVkKGV4cCk7CgkgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgIGNhc2UgJ3AnOgoJICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvUHJlY2lzaW9uKGV4cCk7CgkgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgIGNhc2UgJ2UnOgoJICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvRXhwb25lbnRpYWwoZXhwKTsKCSAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgkgICAgICAgICAgICAgICAgY2FzZSAneCc6CgkgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KGFyZ3NbaV0pLnRvU3RyaW5nKGJhc2UgPyBiYXNlIDogMTYpOwoJICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICBjYXNlICdkJzoKCSAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChwYXJzZUludChhcmdzW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApOwoJICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTsKCSAgICAgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQocDEpOyAvKiBwYWRkaW5nIHNpemUgKi8KCSAgICAgICAgICAgIHZhciBjaCA9IHAxICYmIChwMVswXSArICcnKSA9PT0gJzAnID8gJzAnIDogJyAnOyAvKiBpc251bGw/ICovCgkgICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpCgkgICAgICAgICAgICAgICAgdmFsID0gcDAgIT09IHVuZGVmaW5lZCA/IHZhbCArIGNoIDogY2ggKyB2YWw7IC8qIGlzbWludXM/ICovCgkgICAgICAgICAgICByZXR1cm4gdmFsOwoJICAgICAgICB9CgkgICAgICAgIHZhciByZWdleCA9IC8lKC0pPygwP1swLTldKyk/KFsuXVswLTldKyk/KFsjXVswLTldKyk/KFtzY2ZwZXhkJV0pL2c7CgkgICAgICAgIHJldHVybiBhcHBlbmQucmVwbGFjZShyZWdleCwgY2FsbGJhY2spOwoJICAgIH07CgkgICAgLyoqCgkgICAgICoKCSAgICAgKi8KCSAgICBTdHJpbmdVdGlscy5nZXRCeXRlcyA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7CgkgICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZ18xJDEuZGVmYXVsdC5lbmNvZGUoc3RyLCBlbmNvZGluZyk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBSZXR1cm5zIHRoZSBjaGFyY29kZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIGF0IGluZGV4IHplcm8uCgkgICAgICovCgkgICAgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUgPSBmdW5jdGlvbiAoc3RyLCBpbmRleCkgewoJICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH0KCSAgICAgICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KGluZGV4KTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgY2hhciBmb3IgZ2l2ZW4gY2hhcmNvZGUKCSAgICAgKi8KCSAgICBTdHJpbmdVdGlscy5nZXRDaGFyQXQgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHsKCSAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpOwoJICAgIH07CgkgICAgU3RyaW5nVXRpbHMuU0hJRlRfSklTID0gQ2hhcmFjdGVyU2V0RUNJXzEkMS5kZWZhdWx0LlNKSVMuZ2V0TmFtZSgpOyAvLyAiU0pJUyIKCSAgICBTdHJpbmdVdGlscy5HQjIzMTIgPSAnR0IyMzEyJzsKCSAgICBTdHJpbmdVdGlscy5JU084ODU5MSA9IENoYXJhY3RlclNldEVDSV8xJDEuZGVmYXVsdC5JU084ODU5XzEuZ2V0TmFtZSgpOyAvLyAiSVNPODg1OV8xIgoJICAgIFN0cmluZ1V0aWxzLkVVQ19KUCA9ICdFVUNfSlAnOwoJICAgIFN0cmluZ1V0aWxzLlVURjggPSBDaGFyYWN0ZXJTZXRFQ0lfMSQxLmRlZmF1bHQuVVRGOC5nZXROYW1lKCk7IC8vICJVVEY4IgoJICAgIFN0cmluZ1V0aWxzLlBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcgPSBTdHJpbmdVdGlscy5VVEY4OyAvLyAiVVRGOCIvL0NoYXJzZXQuZGVmYXVsdENoYXJzZXQoKS5uYW1lKCkKCSAgICBTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTID0gZmFsc2U7CgkgICAgcmV0dXJuIFN0cmluZ1V0aWxzOwoJfSgpKTsKCVN0cmluZ1V0aWxzJDEuZGVmYXVsdCA9IFN0cmluZ1V0aWxzOwoKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmdCdWlsZGVyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBTdHJpbmdVdGlsc18xJDEgPSBTdHJpbmdVdGlscyQxOwoJdmFyIFN0cmluZ0J1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcih2YWx1ZSkgewoJICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9ICcnOyB9CgkgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTsKCSAgICB9CgkgICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuZW5hYmxlRGVjb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHsKCSAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nOwoJICAgICAgICByZXR1cm4gdGhpczsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChzKSB7CgkgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHsKCSAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gcy50b1N0cmluZygpOwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgaWYgKHRoaXMuZW5jb2RpbmcpIHsKCSAgICAgICAgICAgIC8vIHVzZSBwYXNzZWQgZm9ybWF0IChmcm9tQ2hhckNvZGUgd2lsbCByZXR1cm4gVVRGOCBlbmNvZGluZykKCSAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gU3RyaW5nVXRpbHNfMSQxLmRlZmF1bHQuY2FzdEFzTm9uVXRmOENoYXIocywgdGhpcy5lbmNvZGluZyk7CgkgICAgICAgIH0KCSAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAvLyBjb3JyZWN0bHkgY29udmVydHMgZnJvbSBVVEYtOCwgYnV0IG5vdCBvdGhlciBlbmNvZGluZ3MKCSAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gdGhpczsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmFwcGVuZENoYXJzID0gZnVuY3Rpb24gKHN0ciwgb2Zmc2V0LCBsZW4pIHsKCSAgICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgb2Zmc2V0IDwgb2Zmc2V0ICsgbGVuOyBpKyspIHsKCSAgICAgICAgICAgIHRoaXMuYXBwZW5kKHN0cltpXSk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRoaXM7CgkgICAgfTsKCSAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmxlbmd0aDsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmNoYXJBdCA9IGZ1bmN0aW9uIChuKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmNoYXJBdChuKTsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmRlbGV0ZUNoYXJBdCA9IGZ1bmN0aW9uIChuKSB7CgkgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIHRoaXMudmFsdWUuc3Vic3RyaW5nKG4gKyAxKTsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnNldENoYXJBdCA9IGZ1bmN0aW9uIChuLCBjKSB7CgkgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIGMgKyB0aGlzLnZhbHVlLnN1YnN0cihuICsgMSk7CgkgICAgfTsKCSAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5zdWJzdHJpbmcgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkgewoJICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAbm90ZSBoZWxwZXIgbWV0aG9kIGZvciBSU1MgRXhwYW5kZWQKCSAgICAgKi8KCSAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5zZXRMZW5ndGhUb1plcm8gPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHRoaXMudmFsdWUgPSAnJzsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTsKCSAgICB9OwoJICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChuLCBjKSB7CgkgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIGMgKyB0aGlzLnZhbHVlLnN1YnN0cihuICsgYy5sZW5ndGgpOwoJICAgIH07CgkgICAgcmV0dXJuIFN0cmluZ0J1aWxkZXI7Cgl9KCkpOwoJU3RyaW5nQnVpbGRlciQxLmRlZmF1bHQgPSBTdHJpbmdCdWlsZGVyOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoQml0TWF0cml4JDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJLyppbXBvcnQgamF2YS51dGlsLkFycmF5czsqLwoJdmFyIEJpdEFycmF5XzEkMSA9IEJpdEFycmF5JDE7Cgl2YXIgU3lzdGVtXzEkMyA9IFN5c3RlbSQxOwoJdmFyIEFycmF5c18xID0gQXJyYXlzJDE7Cgl2YXIgU3RyaW5nQnVpbGRlcl8xJDIgPSBTdHJpbmdCdWlsZGVyJDE7Cgl2YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNyA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiA8cD5SZXByZXNlbnRzIGEgMkQgbWF0cml4IG9mIGJpdHMuIEluIGZ1bmN0aW9uIGFyZ3VtZW50cyBiZWxvdywgYW5kIHRocm91Z2hvdXQgdGhlIGNvbW1vbgoJICogbW9kdWxlLCB4IGlzIHRoZSBjb2x1bW4gcG9zaXRpb24sIGFuZCB5IGlzIHRoZSByb3cgcG9zaXRpb24uIFRoZSBvcmRlcmluZyBpcyBhbHdheXMgeCwgeS4KCSAqIFRoZSBvcmlnaW4gaXMgYXQgdGhlIHRvcC1sZWZ0LjwvcD4KCSAqCgkgKiA8cD5JbnRlcm5hbGx5IHRoZSBiaXRzIGFyZSByZXByZXNlbnRlZCBpbiBhIDEtRCBhcnJheSBvZiAzMi1iaXQgaW50cy4gSG93ZXZlciwgZWFjaCByb3cgYmVnaW5zCgkgKiB3aXRoIGEgbmV3IGludC4gVGhpcyBpcyBkb25lIGludGVudGlvbmFsbHkgc28gdGhhdCB3ZSBjYW4gY29weSBvdXQgYSByb3cgaW50byBhIEJpdEFycmF5IHZlcnkKCSAqIGVmZmljaWVudGx5LjwvcD4KCSAqCgkgKiA8cD5UaGUgb3JkZXJpbmcgb2YgYml0cyBpcyByb3ctbWFqb3IuIFdpdGhpbiBlYWNoIGludCwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgYXJlIHVzZWQgZmlyc3QsCgkgKiBtZWFuaW5nIHRoZXkgcmVwcmVzZW50IGxvd2VyIHggdmFsdWVzLiBUaGlzIGlzIGNvbXBhdGlibGUgd2l0aCBCaXRBcnJheSdzIGltcGxlbWVudGF0aW9uLjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikKCSAqLwoJdmFyIEJpdE1hdHJpeCAvKmltcGxlbWVudHMgQ2xvbmVhYmxlKi8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgLyoqCgkgICAgICogQ3JlYXRlcyBhbiBlbXB0eSBzcXVhcmUge0BsaW5rIEJpdE1hdHJpeH0uCgkgICAgICoKCSAgICAgKiBAcGFyYW0gZGltZW5zaW9uIGhlaWdodCBhbmQgd2lkdGgKCSAgICAgKi8KCSAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoZGltZW5zaW9uOiBudW1iZXIgLyppbnQqLykgewoJICAgIC8vICAgdGhpcyhkaW1lbnNpb24sIGRpbWVuc2lvbikKCSAgICAvLyB9CgkgICAgLyoqCgkgICAgICogQ3JlYXRlcyBhbiBlbXB0eSB7QGxpbmsgQml0TWF0cml4fS4KCSAgICAgKgoJICAgICAqIEBwYXJhbSB3aWR0aCBiaXQgbWF0cml4IHdpZHRoCgkgICAgICogQHBhcmFtIGhlaWdodCBiaXQgbWF0cml4IGhlaWdodAoJICAgICAqLwoJICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pIHsKCSAgICAvLyAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSkgewoJICAgIC8vICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCJCb3RoIGRpbWVuc2lvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCIpCgkgICAgLy8gICB9CgkgICAgLy8gICB0aGlzLndpZHRoID0gd2lkdGgKCSAgICAvLyAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0CgkgICAgLy8gICB0aGlzLnJvd1NpemUgPSAod2lkdGggKyAzMSkgLyAzMgoJICAgIC8vICAgYml0cyA9IG5ldyBpbnRbcm93U2l6ZSAqIGhlaWdodF07CgkgICAgLy8gfQoJICAgIGZ1bmN0aW9uIEJpdE1hdHJpeCh3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcm93U2l6ZSAvKmludCovLCBiaXRzKSB7CgkgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDsKCSAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7CgkgICAgICAgIHRoaXMucm93U2l6ZSA9IHJvd1NpemU7CgkgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7CgkgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGhlaWdodCB8fCBudWxsID09PSBoZWlnaHQpIHsKCSAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0OwoJICAgICAgICBpZiAod2lkdGggPCAxIHx8IGhlaWdodCA8IDEpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ3LmRlZmF1bHQoJ0JvdGggZGltZW5zaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcm93U2l6ZSB8fCBudWxsID09PSByb3dTaXplKSB7CgkgICAgICAgICAgICByb3dTaXplID0gTWF0aC5mbG9vcigod2lkdGggKyAzMSkgLyAzMik7CgkgICAgICAgIH0KCSAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTsKCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7CgkgICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLnJvd1NpemUgKiB0aGlzLmhlaWdodCk7CgkgICAgICAgIH0KCSAgICB9CgkgICAgLyoqCgkgICAgICogSW50ZXJwcmV0cyBhIDJEIGFycmF5IG9mIGJvb2xlYW5zIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0sIHdoZXJlICJ0cnVlIiBtZWFucyBhbiAib24iIGJpdC4KCSAgICAgKgoJICAgICAqIEBmdW5jdGlvbiBwYXJzZQoJICAgICAqIEBwYXJhbSBpbWFnZSBiaXRzIG9mIHRoZSBpbWFnZSwgYXMgYSByb3ctbWFqb3IgMkQgYXJyYXkuIEVsZW1lbnRzIGFyZSBhcnJheXMgcmVwcmVzZW50aW5nIHJvd3MKCSAgICAgKiBAcmV0dXJuIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGF0aW9uIG9mIGltYWdlCgkgICAgICovCgkgICAgQml0TWF0cml4LnBhcnNlRnJvbUJvb2xlYW5BcnJheSA9IGZ1bmN0aW9uIChpbWFnZSkgewoJICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UubGVuZ3RoOwoJICAgICAgICB2YXIgd2lkdGggPSBpbWFnZVswXS5sZW5ndGg7CgkgICAgICAgIHZhciBiaXRzID0gbmV3IEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KTsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykgewoJICAgICAgICAgICAgdmFyIGltYWdlSSA9IGltYWdlW2ldOwoJICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7CgkgICAgICAgICAgICAgICAgaWYgKGltYWdlSVtqXSkgewoJICAgICAgICAgICAgICAgICAgICBiaXRzLnNldChqLCBpKTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGJpdHM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKgoJICAgICAqIEBmdW5jdGlvbiBwYXJzZQoJICAgICAqIEBwYXJhbSBzdHJpbmdSZXByZXNlbnRhdGlvbgoJICAgICAqIEBwYXJhbSBzZXRTdHJpbmcKCSAgICAgKiBAcGFyYW0gdW5zZXRTdHJpbmcKCSAgICAgKi8KCSAgICBCaXRNYXRyaXgucGFyc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZ1JlcHJlc2VudGF0aW9uLCBzZXRTdHJpbmcsIHVuc2V0U3RyaW5nKSB7CgkgICAgICAgIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbiA9PT0gbnVsbCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDcuZGVmYXVsdCgnc3RyaW5nUmVwcmVzZW50YXRpb24gY2Fubm90IGJlIG51bGwnKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgYml0cyA9IG5ldyBBcnJheShzdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGgpOwoJICAgICAgICB2YXIgYml0c1BvcyA9IDA7CgkgICAgICAgIHZhciByb3dTdGFydFBvcyA9IDA7CgkgICAgICAgIHZhciByb3dMZW5ndGggPSAtMTsKCSAgICAgICAgdmFyIG5Sb3dzID0gMDsKCSAgICAgICAgdmFyIHBvcyA9IDA7CgkgICAgICAgIHdoaWxlIChwb3MgPCBzdHJpbmdSZXByZXNlbnRhdGlvbi5sZW5ndGgpIHsKCSAgICAgICAgICAgIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5jaGFyQXQocG9zKSA9PT0gJ1xuJyB8fAoJICAgICAgICAgICAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXHInKSB7CgkgICAgICAgICAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykgewoJICAgICAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoID09PSAtMSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgcm93TGVuZ3RoID0gYml0c1BvcyAtIHJvd1N0YXJ0UG9zOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJpdHNQb3MgLSByb3dTdGFydFBvcyAhPT0gcm93TGVuZ3RoKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNy5kZWZhdWx0KCdyb3cgbGVuZ3RocyBkbyBub3QgbWF0Y2gnKTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICByb3dTdGFydFBvcyA9IGJpdHNQb3M7CgkgICAgICAgICAgICAgICAgICAgIG5Sb3dzKys7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIHBvcysrOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgc2V0U3RyaW5nLmxlbmd0aCkgPT09IHNldFN0cmluZykgewoJICAgICAgICAgICAgICAgIHBvcyArPSBzZXRTdHJpbmcubGVuZ3RoOwoJICAgICAgICAgICAgICAgIGJpdHNbYml0c1Bvc10gPSB0cnVlOwoJICAgICAgICAgICAgICAgIGJpdHNQb3MrKzsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uLnN1YnN0cmluZyhwb3MsIHBvcyArIHVuc2V0U3RyaW5nLmxlbmd0aCkgPT09IHVuc2V0U3RyaW5nKSB7CgkgICAgICAgICAgICAgICAgcG9zICs9IHVuc2V0U3RyaW5nLmxlbmd0aDsKCSAgICAgICAgICAgICAgICBiaXRzW2JpdHNQb3NdID0gZmFsc2U7CgkgICAgICAgICAgICAgICAgYml0c1BvcysrOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDcuZGVmYXVsdCgnaWxsZWdhbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQ6ICcgKyBzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zKSk7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gbm8gRU9MIGF0IGVuZD8KCSAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykgewoJICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHsKCSAgICAgICAgICAgICAgICByb3dMZW5ndGggPSBiaXRzUG9zIC0gcm93U3RhcnRQb3M7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkgewoJICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ3LmRlZmF1bHQoJ3JvdyBsZW5ndGhzIGRvIG5vdCBtYXRjaCcpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgblJvd3MrKzsKCSAgICAgICAgfQoJICAgICAgICB2YXIgbWF0cml4ID0gbmV3IEJpdE1hdHJpeChyb3dMZW5ndGgsIG5Sb3dzKTsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzUG9zOyBpKyspIHsKCSAgICAgICAgICAgIGlmIChiaXRzW2ldKSB7CgkgICAgICAgICAgICAgICAgbWF0cml4LnNldChNYXRoLmZsb29yKGkgJSByb3dMZW5ndGgpLCBNYXRoLmZsb29yKGkgLyByb3dMZW5ndGgpKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gbWF0cml4OwoJICAgIH07CgkgICAgLyoqCgkgICAgICogPHA+R2V0cyB0aGUgcmVxdWVzdGVkIGJpdCwgd2hlcmUgdHJ1ZSBtZWFucyBibGFjay48L3A+CgkgICAgICoKCSAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggY29sdW1uKQoJICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KQoJICAgICAqIEByZXR1cm4gdmFsdWUgb2YgZ2l2ZW4gYml0IGluIG1hdHJpeAoJICAgICAqLwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7CgkgICAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpOwoJICAgICAgICByZXR1cm4gKCh0aGlzLmJpdHNbb2Zmc2V0XSA+Pj4gKHggJiAweDFmKSkgJiAxKSAhPT0gMDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPlNldHMgdGhlIGdpdmVuIGJpdCB0byB0cnVlLjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pCgkgICAgICogQHBhcmFtIHkgVGhlIHZlcnRpY2FsIGNvbXBvbmVudCAoaS5lLiB3aGljaCByb3cpCgkgICAgICovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoeCAvKmludCovLCB5IC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7CgkgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIHw9ICgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRjsKCSAgICB9OwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiAoeCAvKmludCovLCB5IC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7CgkgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdICY9IH4oKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPkZsaXBzIHRoZSBnaXZlbiBiaXQuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbikKCSAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgY29tcG9uZW50IChpLmUuIHdoaWNoIHJvdykKCSAgICAgKi8KCSAgICBCaXRNYXRyaXgucHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbiAoeCAvKmludCovLCB5IC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7CgkgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIF49ICgoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogRXhjbHVzaXZlLW9yIChYT1IpOiBGbGlwIHRoZSBiaXQgaW4gdGhpcyB7QGNvZGUgQml0TWF0cml4fSBpZiB0aGUgY29ycmVzcG9uZGluZwoJICAgICAqIG1hc2sgYml0IGlzIHNldC4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBtYXNrIFhPUiBtYXNrCgkgICAgICovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAobWFzaykgewoJICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbWFzay5nZXRXaWR0aCgpIHx8IHRoaXMuaGVpZ2h0ICE9PSBtYXNrLmdldEhlaWdodCgpCgkgICAgICAgICAgICB8fCB0aGlzLnJvd1NpemUgIT09IG1hc2suZ2V0Um93U2l6ZSgpKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNy5kZWZhdWx0KCdpbnB1dCBtYXRyaXggZGltZW5zaW9ucyBkbyBub3QgbWF0Y2gnKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgcm93QXJyYXkgPSBuZXcgQml0QXJyYXlfMSQxLmRlZmF1bHQoTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMzIpICsgMSk7CgkgICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplOwoJICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0czsKCSAgICAgICAgZm9yICh2YXIgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHsKCSAgICAgICAgICAgIHZhciBvZmZzZXQgPSB5ICogcm93U2l6ZTsKCSAgICAgICAgICAgIHZhciByb3cgPSBtYXNrLmdldFJvdyh5LCByb3dBcnJheSkuZ2V0Qml0QXJyYXkoKTsKCSAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcm93U2l6ZTsgeCsrKSB7CgkgICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyB4XSBePSByb3dbeF07CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICB9OwoJICAgIC8qKgoJICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuCgkgICAgICovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7CgkgICAgICAgIHZhciBtYXggPSBiaXRzLmxlbmd0aDsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykgewoJICAgICAgICAgICAgYml0c1tpXSA9IDA7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPlNldHMgYSBzcXVhcmUgcmVnaW9uIG9mIHRoZSBiaXQgbWF0cml4IHRvIHRydWUuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGxlZnQgVGhlIGhvcml6b250YWwgcG9zaXRpb24gdG8gYmVnaW4gYXQgKGluY2x1c2l2ZSkKCSAgICAgKiBAcGFyYW0gdG9wIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKQoJICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlZ2lvbgoJICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVnaW9uCgkgICAgICovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKHRvcCA8IDAgfHwgbGVmdCA8IDApIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ3LmRlZmF1bHQoJ0xlZnQgYW5kIHRvcCBtdXN0IGJlIG5vbm5lZ2F0aXZlJyk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGhlaWdodCA8IDEgfHwgd2lkdGggPCAxKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNy5kZWZhdWx0KCdIZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgYXQgbGVhc3QgMScpOwoJICAgICAgICB9CgkgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDsKCSAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDsKCSAgICAgICAgaWYgKGJvdHRvbSA+IHRoaXMuaGVpZ2h0IHx8IHJpZ2h0ID4gdGhpcy53aWR0aCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDcuZGVmYXVsdCgnVGhlIHJlZ2lvbiBtdXN0IGZpdCBpbnNpZGUgdGhlIG1hdHJpeCcpOwoJICAgICAgICB9CgkgICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplOwoJICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0czsKCSAgICAgICAgZm9yICh2YXIgeSA9IHRvcDsgeSA8IGJvdHRvbTsgeSsrKSB7CgkgICAgICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHJvd1NpemU7CgkgICAgICAgICAgICBmb3IgKHZhciB4ID0gbGVmdDsgeCA8IHJpZ2h0OyB4KyspIHsKCSAgICAgICAgICAgICAgICBiaXRzW29mZnNldCArIE1hdGguZmxvb3IoeCAvIDMyKV0gfD0gKCgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRik7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEEgZmFzdCBtZXRob2QgdG8gcmV0cmlldmUgb25lIHJvdyBvZiBkYXRhIGZyb20gdGhlIG1hdHJpeCBhcyBhIEJpdEFycmF5LgoJICAgICAqCgkgICAgICogQHBhcmFtIHkgVGhlIHJvdyB0byByZXRyaWV2ZQoJICAgICAqIEBwYXJhbSByb3cgQW4gb3B0aW9uYWwgY2FsbGVyLWFsbG9jYXRlZCBCaXRBcnJheSwgd2lsbCBiZSBhbGxvY2F0ZWQgaWYgbnVsbCBvciB0b28gc21hbGwKCSAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQml0QXJyYXkgLSB0aGlzIHJlZmVyZW5jZSBzaG91bGQgYWx3YXlzIGJlIHVzZWQgZXZlbiB3aGVuIHBhc3NpbmcKCSAgICAgKiAgICAgICAgIHlvdXIgb3duIHJvdwoJICAgICAqLwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7CgkgICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93LmdldFNpemUoKSA8IHRoaXMud2lkdGgpIHsKCSAgICAgICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheV8xJDEuZGVmYXVsdCh0aGlzLndpZHRoKTsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgIHJvdy5jbGVhcigpOwoJICAgICAgICB9CgkgICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplOwoJICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0czsKCSAgICAgICAgdmFyIG9mZnNldCA9IHkgKiByb3dTaXplOwoJICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHJvd1NpemU7IHgrKykgewoJICAgICAgICAgICAgcm93LnNldEJ1bGsoeCAqIDMyLCBiaXRzW29mZnNldCArIHhdKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gcm93OwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHBhcmFtIHkgcm93IHRvIHNldAoJICAgICAqIEBwYXJhbSByb3cge0BsaW5rIEJpdEFycmF5fSB0byBjb3B5IGZyb20KCSAgICAgKi8KCSAgICBCaXRNYXRyaXgucHJvdG90eXBlLnNldFJvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykgewoJICAgICAgICBTeXN0ZW1fMSQzLmRlZmF1bHQuYXJyYXljb3B5KHJvdy5nZXRCaXRBcnJheSgpLCAwLCB0aGlzLmJpdHMsIHkgKiB0aGlzLnJvd1NpemUsIHRoaXMucm93U2l6ZSk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBNb2RpZmllcyB0aGlzIHtAY29kZSBCaXRNYXRyaXh9IHRvIHJlcHJlc2VudCB0aGUgc2FtZSBidXQgcm90YXRlZCAxODAgZGVncmVlcwoJICAgICAqLwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUucm90YXRlMTgwID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7CgkgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpOwoJICAgICAgICB2YXIgdG9wUm93ID0gbmV3IEJpdEFycmF5XzEkMS5kZWZhdWx0KHdpZHRoKTsKCSAgICAgICAgdmFyIGJvdHRvbVJvdyA9IG5ldyBCaXRBcnJheV8xJDEuZGVmYXVsdCh3aWR0aCk7CgkgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IE1hdGguZmxvb3IoKGhlaWdodCArIDEpIC8gMik7IGkgPCBsZW5ndGhfMTsgaSsrKSB7CgkgICAgICAgICAgICB0b3BSb3cgPSB0aGlzLmdldFJvdyhpLCB0b3BSb3cpOwoJICAgICAgICAgICAgYm90dG9tUm93ID0gdGhpcy5nZXRSb3coaGVpZ2h0IC0gMSAtIGksIGJvdHRvbVJvdyk7CgkgICAgICAgICAgICB0b3BSb3cucmV2ZXJzZSgpOwoJICAgICAgICAgICAgYm90dG9tUm93LnJldmVyc2UoKTsKCSAgICAgICAgICAgIHRoaXMuc2V0Um93KGksIGJvdHRvbVJvdyk7CgkgICAgICAgICAgICB0aGlzLnNldFJvdyhoZWlnaHQgLSAxIC0gaSwgdG9wUm93KTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgLyoqCgkgICAgICogVGhpcyBpcyB1c2VmdWwgaW4gZGV0ZWN0aW5nIHRoZSBlbmNsb3NpbmcgcmVjdGFuZ2xlIG9mIGEgJ3B1cmUnIGJhcmNvZGUuCgkgICAgICoKCSAgICAgKiBAcmV0dXJuIHtAY29kZSBsZWZ0LHRvcCx3aWR0aCxoZWlnaHR9IGVuY2xvc2luZyByZWN0YW5nbGUgb2YgYWxsIDEgYml0cywgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGUKCSAgICAgKi8KCSAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldEVuY2xvc2luZ1JlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDsKCSAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0OwoJICAgICAgICB2YXIgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTsKCSAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7CgkgICAgICAgIHZhciBsZWZ0ID0gd2lkdGg7CgkgICAgICAgIHZhciB0b3AgPSBoZWlnaHQ7CgkgICAgICAgIHZhciByaWdodCA9IC0xOwoJICAgICAgICB2YXIgYm90dG9tID0gLTE7CgkgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHsKCSAgICAgICAgICAgIGZvciAodmFyIHgzMiA9IDA7IHgzMiA8IHJvd1NpemU7IHgzMisrKSB7CgkgICAgICAgICAgICAgICAgdmFyIHRoZUJpdHMgPSBiaXRzW3kgKiByb3dTaXplICsgeDMyXTsKCSAgICAgICAgICAgICAgICBpZiAodGhlQml0cyAhPT0gMCkgewoJICAgICAgICAgICAgICAgICAgICBpZiAoeSA8IHRvcCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0geTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICBpZiAoeSA+IGJvdHRvbSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0geTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICBpZiAoeDMyICogMzIgPCBsZWZ0KSB7CgkgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gMDsKCSAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoKHRoZUJpdHMgPDwgKDMxIC0gYml0KSkgJiAweEZGRkZGRkZGKSA9PT0gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCsrOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh4MzIgKiAzMiArIGJpdCkgPCBsZWZ0KSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHgzMiAqIDMyICsgYml0OwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIGlmICh4MzIgKiAzMiArIDMxID4gcmlnaHQpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXQgPSAzMTsKCSAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgodGhlQml0cyA+Pj4gYml0KSA9PT0gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdC0tOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh4MzIgKiAzMiArIGJpdCkgPiByaWdodCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0geDMyICogMzIgKyBiaXQ7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHJpZ2h0IDwgbGVmdCB8fCBib3R0b20gPCB0b3ApIHsKCSAgICAgICAgICAgIHJldHVybiBudWxsOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW2xlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0ICsgMSwgYm90dG9tIC0gdG9wICsgMV0pOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogVGhpcyBpcyB1c2VmdWwgaW4gZGV0ZWN0aW5nIGEgY29ybmVyIG9mIGEgJ3B1cmUnIGJhcmNvZGUuCgkgICAgICoKCSAgICAgKiBAcmV0dXJuIHtAY29kZSB4LHl9IGNvb3JkaW5hdGUgb2YgdG9wLWxlZnQtbW9zdCAxIGJpdCwgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGUKCSAgICAgKi8KCSAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldFRvcExlZnRPbkJpdCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIHJvd1NpemUgPSB0aGlzLnJvd1NpemU7CgkgICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzOwoJICAgICAgICB2YXIgYml0c09mZnNldCA9IDA7CgkgICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0IDwgYml0cy5sZW5ndGggJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkgewoJICAgICAgICAgICAgYml0c09mZnNldCsrOwoJICAgICAgICB9CgkgICAgICAgIGlmIChiaXRzT2Zmc2V0ID09PSBiaXRzLmxlbmd0aCkgewoJICAgICAgICAgICAgcmV0dXJuIG51bGw7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHkgPSBiaXRzT2Zmc2V0IC8gcm93U2l6ZTsKCSAgICAgICAgdmFyIHggPSAoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7CgkgICAgICAgIHZhciB0aGVCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTsKCSAgICAgICAgdmFyIGJpdCA9IDA7CgkgICAgICAgIHdoaWxlICgoKHRoZUJpdHMgPDwgKDMxIC0gYml0KSkgJiAweEZGRkZGRkZGKSA9PT0gMCkgewoJICAgICAgICAgICAgYml0Kys7CgkgICAgICAgIH0KCSAgICAgICAgeCArPSBiaXQ7CgkgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3gsIHldKTsKCSAgICB9OwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0Qm90dG9tUmlnaHRPbkJpdCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIHJvd1NpemUgPSB0aGlzLnJvd1NpemU7CgkgICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzOwoJICAgICAgICB2YXIgYml0c09mZnNldCA9IGJpdHMubGVuZ3RoIC0gMTsKCSAgICAgICAgd2hpbGUgKGJpdHNPZmZzZXQgPj0gMCAmJiBiaXRzW2JpdHNPZmZzZXRdID09PSAwKSB7CgkgICAgICAgICAgICBiaXRzT2Zmc2V0LS07CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGJpdHNPZmZzZXQgPCAwKSB7CgkgICAgICAgICAgICByZXR1cm4gbnVsbDsKCSAgICAgICAgfQoJICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoYml0c09mZnNldCAvIHJvd1NpemUpOwoJICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7CgkgICAgICAgIHZhciB0aGVCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTsKCSAgICAgICAgdmFyIGJpdCA9IDMxOwoJICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHsKCSAgICAgICAgICAgIGJpdC0tOwoJICAgICAgICB9CgkgICAgICAgIHggKz0gYml0OwoJICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFt4LCB5XSk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgbWF0cml4CgkgICAgICovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIFRoZSBoZWlnaHQgb2YgdGhlIG1hdHJpeAoJICAgICAqLwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIFRoZSByb3cgc2l6ZSBvZiB0aGUgbWF0cml4CgkgICAgICovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRSb3dTaXplID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5yb3dTaXplOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHsKCSAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEJpdE1hdHJpeCkpIHsKCSAgICAgICAgICAgIHJldHVybiBmYWxzZTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgb3RoZXIgPSBvOwoJICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodCAmJiB0aGlzLnJvd1NpemUgPT09IG90aGVyLnJvd1NpemUgJiYKCSAgICAgICAgICAgIEFycmF5c18xLmRlZmF1bHQuZXF1YWxzKHRoaXMuYml0cywgb3RoZXIuYml0cyk7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIGhhc2ggPSB0aGlzLndpZHRoOwoJICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy53aWR0aDsKCSAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHRoaXMuaGVpZ2h0OwoJICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy5yb3dTaXplOwoJICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgQXJyYXlzXzEuZGVmYXVsdC5oYXNoQ29kZSh0aGlzLmJpdHMpOwoJICAgICAgICByZXR1cm4gaGFzaDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nICJYIiBmb3Igc2V0IGFuZCAiICIgZm9yIHVuc2V0IGJpdHMKCSAgICAgKi8KCSAgICAvKkBPdmVycmlkZSovCgkgICAgLy8gcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7CgkgICAgLy8gICByZXR1cm4gdG9TdHJpbmcoIjogIlgsICIgICIpCgkgICAgLy8gfQoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0CgkgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdAoJICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVudGlyZSBtYXRyaXggdXRpbGl6aW5nIGdpdmVuIHN0cmluZ3MKCSAgICAgKi8KCSAgICAvLyBwdWJsaWMgdG9TdHJpbmcoc2V0U3RyaW5nOiBzdHJpbmcgPSAiWCAiLCB1bnNldFN0cmluZzogc3RyaW5nID0gIiAgIik6IHN0cmluZyB7CgkgICAgLy8gICByZXR1cm4gdGhpcy5idWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsICJcbiIpCgkgICAgLy8gfQoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0CgkgICAgICogQHBhcmFtIHVuc2V0U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2V0IGJpdAoJICAgICAqIEBwYXJhbSBsaW5lU2VwYXJhdG9yIG5ld2xpbmUgY2hhcmFjdGVyIGluIHN0cmluZyByZXByZXNlbnRhdGlvbgoJICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVudGlyZSBtYXRyaXggdXRpbGl6aW5nIGdpdmVuIHN0cmluZ3MgYW5kIGxpbmUgc2VwYXJhdG9yCgkgICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgI3RvU3RyaW5nKFN0cmluZyxTdHJpbmcpfSBvbmx5LCB3aGljaCB1c2VzIFxuIGxpbmUgc2VwYXJhdG9yIGFsd2F5cwoJICAgICAqLwoJICAgIC8vIEBEZXByZWNhdGVkCgkgICAgQml0TWF0cml4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChzZXRTdHJpbmcsIHVuc2V0U3RyaW5nLCBsaW5lU2VwYXJhdG9yKSB7CgkgICAgICAgIGlmIChzZXRTdHJpbmcgPT09IHZvaWQgMCkgeyBzZXRTdHJpbmcgPSAnWCAnOyB9CgkgICAgICAgIGlmICh1bnNldFN0cmluZyA9PT0gdm9pZCAwKSB7IHVuc2V0U3RyaW5nID0gJyAgJzsgfQoJICAgICAgICBpZiAobGluZVNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IGxpbmVTZXBhcmF0b3IgPSAnXG4nOyB9CgkgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcik7CgkgICAgfTsKCSAgICBCaXRNYXRyaXgucHJvdG90eXBlLmJ1aWxkVG9TdHJpbmcgPSBmdW5jdGlvbiAoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcikgewoJICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMSQyLmRlZmF1bHQoKTsKCSAgICAgICAgLy8gcmVzdWx0LmFwcGVuZChsaW5lU2VwYXJhdG9yKTsKCSAgICAgICAgZm9yICh2YXIgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspIHsKCSAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB3aWR0aCA9IHRoaXMud2lkdGg7IHggPCB3aWR0aDsgeCsrKSB7CgkgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLmdldCh4LCB5KSA/IHNldFN0cmluZyA6IHVuc2V0U3RyaW5nKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQobGluZVNlcGFyYXRvcik7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiBuZXcgQml0TWF0cml4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJvd1NpemUsIHRoaXMuYml0cy5zbGljZSgpKTsKCSAgICB9OwoJICAgIHJldHVybiBCaXRNYXRyaXg7Cgl9KCkpOwoJQml0TWF0cml4JDEuZGVmYXVsdCA9IEJpdE1hdHJpeDsKCgl2YXIgTm90Rm91bmRFeGNlcHRpb24kMSA9IHt9OwoKCXZhciBfX2V4dGVuZHMkZCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb3RGb3VuZEV4Y2VwdGlvbiQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgRXhjZXB0aW9uXzEkNSA9IEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uCgkgKi8KCXZhciBOb3RGb3VuZEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkZChOb3RGb3VuZEV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBOb3RGb3VuZEV4Y2VwdGlvbigpIHsKCSAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoJICAgIH0KCSAgICBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7CgkgICAgfTsKCSAgICBOb3RGb3VuZEV4Y2VwdGlvbi5raW5kID0gJ05vdEZvdW5kRXhjZXB0aW9uJzsKCSAgICByZXR1cm4gTm90Rm91bmRFeGNlcHRpb247Cgl9KEV4Y2VwdGlvbl8xJDUuZGVmYXVsdCkpOwoJTm90Rm91bmRFeGNlcHRpb24kMS5kZWZhdWx0ID0gTm90Rm91bmRFeGNlcHRpb247CgoJLyoKCSAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCXZhciBfX2V4dGVuZHMkYyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovCgl2YXIgQmluYXJpemVyXzEgPSBCaW5hcml6ZXIkMTsKCXZhciBCaXRBcnJheV8xID0gQml0QXJyYXkkMTsKCXZhciBCaXRNYXRyaXhfMSQ1ID0gQml0TWF0cml4JDE7Cgl2YXIgTm90Rm91bmRFeGNlcHRpb25fMSQ2ID0gTm90Rm91bmRFeGNlcHRpb24kMTsKCS8qKgoJICogVGhpcyBCaW5hcml6ZXIgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgb2xkIFpYaW5nIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guIEl0IGlzIHN1aXRhYmxlCgkgKiBmb3IgbG93LWVuZCBtb2JpbGUgZGV2aWNlcyB3aGljaCBkb24ndCBoYXZlIGVub3VnaCBDUFUgb3IgbWVtb3J5IHRvIHVzZSBhIGxvY2FsIHRocmVzaG9sZGluZwoJICogYWxnb3JpdGhtLiBIb3dldmVyLCBiZWNhdXNlIGl0IHBpY2tzIGEgZ2xvYmFsIGJsYWNrIHBvaW50LCBpdCBjYW5ub3QgaGFuZGxlIGRpZmZpY3VsdCBzaGFkb3dzCgkgKiBhbmQgZ3JhZGllbnRzLgoJICoKCSAqIEZhc3RlciBtb2JpbGUgZGV2aWNlcyBhbmQgYWxsIGRlc2t0b3AgYXBwbGljYXRpb25zIHNob3VsZCBwcm9iYWJseSB1c2UgSHlicmlkQmluYXJpemVyIGluc3RlYWQuCgkgKgoJICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJGMoR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCBfc3VwZXIpOwoJICAgIGZ1bmN0aW9uIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcihzb3VyY2UpIHsKCSAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc291cmNlKSB8fCB0aGlzOwoJICAgICAgICBfdGhpcy5sdW1pbmFuY2VzID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkVNUFRZOwoJICAgICAgICBfdGhpcy5idWNrZXRzID0gbmV3IEludDMyQXJyYXkoR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CVUNLRVRTKTsKCSAgICAgICAgcmV0dXJuIF90aGlzOwoJICAgIH0KCSAgICAvLyBBcHBsaWVzIHNpbXBsZSBzaGFycGVuaW5nIHRvIHRoZSByb3cgZGF0YSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSAxRCBSZWFkZXJzLgoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIucHJvdG90eXBlLmdldEJsYWNrUm93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7CgkgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpOwoJICAgICAgICB2YXIgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdyA9PT0gbnVsbCB8fCByb3cuZ2V0U2l6ZSgpIDwgd2lkdGgpIHsKCSAgICAgICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQod2lkdGgpOwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgcm93LmNsZWFyKCk7CgkgICAgICAgIH0KCSAgICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTsKCSAgICAgICAgdmFyIGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3coeSwgdGhpcy5sdW1pbmFuY2VzKTsKCSAgICAgICAgdmFyIGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0czsKCSAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7CgkgICAgICAgICAgICBsb2NhbEJ1Y2tldHNbKGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmYpID4+IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlRdKys7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGJsYWNrUG9pbnQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7CgkgICAgICAgIGlmICh3aWR0aCA8IDMpIHsKCSAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdmVyeSBzbWFsbCBpbWFnZXMKCSAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykgewoJICAgICAgICAgICAgICAgIGlmICgobG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZikgPCBibGFja1BvaW50KSB7CgkgICAgICAgICAgICAgICAgICAgIHJvdy5zZXQoeCk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgdmFyIGxlZnQgPSBsb2NhbEx1bWluYW5jZXNbMF0gJiAweGZmOwoJICAgICAgICAgICAgdmFyIGNlbnRlciA9IGxvY2FsTHVtaW5hbmNlc1sxXSAmIDB4ZmY7CgkgICAgICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbG9jYWxMdW1pbmFuY2VzW3ggKyAxXSAmIDB4ZmY7CgkgICAgICAgICAgICAgICAgLy8gQSBzaW1wbGUgLTEgNCAtMSBib3ggZmlsdGVyIHdpdGggYSB3ZWlnaHQgb2YgMi4KCSAgICAgICAgICAgICAgICBpZiAoKChjZW50ZXIgKiA0KSAtIGxlZnQgLSByaWdodCkgLyAyIDwgYmxhY2tQb2ludCkgewoJICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBsZWZ0ID0gY2VudGVyOwoJICAgICAgICAgICAgICAgIGNlbnRlciA9IHJpZ2h0OwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiByb3c7CgkgICAgfTsKCSAgICAvLyBEb2VzIG5vdCBzaGFycGVuIHRoZSBkYXRhLCBhcyB0aGlzIGNhbGwgaXMgaW50ZW5kZWQgdG8gb25seSBiZSB1c2VkIGJ5IDJEIFJlYWRlcnMuCgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5wcm90b3R5cGUuZ2V0QmxhY2tNYXRyaXggPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpOwoJICAgICAgICB2YXIgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgdmFyIGhlaWdodCA9IHNvdXJjZS5nZXRIZWlnaHQoKTsKCSAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBCaXRNYXRyaXhfMSQ1LmRlZmF1bHQod2lkdGgsIGhlaWdodCk7CgkgICAgICAgIC8vIFF1aWNrbHkgY2FsY3VsYXRlcyB0aGUgaGlzdG9ncmFtIGJ5IHNhbXBsaW5nIGZvdXIgcm93cyBmcm9tIHRoZSBpbWFnZS4gVGhpcyBwcm92ZWQgdG8gYmUKCSAgICAgICAgLy8gbW9yZSByb2J1c3Qgb24gdGhlIGJsYWNrYm94IHRlc3RzIHRoYW4gc2FtcGxpbmcgYSBkaWFnb25hbCBhcyB3ZSB1c2VkIHRvIGRvLgoJICAgICAgICB0aGlzLmluaXRBcnJheXMod2lkdGgpOwoJICAgICAgICB2YXIgbG9jYWxCdWNrZXRzID0gdGhpcy5idWNrZXRzOwoJICAgICAgICBmb3IgKHZhciB5ID0gMTsgeSA8IDU7IHkrKykgewoJICAgICAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoKGhlaWdodCAqIHkpIC8gNSk7CgkgICAgICAgICAgICB2YXIgbG9jYWxMdW1pbmFuY2VzXzEgPSBzb3VyY2UuZ2V0Um93KHJvdywgdGhpcy5sdW1pbmFuY2VzKTsKCSAgICAgICAgICAgIHZhciByaWdodCA9IE1hdGguZmxvb3IoKHdpZHRoICogNCkgLyA1KTsKCSAgICAgICAgICAgIGZvciAodmFyIHggPSBNYXRoLmZsb29yKHdpZHRoIC8gNSk7IHggPCByaWdodDsgeCsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzXzFbeF0gJiAweGZmOwoJICAgICAgICAgICAgICAgIGxvY2FsQnVja2V0c1twaXhlbCA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHZhciBibGFja1BvaW50ID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmVzdGltYXRlQmxhY2tQb2ludChsb2NhbEJ1Y2tldHMpOwoJICAgICAgICAvLyBXZSBkZWxheSByZWFkaW5nIHRoZSBlbnRpcmUgaW1hZ2UgbHVtaW5hbmNlIHVudGlsIHRoZSBibGFjayBwb2ludCBlc3RpbWF0aW9uIHN1Y2NlZWRzLgoJICAgICAgICAvLyBBbHRob3VnaCB3ZSBlbmQgdXAgcmVhZGluZyBmb3VyIHJvd3MgdHdpY2UsIGl0IGlzIGNvbnNpc3RlbnQgd2l0aCBvdXIgbW90dG8gb2YKCSAgICAgICAgLy8gImZhaWwgcXVpY2tseSIgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBjb250aW51b3VzIHNjYW5uaW5nLgoJICAgICAgICB2YXIgbG9jYWxMdW1pbmFuY2VzID0gc291cmNlLmdldE1hdHJpeCgpOwoJICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7CgkgICAgICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHdpZHRoOwoJICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhmZjsKCSAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPCBibGFja1BvaW50KSB7CgkgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoeCwgeSk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBtYXRyaXg7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLnByb3RvdHlwZS5jcmVhdGVCaW5hcml6ZXIgPSBmdW5jdGlvbiAoc291cmNlKSB7CgkgICAgICAgIHJldHVybiBuZXcgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyKHNvdXJjZSk7CgkgICAgfTsKCSAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIucHJvdG90eXBlLmluaXRBcnJheXMgPSBmdW5jdGlvbiAobHVtaW5hbmNlU2l6ZSAvKmludCovKSB7CgkgICAgICAgIGlmICh0aGlzLmx1bWluYW5jZXMubGVuZ3RoIDwgbHVtaW5hbmNlU2l6ZSkgewoJICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGx1bWluYW5jZVNpemUpOwoJICAgICAgICB9CgkgICAgICAgIHZhciBidWNrZXRzID0gdGhpcy5idWNrZXRzOwoJICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUzsgeCsrKSB7CgkgICAgICAgICAgICBidWNrZXRzW3hdID0gMDsKCSAgICAgICAgfQoJICAgIH07CgkgICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmVzdGltYXRlQmxhY2tQb2ludCA9IGZ1bmN0aW9uIChidWNrZXRzKSB7CgkgICAgICAgIC8vIEZpbmQgdGhlIHRhbGxlc3QgcGVhayBpbiB0aGUgaGlzdG9ncmFtLgoJICAgICAgICB2YXIgbnVtQnVja2V0cyA9IGJ1Y2tldHMubGVuZ3RoOwoJICAgICAgICB2YXIgbWF4QnVja2V0Q291bnQgPSAwOwoJICAgICAgICB2YXIgZmlyc3RQZWFrID0gMDsKCSAgICAgICAgdmFyIGZpcnN0UGVha1NpemUgPSAwOwoJICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykgewoJICAgICAgICAgICAgaWYgKGJ1Y2tldHNbeF0gPiBmaXJzdFBlYWtTaXplKSB7CgkgICAgICAgICAgICAgICAgZmlyc3RQZWFrID0geDsKCSAgICAgICAgICAgICAgICBmaXJzdFBlYWtTaXplID0gYnVja2V0c1t4XTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGlmIChidWNrZXRzW3hdID4gbWF4QnVja2V0Q291bnQpIHsKCSAgICAgICAgICAgICAgICBtYXhCdWNrZXRDb3VudCA9IGJ1Y2tldHNbeF07CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gRmluZCB0aGUgc2Vjb25kLXRhbGxlc3QgcGVhayB3aGljaCBpcyBzb21ld2hhdCBmYXIgZnJvbSB0aGUgdGFsbGVzdCBwZWFrLgoJICAgICAgICB2YXIgc2Vjb25kUGVhayA9IDA7CgkgICAgICAgIHZhciBzZWNvbmRQZWFrU2NvcmUgPSAwOwoJICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykgewoJICAgICAgICAgICAgdmFyIGRpc3RhbmNlVG9CaWdnZXN0ID0geCAtIGZpcnN0UGVhazsKCSAgICAgICAgICAgIC8vIEVuY291cmFnZSBtb3JlIGRpc3RhbnQgc2Vjb25kIHBlYWtzIGJ5IG11bHRpcGx5aW5nIGJ5IHNxdWFyZSBvZiBkaXN0YW5jZS4KCSAgICAgICAgICAgIHZhciBzY29yZSA9IGJ1Y2tldHNbeF0gKiBkaXN0YW5jZVRvQmlnZ2VzdCAqIGRpc3RhbmNlVG9CaWdnZXN0OwoJICAgICAgICAgICAgaWYgKHNjb3JlID4gc2Vjb25kUGVha1Njb3JlKSB7CgkgICAgICAgICAgICAgICAgc2Vjb25kUGVhayA9IHg7CgkgICAgICAgICAgICAgICAgc2Vjb25kUGVha1Njb3JlID0gc2NvcmU7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gTWFrZSBzdXJlIGZpcnN0UGVhayBjb3JyZXNwb25kcyB0byB0aGUgYmxhY2sgcGVhay4KCSAgICAgICAgaWYgKGZpcnN0UGVhayA+IHNlY29uZFBlYWspIHsKCSAgICAgICAgICAgIHZhciB0ZW1wID0gZmlyc3RQZWFrOwoJICAgICAgICAgICAgZmlyc3RQZWFrID0gc2Vjb25kUGVhazsKCSAgICAgICAgICAgIHNlY29uZFBlYWsgPSB0ZW1wOwoJICAgICAgICB9CgkgICAgICAgIC8vIElmIHRoZXJlIGlzIHRvbyBsaXR0bGUgY29udHJhc3QgaW4gdGhlIGltYWdlIHRvIHBpY2sgYSBtZWFuaW5nZnVsIGJsYWNrIHBvaW50LCB0aHJvdyByYXRoZXIKCSAgICAgICAgLy8gdGhhbiB3YXN0ZSB0aW1lIHRyeWluZyB0byBkZWNvZGUgdGhlIGltYWdlLCBhbmQgcmlzayBmYWxzZSBwb3NpdGl2ZXMuCgkgICAgICAgIGlmIChzZWNvbmRQZWFrIC0gZmlyc3RQZWFrIDw9IG51bUJ1Y2tldHMgLyAxNikgewoJICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEkNi5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gRmluZCBhIHZhbGxleSBiZXR3ZWVuIHRoZW0gdGhhdCBpcyBsb3cgYW5kIGNsb3NlciB0byB0aGUgd2hpdGUgcGVhay4KCSAgICAgICAgdmFyIGJlc3RWYWxsZXkgPSBzZWNvbmRQZWFrIC0gMTsKCSAgICAgICAgdmFyIGJlc3RWYWxsZXlTY29yZSA9IC0xOwoJICAgICAgICBmb3IgKHZhciB4ID0gc2Vjb25kUGVhayAtIDE7IHggPiBmaXJzdFBlYWs7IHgtLSkgewoJICAgICAgICAgICAgdmFyIGZyb21GaXJzdCA9IHggLSBmaXJzdFBlYWs7CgkgICAgICAgICAgICB2YXIgc2NvcmUgPSBmcm9tRmlyc3QgKiBmcm9tRmlyc3QgKiAoc2Vjb25kUGVhayAtIHgpICogKG1heEJ1Y2tldENvdW50IC0gYnVja2V0c1t4XSk7CgkgICAgICAgICAgICBpZiAoc2NvcmUgPiBiZXN0VmFsbGV5U2NvcmUpIHsKCSAgICAgICAgICAgICAgICBiZXN0VmFsbGV5ID0geDsKCSAgICAgICAgICAgICAgICBiZXN0VmFsbGV5U2NvcmUgPSBzY29yZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gYmVzdFZhbGxleSA8PCBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUOwoJICAgIH07CgkgICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTID0gNTsKCSAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUID0gOCAtIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUzsKCSAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFMgPSAxIDw8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUzsKCSAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuRU1QVFkgPSBVaW50OENsYW1wZWRBcnJheS5mcm9tKFswXSk7CgkgICAgcmV0dXJuIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcjsKCX0oQmluYXJpemVyXzEuZGVmYXVsdCkpOwoJR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyJDEuZGVmYXVsdCA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcjsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fZXh0ZW5kcyRiID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKCSAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHwKCSAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9OwoJICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICB9OwoJICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH0KCSAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpOwoJICAgIH07Cgl9KSgpOwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEh5YnJpZEJpbmFyaXplciQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXzEgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIkMTsKCXZhciBCaXRNYXRyaXhfMSQ0ID0gQml0TWF0cml4JDE7CgkvKioKCSAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIGxvY2FsIHRocmVzaG9sZGluZyBhbGdvcml0aG0sIHdoaWNoIHdoaWxlIHNsb3dlciB0aGFuIHRoZQoJICogR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCBpcyBmYWlybHkgZWZmaWNpZW50IGZvciB3aGF0IGl0IGRvZXMuIEl0IGlzIGRlc2lnbmVkIGZvcgoJICogaGlnaCBmcmVxdWVuY3kgaW1hZ2VzIG9mIGJhcmNvZGVzIHdpdGggYmxhY2sgZGF0YSBvbiB3aGl0ZSBiYWNrZ3JvdW5kcy4gRm9yIHRoaXMgYXBwbGljYXRpb24sCgkgKiBpdCBkb2VzIGEgbXVjaCBiZXR0ZXIgam9iIHRoYW4gYSBnbG9iYWwgYmxhY2twb2ludCB3aXRoIHNldmVyZSBzaGFkb3dzIGFuZCBncmFkaWVudHMuCgkgKiBIb3dldmVyIGl0IHRlbmRzIHRvIHByb2R1Y2UgYXJ0aWZhY3RzIG9uIGxvd2VyIGZyZXF1ZW5jeSBpbWFnZXMgYW5kIGlzIHRoZXJlZm9yZSBub3QKCSAqIGEgZ29vZCBnZW5lcmFsIHB1cnBvc2UgYmluYXJpemVyIGZvciB1c2VzIG91dHNpZGUgWlhpbmcuCgkgKgoJICogVGhpcyBjbGFzcyBleHRlbmRzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgdXNpbmcgdGhlIG9sZGVyIGhpc3RvZ3JhbSBhcHByb2FjaCBmb3IgMUQgcmVhZGVycywKCSAqIGFuZCB0aGUgbmV3ZXIgbG9jYWwgYXBwcm9hY2ggZm9yIDJEIHJlYWRlcnMuIDFEIGRlY29kaW5nIHVzaW5nIGEgcGVyLXJvdyBoaXN0b2dyYW0gaXMgYWxyZWFkeQoJICogaW5oZXJlbnRseSBsb2NhbCwgYW5kIG9ubHkgZmFpbHMgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzLiBXZSBjYW4gcmV2aXNpdCB0aGF0IHByb2JsZW0gbGF0ZXIsCgkgKiBidXQgZm9yIG5vdyBpdCB3YXMgbm90IGEgd2luIHRvIHVzZSBsb2NhbCBibG9ja3MgZm9yIDFELgoJICoKCSAqIFRoaXMgQmluYXJpemVyIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdW5pdCB0ZXN0cyBhbmQgdGhlIHJlY29tbWVuZGVkIGNsYXNzIGZvciBsaWJyYXJ5IHVzZXJzLgoJICoKCSAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pCgkgKi8KCXZhciBIeWJyaWRCaW5hcml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJGIoSHlicmlkQmluYXJpemVyLCBfc3VwZXIpOwoJICAgIGZ1bmN0aW9uIEh5YnJpZEJpbmFyaXplcihzb3VyY2UpIHsKCSAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc291cmNlKSB8fCB0aGlzOwoJICAgICAgICBfdGhpcy5tYXRyaXggPSBudWxsOwoJICAgICAgICByZXR1cm4gX3RoaXM7CgkgICAgfQoJICAgIC8qKgoJICAgICAqIENhbGN1bGF0ZXMgdGhlIGZpbmFsIEJpdE1hdHJpeCBvbmNlIGZvciBhbGwgcmVxdWVzdHMuIFRoaXMgY291bGQgYmUgY2FsbGVkIG9uY2UgZnJvbSB0aGUKCSAgICAgKiBjb25zdHJ1Y3RvciBpbnN0ZWFkLCBidXQgdGhlcmUgYXJlIHNvbWUgYWR2YW50YWdlcyB0byBkb2luZyBpdCBsYXppbHksIHN1Y2ggYXMgbWFraW5nCgkgICAgICogcHJvZmlsaW5nIGVhc2llciwgYW5kIG5vdCBkb2luZyBoZWF2eSBsaWZ0aW5nIHdoZW4gY2FsbGVycyBkb24ndCBleHBlY3QgaXQuCgkgICAgICovCgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEh5YnJpZEJpbmFyaXplci5wcm90b3R5cGUuZ2V0QmxhY2tNYXRyaXggPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIGlmICh0aGlzLm1hdHJpeCAhPT0gbnVsbCkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4OwoJICAgICAgICB9CgkgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpOwoJICAgICAgICB2YXIgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgdmFyIGhlaWdodCA9IHNvdXJjZS5nZXRIZWlnaHQoKTsKCSAgICAgICAgaWYgKHdpZHRoID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTiAmJiBoZWlnaHQgPj0gSHlicmlkQmluYXJpemVyLk1JTklNVU1fRElNRU5TSU9OKSB7CgkgICAgICAgICAgICB2YXIgbHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTsKCSAgICAgICAgICAgIHZhciBzdWJXaWR0aCA9IHdpZHRoID4+IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSOwoJICAgICAgICAgICAgaWYgKCh3aWR0aCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7CgkgICAgICAgICAgICAgICAgc3ViV2lkdGgrKzsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHZhciBzdWJIZWlnaHQgPSBoZWlnaHQgPj4gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7CgkgICAgICAgICAgICBpZiAoKGhlaWdodCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7CgkgICAgICAgICAgICAgICAgc3ViSGVpZ2h0Kys7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB2YXIgYmxhY2tQb2ludHMgPSBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlQmxhY2tQb2ludHMobHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCwgd2lkdGgsIGhlaWdodCk7CgkgICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gbmV3IEJpdE1hdHJpeF8xJDQuZGVmYXVsdCh3aWR0aCwgaGVpZ2h0KTsKCSAgICAgICAgICAgIEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVUaHJlc2hvbGRGb3JCbG9jayhsdW1pbmFuY2VzLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBibGFja1BvaW50cywgbmV3TWF0cml4KTsKCSAgICAgICAgICAgIHRoaXMubWF0cml4ID0gbmV3TWF0cml4OwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgLy8gSWYgdGhlIGltYWdlIGlzIHRvbyBzbWFsbCwgZmFsbCBiYWNrIHRvIHRoZSBnbG9iYWwgaGlzdG9ncmFtIGFwcHJvYWNoLgoJICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBfc3VwZXIucHJvdG90eXBlLmdldEJsYWNrTWF0cml4LmNhbGwodGhpcyk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4OwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEh5YnJpZEJpbmFyaXplci5wcm90b3R5cGUuY3JlYXRlQmluYXJpemVyID0gZnVuY3Rpb24gKHNvdXJjZSkgewoJICAgICAgICByZXR1cm4gbmV3IEh5YnJpZEJpbmFyaXplcihzb3VyY2UpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogRm9yIGVhY2ggYmxvY2sgaW4gdGhlIGltYWdlLCBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgYmxhY2sgcG9pbnQgdXNpbmcgYSA1eDUgZ3JpZAoJICAgICAqIG9mIHRoZSBibG9ja3MgYXJvdW5kIGl0LiBBbHNvIGhhbmRsZXMgdGhlIGNvcm5lciBjYXNlcyAoZnJhY3Rpb25hbCBibG9ja3MgYXJlIGNvbXB1dGVkIGJhc2VkCgkgICAgICogb24gdGhlIGxhc3QgcGl4ZWxzIGluIHRoZSByb3cvY29sdW1uIHdoaWNoIGFyZSBhbHNvIHVzZWQgaW4gdGhlIHByZXZpb3VzIGJsb2NrKS4KCSAgICAgKi8KCSAgICBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlVGhyZXNob2xkRm9yQmxvY2sgPSBmdW5jdGlvbiAobHVtaW5hbmNlcywgc3ViV2lkdGggLyppbnQqLywgc3ViSGVpZ2h0IC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBibGFja1BvaW50cywgbWF0cml4KSB7CgkgICAgICAgIHZhciBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7CgkgICAgICAgIHZhciBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsKCSAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzdWJIZWlnaHQ7IHkrKykgewoJICAgICAgICAgICAgdmFyIHlvZmZzZXQgPSB5IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSOwoJICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7CgkgICAgICAgICAgICAgICAgeW9mZnNldCA9IG1heFlPZmZzZXQ7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB2YXIgdG9wXzEgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHksIDIsIHN1YkhlaWdodCAtIDMpOwoJICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzdWJXaWR0aDsgeCsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIHhvZmZzZXQgPSB4IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSOwoJICAgICAgICAgICAgICAgIGlmICh4b2Zmc2V0ID4gbWF4WE9mZnNldCkgewoJICAgICAgICAgICAgICAgICAgICB4b2Zmc2V0ID0gbWF4WE9mZnNldDsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHgsIDIsIHN1YldpZHRoIC0gMyk7CgkgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7CgkgICAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IC0yOyB6IDw9IDI7IHorKykgewoJICAgICAgICAgICAgICAgICAgICB2YXIgYmxhY2tSb3cgPSBibGFja1BvaW50c1t0b3BfMSArIHpdOwoJICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYmxhY2tSb3dbbGVmdCAtIDJdICsgYmxhY2tSb3dbbGVmdCAtIDFdICsgYmxhY2tSb3dbbGVmdF0gKyBibGFja1Jvd1tsZWZ0ICsgMV0gKyBibGFja1Jvd1tsZWZ0ICsgMl07CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIHZhciBhdmVyYWdlID0gc3VtIC8gMjU7CgkgICAgICAgICAgICAgICAgSHlicmlkQmluYXJpemVyLnRocmVzaG9sZEJsb2NrKGx1bWluYW5jZXMsIHhvZmZzZXQsIHlvZmZzZXQsIGF2ZXJhZ2UsIHdpZHRoLCBtYXRyaXgpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgfTsKCSAgICBIeWJyaWRCaW5hcml6ZXIuY2FwID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8sIG1pbiAvKmludCovLCBtYXggLyppbnQqLykgewoJICAgICAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQXBwbGllcyBhIHNpbmdsZSB0aHJlc2hvbGQgdG8gYSBibG9jayBvZiBwaXhlbHMuCgkgICAgICovCgkgICAgSHlicmlkQmluYXJpemVyLnRocmVzaG9sZEJsb2NrID0gZnVuY3Rpb24gKGx1bWluYW5jZXMsIHhvZmZzZXQgLyppbnQqLywgeW9mZnNldCAvKmludCovLCB0aHJlc2hvbGQgLyppbnQqLywgc3RyaWRlIC8qaW50Ki8sIG1hdHJpeCkgewoJICAgICAgICBmb3IgKHZhciB5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHN0cmlkZSArIHhvZmZzZXQ7IHkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeSsrLCBvZmZzZXQgKz0gc3RyaWRlKSB7CgkgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB4KyspIHsKCSAgICAgICAgICAgICAgICAvLyBDb21wYXJpc29uIG5lZWRzIHRvIGJlIDw9IHNvIHRoYXQgYmxhY2sgPT0gMCBwaXhlbHMgYXJlIGJsYWNrIGV2ZW4gaWYgdGhlIHRocmVzaG9sZCBpcyAwLgoJICAgICAgICAgICAgICAgIGlmICgobHVtaW5hbmNlc1tvZmZzZXQgKyB4XSAmIDB4RkYpIDw9IHRocmVzaG9sZCkgewoJICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHhvZmZzZXQgKyB4LCB5b2Zmc2V0ICsgeSk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBDYWxjdWxhdGVzIGEgc2luZ2xlIGJsYWNrIHBvaW50IGZvciBlYWNoIGJsb2NrIG9mIHBpeGVscyBhbmQgc2F2ZXMgaXQgYXdheS4KCSAgICAgKiBTZWUgdGhlIGZvbGxvd2luZyB0aHJlYWQgZm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGlzIGFsZ29yaXRobToKCSAgICAgKiAgaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2dyb3VwL3p4aW5nL2Jyb3dzZV90aHJlYWQvdGhyZWFkL2QwNmVmYTJjMzVhN2RkYzAKCSAgICAgKi8KCSAgICBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlQmxhY2tQb2ludHMgPSBmdW5jdGlvbiAobHVtaW5hbmNlcywgc3ViV2lkdGggLyppbnQqLywgc3ViSGVpZ2h0IC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7CgkgICAgICAgIHZhciBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7CgkgICAgICAgIHZhciBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsKCSAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOndoaXRlc3BhY2UKCSAgICAgICAgdmFyIGJsYWNrUG9pbnRzID0gbmV3IEFycmF5KHN1YkhlaWdodCk7IC8vIHN1YldpZHRoCgkgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc3ViSGVpZ2h0OyB5KyspIHsKCSAgICAgICAgICAgIGJsYWNrUG9pbnRzW3ldID0gbmV3IEludDMyQXJyYXkoc3ViV2lkdGgpOwoJICAgICAgICAgICAgdmFyIHlvZmZzZXQgPSB5IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSOwoJICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7CgkgICAgICAgICAgICAgICAgeW9mZnNldCA9IG1heFlPZmZzZXQ7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHsKCSAgICAgICAgICAgICAgICB2YXIgeG9mZnNldCA9IHggPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7CgkgICAgICAgICAgICAgICAgaWYgKHhvZmZzZXQgPiBtYXhYT2Zmc2V0KSB7CgkgICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0OwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDsKCSAgICAgICAgICAgICAgICB2YXIgbWluID0gMHhGRjsKCSAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMDsKCSAgICAgICAgICAgICAgICBmb3IgKHZhciB5eSA9IDAsIG9mZnNldCA9IHlvZmZzZXQgKiB3aWR0aCArIHhvZmZzZXQ7IHl5IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHl5KyssIG9mZnNldCArPSB3aWR0aCkgewoJICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4eCA9IDA7IHh4IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHh4KyspIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjsKCSAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBwaXhlbDsKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIGxvb2tpbmcgZm9yIGdvb2QgY29udHJhc3QKCSAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA8IG1pbikgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHBpeGVsOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsID4gbWF4KSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcGl4ZWw7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBtaW4vbWF4IHRlc3RzIG9uY2UgZHluYW1pYyByYW5nZSBpcyBtZXQKCSAgICAgICAgICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA+IEh5YnJpZEJpbmFyaXplci5NSU5fRFlOQU1JQ19SQU5HRSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluaXNoIHRoZSByZXN0IG9mIHRoZSByb3dzIHF1aWNrbHkKCSAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeXkrKywgb2Zmc2V0ICs9IHdpZHRoOyB5eSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4eCA9IDA7IHh4IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHh4KyspIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgZXN0aW1hdGUgaXMgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHZhbHVlcyBpbiB0aGUgYmxvY2suCgkgICAgICAgICAgICAgICAgdmFyIGF2ZXJhZ2UgPSBzdW0gPj4gKEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSICogMik7CgkgICAgICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA8PSBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UpIHsKCSAgICAgICAgICAgICAgICAgICAgLy8gSWYgdmFyaWF0aW9uIHdpdGhpbiB0aGUgYmxvY2sgaXMgbG93LCBhc3N1bWUgdGhpcyBpcyBhIGJsb2NrIHdpdGggb25seSBsaWdodCBvciBvbmx5CgkgICAgICAgICAgICAgICAgICAgIC8vIGRhcmsgcGl4ZWxzLiBJbiB0aGF0IGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gdXNlIHRoZSBhdmVyYWdlLCBhcyBpdCB3b3VsZCBkaXZpZGUgdGhpcwoJICAgICAgICAgICAgICAgICAgICAvLyBsb3cgY29udHJhc3QgYXJlYSBpbnRvIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMsIGVzc2VudGlhbGx5IGNyZWF0aW5nIGRhdGEgb3V0IG9mIG5vaXNlLgoJICAgICAgICAgICAgICAgICAgICAvLwoJICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGJsb2NrIGlzIGxpZ2h0L2JhY2tncm91bmQuIFNpbmNlIG5vIGVzdGltYXRlIGZvcgoJICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGV2ZWwgb2YgZGFyayBwaXhlbHMgZXhpc3RzIGxvY2FsbHksIHVzZSBoYWxmIHRoZSBtaW4gZm9yIHRoZSBibG9jay4KCSAgICAgICAgICAgICAgICAgICAgYXZlcmFnZSA9IG1pbiAvIDI7CgkgICAgICAgICAgICAgICAgICAgIGlmICh5ID4gMCAmJiB4ID4gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB0aGUgIndoaXRlIGJhY2tncm91bmQiIGFzc3VtcHRpb24gZm9yIGJsb2NrcyB0aGF0IGhhdmUgbmVpZ2hib3JzIGJ5IGNvbXBhcmluZwoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBpeGVscyBpbiB0aGlzIGJsb2NrIHRvIHRoZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQgYmxhY2sgcG9pbnRzLiBUaGlzIGlzIGJhc2VkIG9uCgkgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IGRhcmsgYmFyY29kZSBzeW1ib2xvZ3kgaXMgYWx3YXlzIHN1cnJvdW5kZWQgYnkgc29tZSBhbW91bnQgb2YgbGlnaHQKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2tncm91bmQgZm9yIHdoaWNoIHJlYXNvbmFibGUgYmxhY2sgcG9pbnQgZXN0aW1hdGVzIHdlcmUgbWFkZS4gVGhlIGJwIGVzdGltYXRlZCBhdAoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJvdW5kYXJpZXMgaXMgdXNlZCBmb3IgdGhlIGludGVyaW9yLgoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIChtaW4gPCBicCkgaXMgYXJiaXRyYXJ5IGJ1dCB3b3JrcyBiZXR0ZXIgdGhhbiBvdGhlciBoZXVyaXN0aWNzIHRoYXQgd2VyZSB0cmllZC4KCSAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50ID0gKGJsYWNrUG9pbnRzW3kgLSAxXVt4XSArICgyICogYmxhY2tQb2ludHNbeV1beCAtIDFdKSArIGJsYWNrUG9pbnRzW3kgLSAxXVt4IC0gMV0pIC8gNDsKCSAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPCBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50KSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZSA9IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQ7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgYmxhY2tQb2ludHNbeV1beF0gPSBhdmVyYWdlOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBibGFja1BvaW50czsKCSAgICB9OwoJICAgIC8vIFRoaXMgY2xhc3MgdXNlcyA1eDUgYmxvY2tzIHRvIGNvbXB1dGUgbG9jYWwgbHVtaW5hbmNlLCB3aGVyZSBlYWNoIGJsb2NrIGlzIDh4OCBwaXhlbHMuCgkgICAgLy8gU28gdGhpcyBpcyB0aGUgc21hbGxlc3QgZGltZW5zaW9uIGluIGVhY2ggYXhpcyB3ZSBjYW4gYWNjZXB0LgoJICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSID0gMzsKCSAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSA9IDEgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7IC8vIC4uLjAxMDAuLi4wMAoJICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0sgPSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSAtIDE7IC8vIC4uLjAwMTEuLi4xMQoJICAgIEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTiA9IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFICogNTsKCSAgICBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UgPSAyNDsKCSAgICByZXR1cm4gSHlicmlkQmluYXJpemVyOwoJfShHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXJfMS5kZWZhdWx0KSk7Cgl2YXIgX2RlZmF1bHQkMiA9IEh5YnJpZEJpbmFyaXplciQxLmRlZmF1bHQgPSBIeWJyaWRCaW5hcml6ZXI7CgoJdmFyIFJHQkx1bWluYW5jZVNvdXJjZSQxID0ge307CgoJdmFyIEludmVydGVkTHVtaW5hbmNlU291cmNlJDEgPSB7fTsKCgl2YXIgTHVtaW5hbmNlU291cmNlJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEx1bWluYW5jZVNvdXJjZSQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgU3RyaW5nQnVpbGRlcl8xJDEgPSBTdHJpbmdCdWlsZGVyJDE7Cgl2YXIgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMSA9IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uJDE7CgkvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqLwoJLyoqCgkgKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNsYXNzIGhpZXJhcmNoeSBpcyB0byBhYnN0cmFjdCBkaWZmZXJlbnQgYml0bWFwIGltcGxlbWVudGF0aW9ucyBhY3Jvc3MKCSAqIHBsYXRmb3JtcyBpbnRvIGEgc3RhbmRhcmQgaW50ZXJmYWNlIGZvciByZXF1ZXN0aW5nIGdyZXlzY2FsZSBsdW1pbmFuY2UgdmFsdWVzLiBUaGUgaW50ZXJmYWNlCgkgKiBvbmx5IHByb3ZpZGVzIGltbXV0YWJsZSBtZXRob2RzOyB0aGVyZWZvcmUgY3JvcCBhbmQgcm90YXRpb24gY3JlYXRlIGNvcGllcy4gVGhpcyBpcyB0byBlbnN1cmUKCSAqIHRoYXQgb25lIFJlYWRlciBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGx1bWluYW5jZSBzb3VyY2UgYW5kIGxlYXZlIGl0IGluIGFuIHVua25vd24gc3RhdGUKCSAqIGZvciBvdGhlciBSZWFkZXJzIGluIHRoZSBjaGFpbi4KCSAqCgkgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKQoJICovCgl2YXIgTHVtaW5hbmNlU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIEx1bWluYW5jZVNvdXJjZSh3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykgewoJICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7CgkgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0OwoJICAgIH0KCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgYml0bWFwLgoJICAgICAqLwoJICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLndpZHRoOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBiaXRtYXAuCgkgICAgICovCgkgICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNyb3BwaW5nLgoJICAgICAqLwoJICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNDcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGNyb3BwZWQgaW1hZ2UgZGF0YS4gSW1wbGVtZW50YXRpb25zIG1heSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZQoJICAgICAqIG9yaWdpbmFsIGRhdGEgcmF0aGVyIHRoYW4gYSBjb3B5LiBPbmx5IGNhbGxhYmxlIGlmIGlzQ3JvcFN1cHBvcnRlZCgpIGlzIHRydWUuCgkgICAgICoKCSAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldFdpZHRoKCkpCgkgICAgICogQHBhcmFtIHRvcCBUaGUgdG9wIGNvb3JkaW5hdGUsIHdoaWNoIG11c3QgYmUgaW4gWzAsZ2V0SGVpZ2h0KCkpCgkgICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuCgkgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC4KCSAgICAgKiBAcmV0dXJuIEEgY3JvcHBlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LgoJICAgICAqLwoJICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuY3JvcCA9IGZ1bmN0aW9uIChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykgewoJICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMS5kZWZhdWx0KCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCBjcm9wcGluZy4nKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLgoJICAgICAqLwoJICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNSb3RhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiBmYWxzZTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS4KCSAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS4KCSAgICAgKgoJICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuCgkgICAgICovCgkgICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMS5kZWZhdWx0KCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbiBieSA5MCBkZWdyZWVzLicpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgNDUgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLgoJICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLgoJICAgICAqCgkgICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC4KCSAgICAgKi8KCSAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXzEuZGVmYXVsdCgnVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgNDUgZGVncmVlcy4nKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMud2lkdGgpOwoJICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMSQxLmRlZmF1bHQoKTsKCSAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7CgkgICAgICAgICAgICB2YXIgc291cmNlUm93ID0gdGhpcy5nZXRSb3coeSwgcm93KTsKCSAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIGx1bWluYW5jZSA9IHNvdXJjZVJvd1t4XSAmIDB4RkY7CgkgICAgICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDA7CgkgICAgICAgICAgICAgICAgaWYgKGx1bWluYW5jZSA8IDB4NDApIHsKCSAgICAgICAgICAgICAgICAgICAgYyA9ICcjJzsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZWxzZSBpZiAobHVtaW5hbmNlIDwgMHg4MCkgewoJICAgICAgICAgICAgICAgICAgICBjID0gJysnOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBlbHNlIGlmIChsdW1pbmFuY2UgPCAweEMwKSB7CgkgICAgICAgICAgICAgICAgICAgIGMgPSAnLic7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgICAgICAgICBjID0gJyAnOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGMpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXG4nKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7CgkgICAgfTsKCSAgICByZXR1cm4gTHVtaW5hbmNlU291cmNlOwoJfSgpKTsKCUx1bWluYW5jZVNvdXJjZSQxLmRlZmF1bHQgPSBMdW1pbmFuY2VTb3VyY2U7CgoJLyoKCSAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCXZhciBfX2V4dGVuZHMkYSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgTHVtaW5hbmNlU291cmNlXzEkMSA9IEx1bWluYW5jZVNvdXJjZSQxOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki8KCS8qKgoJICogQSB3cmFwcGVyIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBMdW1pbmFuY2VTb3VyY2V9IHdoaWNoIGludmVydHMgdGhlIGx1bWluYW5jZXMgaXQgcmV0dXJucyAtLSBibGFjayBiZWNvbWVzCgkgKiB3aGl0ZSBhbmQgdmljZSB2ZXJzYSwgYW5kIGVhY2ggdmFsdWUgYmVjb21lcyAoMjU1LXZhbHVlKS4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJGEoSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UsIF9zdXBlcik7CgkgICAgZnVuY3Rpb24gSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UoZGVsZWdhdGUpIHsKCSAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVsZWdhdGUuZ2V0V2lkdGgoKSwgZGVsZWdhdGUuZ2V0SGVpZ2h0KCkpIHx8IHRoaXM7CgkgICAgICAgIF90aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7CgkgICAgICAgIHJldHVybiBfdGhpczsKCSAgICB9CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHsKCSAgICAgICAgdmFyIHNvdXJjZVJvdyA9IHRoaXMuZGVsZWdhdGUuZ2V0Um93KHksIHJvdyk7CgkgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7CgkgICAgICAgICAgICBzb3VyY2VSb3dbaV0gPSAvKihieXRlKSovICgyNTUgLSAoc291cmNlUm93W2ldICYgMHhGRikpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBzb3VyY2VSb3c7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuZGVsZWdhdGUuZ2V0TWF0cml4KCk7CgkgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmdldEhlaWdodCgpOwoJICAgICAgICB2YXIgaW52ZXJ0ZWRNYXRyaXggPSBuZXcgVWludDhDbGFtcGVkQXJyYXkobGVuZ3RoKTsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewoJICAgICAgICAgICAgaW52ZXJ0ZWRNYXRyaXhbaV0gPSAvKihieXRlKSovICgyNTUgLSAobWF0cml4W2ldICYgMHhGRikpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBpbnZlcnRlZE1hdHJpeDsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNDcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5pc0Nyb3BTdXBwb3J0ZWQoKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuY3JvcCA9IGZ1bmN0aW9uIChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykgewoJICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUuY3JvcChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNSb3RhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzUm90YXRlU3VwcG9ydGVkKCk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIG9yaWdpbmFsIGRlbGVnYXRlIHtAbGluayBMdW1pbmFuY2VTb3VyY2V9IHNpbmNlIGludmVydCB1bmRvZXMgaXRzZWxmCgkgICAgICovCgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkpOwoJICAgIH07CgkgICAgcmV0dXJuIEludmVydGVkTHVtaW5hbmNlU291cmNlOwoJfShMdW1pbmFuY2VTb3VyY2VfMSQxLmRlZmF1bHQpKTsKCUludmVydGVkTHVtaW5hbmNlU291cmNlJDEuZGVmYXVsdCA9IEludmVydGVkTHVtaW5hbmNlU291cmNlOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCgl2YXIgX19leHRlbmRzJDkgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoUkdCTHVtaW5hbmNlU291cmNlJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovCgkgLy8gcmVxdWlyZWQgYmVjYXVzZSBvZiBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBMdW1pbmFuY2VTb3VyY2UgYW5kIEludmVydGVkTHVtaW5hbmNlU291cmNlCgl2YXIgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VfMSA9IEludmVydGVkTHVtaW5hbmNlU291cmNlJDE7Cgl2YXIgTHVtaW5hbmNlU291cmNlXzEgPSBMdW1pbmFuY2VTb3VyY2UkMTsKCXZhciBTeXN0ZW1fMSQyID0gU3lzdGVtJDE7Cgl2YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNiA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gaGVscCBkZWNvZGUgaW1hZ2VzIGZyb20gZmlsZXMgd2hpY2ggYXJyaXZlIGFzIFJHQiBkYXRhIGZyb20KCSAqIGFuIEFSR0IgcGl4ZWwgYXJyYXkuIEl0IGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24uCgkgKgoJICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikKCSAqIEBhdXRob3IgQmV0YW1pbm9zCgkgKi8KCXZhciBSR0JMdW1pbmFuY2VTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJDkoUkdCTHVtaW5hbmNlU291cmNlLCBfc3VwZXIpOwoJICAgIGZ1bmN0aW9uIFJHQkx1bWluYW5jZVNvdXJjZShsdW1pbmFuY2VzLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLykgewoJICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KSB8fCB0aGlzOwoJICAgICAgICBfdGhpcy5kYXRhV2lkdGggPSBkYXRhV2lkdGg7CgkgICAgICAgIF90aGlzLmRhdGFIZWlnaHQgPSBkYXRhSGVpZ2h0OwoJICAgICAgICBfdGhpcy5sZWZ0ID0gbGVmdDsKCSAgICAgICAgX3RoaXMudG9wID0gdG9wOwoJICAgICAgICBpZiAobHVtaW5hbmNlcy5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkgeyAvLyBJbnQzMkFycmF5CgkgICAgICAgICAgICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0OwoJICAgICAgICAgICAgdmFyIGx1bWluYW5jZXNVaW50OEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNpemUpOwoJICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgc2l6ZTsgb2Zmc2V0KyspIHsKCSAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBsdW1pbmFuY2VzW29mZnNldF07CgkgICAgICAgICAgICAgICAgdmFyIHIgPSAocGl4ZWwgPj4gMTYpICYgMHhmZjsgLy8gcmVkCgkgICAgICAgICAgICAgICAgdmFyIGcyID0gKHBpeGVsID4+IDcpICYgMHgxZmU7IC8vIDIgKiBncmVlbgoJICAgICAgICAgICAgICAgIHZhciBiID0gcGl4ZWwgJiAweGZmOyAvLyBibHVlCgkgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGdyZWVuLWZhdm91cmluZyBhdmVyYWdlIGNoZWFwbHkKCSAgICAgICAgICAgICAgICBsdW1pbmFuY2VzVWludDhBcnJheVtvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChyICsgZzIgKyBiKSAvIDQpICYgMHhGRjsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIF90aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzVWludDhBcnJheTsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgIF90aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzOwoJICAgICAgICB9CgkgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFXaWR0aCkgewoJICAgICAgICAgICAgX3RoaXMuZGF0YVdpZHRoID0gd2lkdGg7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGF0YUhlaWdodCkgewoJICAgICAgICAgICAgX3RoaXMuZGF0YUhlaWdodCA9IGhlaWdodDsKCSAgICAgICAgfQoJICAgICAgICBpZiAodW5kZWZpbmVkID09PSBsZWZ0KSB7CgkgICAgICAgICAgICBfdGhpcy5sZWZ0ID0gMDsKCSAgICAgICAgfQoJICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0b3ApIHsKCSAgICAgICAgICAgIF90aGlzLnRvcCA9IDA7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKF90aGlzLmxlZnQgKyB3aWR0aCA+IF90aGlzLmRhdGFXaWR0aCB8fCBfdGhpcy50b3AgKyBoZWlnaHQgPiBfdGhpcy5kYXRhSGVpZ2h0KSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNi5kZWZhdWx0KCdDcm9wIHJlY3RhbmdsZSBkb2VzIG5vdCBmaXQgd2l0aGluIGltYWdlIGRhdGEuJyk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIF90aGlzOwoJICAgIH0KCSAgICAvKkBPdmVycmlkZSovCgkgICAgUkdCTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHsKCSAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5nZXRIZWlnaHQoKSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDYuZGVmYXVsdCgnUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpOwoJICAgICAgICB9CgkgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTsKCSAgICAgICAgaWYgKHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHVuZGVmaW5lZCB8fCByb3cubGVuZ3RoIDwgd2lkdGgpIHsKCSAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIG9mZnNldCA9ICh5ICsgdGhpcy50b3ApICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7CgkgICAgICAgIFN5c3RlbV8xJDIuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5sdW1pbmFuY2VzLCBvZmZzZXQsIHJvdywgMCwgd2lkdGgpOwoJICAgICAgICByZXR1cm4gcm93OwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIFJHQkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7CgkgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpOwoJICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIGFza3MgZm9yIHRoZSBlbnRpcmUgdW5kZXJseWluZyBpbWFnZSwgc2F2ZSB0aGUgY29weSBhbmQgZ2l2ZSB0aGVtIHRoZQoJICAgICAgICAvLyBvcmlnaW5hbCBkYXRhLiBUaGUgZG9jcyBzcGVjaWZpY2FsbHkgd2FybiB0aGF0IHJlc3VsdC5sZW5ndGggbXVzdCBiZSBpZ25vcmVkLgoJICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5kYXRhSGVpZ2h0KSB7CgkgICAgICAgICAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VzOwoJICAgICAgICB9CgkgICAgICAgIHZhciBhcmVhID0gd2lkdGggKiBoZWlnaHQ7CgkgICAgICAgIHZhciBtYXRyaXggPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJlYSk7CgkgICAgICAgIHZhciBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7CgkgICAgICAgIC8vIElmIHRoZSB3aWR0aCBtYXRjaGVzIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEsIHBlcmZvcm0gYSBzaW5nbGUgY29weS4KCSAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCkgewoJICAgICAgICAgICAgU3lzdGVtXzEkMi5kZWZhdWx0LmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIDAsIGFyZWEpOwoJICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDsKCSAgICAgICAgfQoJICAgICAgICAvLyBPdGhlcndpc2UgY29weSBvbmUgY3JvcHBlZCByb3cgYXQgYSB0aW1lLgoJICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7CgkgICAgICAgICAgICB2YXIgb3V0cHV0T2Zmc2V0ID0geSAqIHdpZHRoOwoJICAgICAgICAgICAgU3lzdGVtXzEkMi5kZWZhdWx0LmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIG91dHB1dE9mZnNldCwgd2lkdGgpOwoJICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIG1hdHJpeDsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBSR0JMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRydWU7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgUkdCTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7CgkgICAgICAgIHJldHVybiBuZXcgUkdCTHVtaW5hbmNlU291cmNlKHRoaXMubHVtaW5hbmNlcywgd2lkdGgsIGhlaWdodCwgdGhpcy5kYXRhV2lkdGgsIHRoaXMuZGF0YUhlaWdodCwgdGhpcy5sZWZ0ICsgbGVmdCwgdGhpcy50b3AgKyB0b3ApOwoJICAgIH07CgkgICAgUkdCTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiBuZXcgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0KHRoaXMpOwoJICAgIH07CgkgICAgcmV0dXJuIFJHQkx1bWluYW5jZVNvdXJjZTsKCX0oTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCkpOwoJdmFyIF9kZWZhdWx0JDEgPSBSR0JMdW1pbmFuY2VTb3VyY2UkMS5kZWZhdWx0ID0gUkdCTHVtaW5hbmNlU291cmNlOwoKCXZhciBRUkNvZGVSZWFkZXIkMSA9IHt9OwoKCXZhciBCYXJjb2RlRm9ybWF0JDEgPSB7fTsKCgkvKgoJICogRGlyZWN0IHBvcnQgdG8gVHlwZVNjcmlwdCBvZiBaWGluZyBieSBBZHJpYW4gVG/ImWPEgwoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFyY29kZUZvcm1hdCQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKgoJICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki8KCS8qKgoJICogRW51bWVyYXRlcyBiYXJjb2RlIGZvcm1hdHMga25vd24gdG8gdGhpcyBwYWNrYWdlLiBQbGVhc2Uga2VlcCBhbHBoYWJldGl6ZWQuCgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEJhcmNvZGVGb3JtYXQ7CgkoZnVuY3Rpb24gKEJhcmNvZGVGb3JtYXQpIHsKCSAgICAvKiogQXp0ZWMgMkQgYmFyY29kZSBmb3JtYXQuICovCgkgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0WyJBWlRFQyJdID0gMF0gPSAiQVpURUMiOwoJICAgIC8qKiBDT0RBQkFSIDFEIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIkNPREFCQVIiXSA9IDFdID0gIkNPREFCQVIiOwoJICAgIC8qKiBDb2RlIDM5IDFEIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIkNPREVfMzkiXSA9IDJdID0gIkNPREVfMzkiOwoJICAgIC8qKiBDb2RlIDkzIDFEIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIkNPREVfOTMiXSA9IDNdID0gIkNPREVfOTMiOwoJICAgIC8qKiBDb2RlIDEyOCAxRCBmb3JtYXQuICovCgkgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0WyJDT0RFXzEyOCJdID0gNF0gPSAiQ09ERV8xMjgiOwoJICAgIC8qKiBEYXRhIE1hdHJpeCAyRCBiYXJjb2RlIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIkRBVEFfTUFUUklYIl0gPSA1XSA9ICJEQVRBX01BVFJJWCI7CgkgICAgLyoqIEVBTi04IDFEIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIkVBTl84Il0gPSA2XSA9ICJFQU5fOCI7CgkgICAgLyoqIEVBTi0xMyAxRCBmb3JtYXQuICovCgkgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0WyJFQU5fMTMiXSA9IDddID0gIkVBTl8xMyI7CgkgICAgLyoqIElURiAoSW50ZXJsZWF2ZWQgVHdvIG9mIEZpdmUpIDFEIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIklURiJdID0gOF0gPSAiSVRGIjsKCSAgICAvKiogTWF4aUNvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovCgkgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0WyJNQVhJQ09ERSJdID0gOV0gPSAiTUFYSUNPREUiOwoJICAgIC8qKiBQREY0MTcgZm9ybWF0LiAqLwoJICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFsiUERGXzQxNyJdID0gMTBdID0gIlBERl80MTciOwoJICAgIC8qKiBRUiBDb2RlIDJEIGJhcmNvZGUgZm9ybWF0LiAqLwoJICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFsiUVJfQ09ERSJdID0gMTFdID0gIlFSX0NPREUiOwoJICAgIC8qKiBSU1MgMTQgKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIlJTU18xNCJdID0gMTJdID0gIlJTU18xNCI7CgkgICAgLyoqIFJTUyBFWFBBTkRFRCAqLwoJICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFsiUlNTX0VYUEFOREVEIl0gPSAxM10gPSAiUlNTX0VYUEFOREVEIjsKCSAgICAvKiogVVBDLUEgMUQgZm9ybWF0LiAqLwoJICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFsiVVBDX0EiXSA9IDE0XSA9ICJVUENfQSI7CgkgICAgLyoqIFVQQy1FIDFEIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIlVQQ19FIl0gPSAxNV0gPSAiVVBDX0UiOwoJICAgIC8qKiBVUEMvRUFOIGV4dGVuc2lvbiBmb3JtYXQuIE5vdCBhIHN0YW5kLWFsb25lIGZvcm1hdC4gKi8KCSAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbIlVQQ19FQU5fRVhURU5TSU9OIl0gPSAxNl0gPSAiVVBDX0VBTl9FWFRFTlNJT04iOwoJfSkoQmFyY29kZUZvcm1hdCB8fCAoQmFyY29kZUZvcm1hdCA9IHt9KSk7CglCYXJjb2RlRm9ybWF0JDEuZGVmYXVsdCA9IEJhcmNvZGVGb3JtYXQ7CgoJdmFyIFJlc3VsdCQxID0ge307CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXN1bHQkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIFN5c3RlbV8xJDEgPSBTeXN0ZW0kMTsKCS8qKgoJICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBiYXJjb2RlIHdpdGhpbiBhbiBpbWFnZS48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIFJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSB0ZXh0OiBzdHJpbmcsCgkgICAgLy8gICAgICAgICAgICAgICBVaW50OEFycmF5IHJhd0J5dGVzLAoJICAgIC8vICAgICAgICAgICAgICAgUmVzdWx0UG9jb25zdCByZXN1bHRQb2ludHM6IEludDMyQXJyYXksCgkgICAgLy8gICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0IGZvcm1hdCkgewoJICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKQoJICAgIC8vIH0KCSAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IodGV4dDogc3RyaW5nLAoJICAgIC8vICAgICAgICAgICAgICAgVWludDhBcnJheSByYXdCeXRlcywKCSAgICAvLyAgICAgICAgICAgICAgIFJlc3VsdFBvY29uc3QgcmVzdWx0UG9pbnRzOiBJbnQzMkFycmF5LAoJICAgIC8vICAgICAgICAgICAgICAgQmFyY29kZUZvcm1hdCBmb3JtYXQsCgkgICAgLy8gICAgICAgICAgICAgICBsb25nIHRpbWVzdGFtcCkgewoJICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmF3Qnl0ZXMgPT0gbnVsbCA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoLAoJICAgIC8vICAgICAgICByZXN1bHRQb2ludHMsIGZvcm1hdCwgdGltZXN0YW1wKQoJICAgIC8vIH0KCSAgICBmdW5jdGlvbiBSZXN1bHQodGV4dCwgcmF3Qnl0ZXMsIG51bUJpdHMsIHJlc3VsdFBvaW50cywgZm9ybWF0LCB0aW1lc3RhbXApIHsKCSAgICAgICAgaWYgKG51bUJpdHMgPT09IHZvaWQgMCkgeyBudW1CaXRzID0gcmF3Qnl0ZXMgPT0gbnVsbCA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoOyB9CgkgICAgICAgIGlmICh0aW1lc3RhbXAgPT09IHZvaWQgMCkgeyB0aW1lc3RhbXAgPSBTeXN0ZW1fMSQxLmRlZmF1bHQuY3VycmVudFRpbWVNaWxsaXMoKTsgfQoJICAgICAgICB0aGlzLnRleHQgPSB0ZXh0OwoJICAgICAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7CgkgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7CgkgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gcmVzdWx0UG9pbnRzOwoJICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDsKCSAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7CgkgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7CgkgICAgICAgIHRoaXMucmF3Qnl0ZXMgPSByYXdCeXRlczsKCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbnVtQml0cyB8fCBudWxsID09PSBudW1CaXRzKSB7CgkgICAgICAgICAgICB0aGlzLm51bUJpdHMgPSAocmF3Qnl0ZXMgPT09IG51bGwgfHwgcmF3Qnl0ZXMgPT09IHVuZGVmaW5lZCkgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aDsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7CgkgICAgICAgIH0KCSAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSByZXN1bHRQb2ludHM7CgkgICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0OwoJICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbnVsbDsKCSAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGltZXN0YW1wIHx8IG51bGwgPT09IHRpbWVzdGFtcCkgewoJICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBTeXN0ZW1fMSQxLmRlZmF1bHQuY3VycmVudFRpbWVNaWxsaXMoKTsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wOwoJICAgICAgICB9CgkgICAgfQoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gcmF3IHRleHQgZW5jb2RlZCBieSB0aGUgYmFyY29kZQoJICAgICAqLwoJICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMudGV4dDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gcmF3IGJ5dGVzIGVuY29kZWQgYnkgdGhlIGJhcmNvZGUsIGlmIGFwcGxpY2FibGUsIG90aGVyd2lzZSB7QGNvZGUgbnVsbH0KCSAgICAgKi8KCSAgICBSZXN1bHQucHJvdG90eXBlLmdldFJhd0J5dGVzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5yYXdCeXRlczsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gaG93IG1hbnkgYml0cyBvZiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9IGFyZSB2YWxpZDsgdHlwaWNhbGx5IDggdGltZXMgaXRzIGxlbmd0aAoJICAgICAqIEBzaW5jZSAzLjMuMAoJICAgICAqLwoJICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0TnVtQml0cyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMubnVtQml0czsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gcG9pbnRzIHJlbGF0ZWQgdG8gdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLiBUaGVzZSBhcmUgdHlwaWNhbGx5IHBvaW50cwoJICAgICAqICAgICAgICAgaWRlbnRpZnlpbmcgZmluZGVyIHBhdHRlcm5zIG9yIHRoZSBjb3JuZXJzIG9mIHRoZSBiYXJjb2RlLiBUaGUgZXhhY3QgbWVhbmluZyBpcwoJICAgICAqICAgICAgICAgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgYmFyY29kZSB0aGF0IHdhcyBkZWNvZGVkLgoJICAgICAqLwoJICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0UmVzdWx0UG9pbnRzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludHM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIHtAbGluayBCYXJjb2RlRm9ybWF0fSByZXByZXNlbnRpbmcgdGhlIGZvcm1hdCBvZiB0aGUgYmFyY29kZSB0aGF0IHdhcyBkZWNvZGVkCgkgICAgICovCgkgICAgUmVzdWx0LnByb3RvdHlwZS5nZXRCYXJjb2RlRm9ybWF0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQ7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIHtAbGluayBNYXB9IG1hcHBpbmcge0BsaW5rIFJlc3VsdE1ldGFkYXRhVHlwZX0ga2V5cyB0byB2YWx1ZXMuIE1heSBiZQoJICAgICAqICAge0Bjb2RlIG51bGx9LiBUaGlzIGNvbnRhaW5zIG9wdGlvbmFsIG1ldGFkYXRhIGFib3V0IHdoYXQgd2FzIGRldGVjdGVkIGFib3V0IHRoZSBiYXJjb2RlLAoJICAgICAqICAgbGlrZSBvcmllbnRhdGlvbi4KCSAgICAgKi8KCSAgICBSZXN1bHQucHJvdG90eXBlLmdldFJlc3VsdE1ldGFkYXRhID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRNZXRhZGF0YTsKCSAgICB9OwoJICAgIFJlc3VsdC5wcm90b3R5cGUucHV0TWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHsKCSAgICAgICAgaWYgKHRoaXMucmVzdWx0TWV0YWRhdGEgPT09IG51bGwpIHsKCSAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBuZXcgTWFwKCk7CgkgICAgICAgIH0KCSAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YS5zZXQodHlwZSwgdmFsdWUpOwoJICAgIH07CgkgICAgUmVzdWx0LnByb3RvdHlwZS5wdXRBbGxNZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkgewoJICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwpIHsKCSAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdE1ldGFkYXRhID09PSBudWxsKSB7CgkgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG1ldGFkYXRhOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG5ldyBNYXAobWV0YWRhdGEpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgfTsKCSAgICBSZXN1bHQucHJvdG90eXBlLmFkZFJlc3VsdFBvaW50cyA9IGZ1bmN0aW9uIChuZXdQb2ludHMpIHsKCSAgICAgICAgdmFyIG9sZFBvaW50cyA9IHRoaXMucmVzdWx0UG9pbnRzOwoJICAgICAgICBpZiAob2xkUG9pbnRzID09PSBudWxsKSB7CgkgICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IG5ld1BvaW50czsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIGlmIChuZXdQb2ludHMgIT09IG51bGwgJiYgbmV3UG9pbnRzLmxlbmd0aCA+IDApIHsKCSAgICAgICAgICAgIHZhciBhbGxQb2ludHMgPSBuZXcgQXJyYXkob2xkUG9pbnRzLmxlbmd0aCArIG5ld1BvaW50cy5sZW5ndGgpOwoJICAgICAgICAgICAgU3lzdGVtXzEkMS5kZWZhdWx0LmFycmF5Y29weShvbGRQb2ludHMsIDAsIGFsbFBvaW50cywgMCwgb2xkUG9pbnRzLmxlbmd0aCk7CgkgICAgICAgICAgICBTeXN0ZW1fMSQxLmRlZmF1bHQuYXJyYXljb3B5KG5ld1BvaW50cywgMCwgYWxsUG9pbnRzLCBvbGRQb2ludHMubGVuZ3RoLCBuZXdQb2ludHMubGVuZ3RoKTsKCSAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gYWxsUG9pbnRzOwoJICAgICAgICB9CgkgICAgfTsKCSAgICBSZXN1bHQucHJvdG90eXBlLmdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIFJlc3VsdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnRleHQ7CgkgICAgfTsKCSAgICByZXR1cm4gUmVzdWx0OwoJfSgpKTsKCVJlc3VsdCQxLmRlZmF1bHQgPSBSZXN1bHQ7CgoJdmFyIFJlc3VsdE1ldGFkYXRhVHlwZSQxID0ge307CgoJLyoKCSAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXN1bHRNZXRhZGF0YVR5cGUkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki8KCS8qKgoJICogUmVwcmVzZW50cyBzb21lIHR5cGUgb2YgbWV0YWRhdGEgYWJvdXQgdGhlIHJlc3VsdCBvZiB0aGUgZGVjb2RpbmcgdGhhdCB0aGUgZGVjb2RlcgoJICogd2lzaGVzIHRvIGNvbW11bmljYXRlIGJhY2sgdG8gdGhlIGNhbGxlci4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgUmVzdWx0TWV0YWRhdGFUeXBlOwoJKGZ1bmN0aW9uIChSZXN1bHRNZXRhZGF0YVR5cGUpIHsKCSAgICAvKioKCSAgICAgKiBVbnNwZWNpZmllZCwgYXBwbGljYXRpb24tc3BlY2lmaWMgbWV0YWRhdGEuIE1hcHMgdG8gYW4gdW5zcGVjaWZpZWQge0BsaW5rIE9iamVjdH0uCgkgICAgICovCgkgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVsiT1RIRVIiXSA9IDBdID0gIk9USEVSIjsKCSAgICAvKioKCSAgICAgKiBEZW5vdGVzIHRoZSBsaWtlbHkgYXBwcm94aW1hdGUgb3JpZW50YXRpb24gb2YgdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLiBUaGlzIHZhbHVlCgkgICAgICogaXMgZ2l2ZW4gYXMgZGVncmVlcyByb3RhdGVkIGNsb2Nrd2lzZSBmcm9tIHRoZSBub3JtYWwsIHVwcmlnaHQgb3JpZW50YXRpb24uCgkgICAgICogRm9yIGV4YW1wbGUgYSAxRCBiYXJjb2RlIHdoaWNoIHdhcyBmb3VuZCBieSByZWFkaW5nIHRvcC10by1ib3R0b20gd291bGQgYmUKCSAgICAgKiBzYWlkIHRvIGhhdmUgb3JpZW50YXRpb24gIjkwIi4gVGhpcyBrZXkgbWFwcyB0byBhbiB7QGxpbmsgSW50ZWdlcn0gd2hvc2UKCSAgICAgKiB2YWx1ZSBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKS4KCSAgICAgKi8KCSAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlWyJPUklFTlRBVElPTiJdID0gMV0gPSAiT1JJRU5UQVRJT04iOwoJICAgIC8qKgoJICAgICAqIDxwPjJEIGJhcmNvZGUgZm9ybWF0cyB0eXBpY2FsbHkgZW5jb2RlIHRleHQsIGJ1dCBhbGxvdyBmb3IgYSBzb3J0IG9mICdieXRlIG1vZGUnCgkgICAgICogd2hpY2ggaXMgc29tZXRpbWVzIHVzZWQgdG8gZW5jb2RlIGJpbmFyeSBkYXRhLiBXaGlsZSB7QGxpbmsgUmVzdWx0fSBtYWtlcyBhdmFpbGFibGUKCSAgICAgKiB0aGUgY29tcGxldGUgcmF3IGJ5dGVzIGluIHRoZSBiYXJjb2RlIGZvciB0aGVzZSBmb3JtYXRzLCBpdCBkb2VzIG5vdCBvZmZlciB0aGUgYnl0ZXMKCSAgICAgKiBmcm9tIHRoZSBieXRlIHNlZ21lbnRzIGFsb25lLjwvcD4KCSAgICAgKgoJICAgICAqIDxwPlRoaXMgbWFwcyB0byBhIHtAbGluayBqYXZhLnV0aWwuTGlzdH0gb2YgYnl0ZSBhcnJheXMgY29ycmVzcG9uZGluZyB0byB0aGUKCSAgICAgKiByYXcgYnl0ZXMgaW4gdGhlIGJ5dGUgc2VnbWVudHMgaW4gdGhlIGJhcmNvZGUsIGluIG9yZGVyLjwvcD4KCSAgICAgKi8KCSAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlWyJCWVRFX1NFR01FTlRTIl0gPSAyXSA9ICJCWVRFX1NFR01FTlRTIjsKCSAgICAvKioKCSAgICAgKiBFcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIGlmIGFwcGxpY2FibGUuIFRoZSB2YWx1ZSB0eXBlIGRlcGVuZHMgb24gdGhlCgkgICAgICogZm9ybWF0LCBidXQgaXMgdHlwaWNhbGx5IGEgU3RyaW5nLgoJICAgICAqLwoJICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwiXSA9IDNdID0gIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwiOwoJICAgIC8qKgoJICAgICAqIEZvciBzb21lIHBlcmlvZGljYWxzLCBpbmRpY2F0ZXMgdGhlIGlzc3VlIG51bWJlciBhcyBhbiB7QGxpbmsgSW50ZWdlcn0uCgkgICAgICovCgkgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVsiSVNTVUVfTlVNQkVSIl0gPSA0XSA9ICJJU1NVRV9OVU1CRVIiOwoJICAgIC8qKgoJICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCBpbmRpY2F0ZXMgdGhlIHN1Z2dlc3RlZCByZXRhaWwgcHJpY2UgaW4gdGhlIGJhcmNvZGUgYXMgYQoJICAgICAqIGZvcm1hdHRlZCB7QGxpbmsgU3RyaW5nfS4KCSAgICAgKi8KCSAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlWyJTVUdHRVNURURfUFJJQ0UiXSA9IDVdID0gIlNVR0dFU1RFRF9QUklDRSI7CgkgICAgLyoqCgkgICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIHRoZSBwb3NzaWJsZSBjb3VudHJ5IG9mIG1hbnVmYWN0dXJlIGFzIGEge0BsaW5rIFN0cmluZ30gZGVub3RpbmcgdGhlCgkgICAgICogSVNPIGNvdW50cnkgY29kZS4gU29tZSBtYXAgdG8gbXVsdGlwbGUgcG9zc2libGUgY291bnRyaWVzLCBsaWtlICJVUy9DQSIuCgkgICAgICovCgkgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVsiUE9TU0lCTEVfQ09VTlRSWSJdID0gNl0gPSAiUE9TU0lCTEVfQ09VTlRSWSI7CgkgICAgLyoqCgkgICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIHRoZSBleHRlbnNpb24gdGV4dAoJICAgICAqLwoJICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbIlVQQ19FQU5fRVhURU5TSU9OIl0gPSA3XSA9ICJVUENfRUFOX0VYVEVOU0lPTiI7CgkgICAgLyoqCgkgICAgICogUERGNDE3LXNwZWNpZmljIG1ldGFkYXRhCgkgICAgICovCgkgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVsiUERGNDE3X0VYVFJBX01FVEFEQVRBIl0gPSA4XSA9ICJQREY0MTdfRVhUUkFfTUVUQURBVEEiOwoJICAgIC8qKgoJICAgICAqIElmIHRoZSBjb2RlIGZvcm1hdCBzdXBwb3J0cyBzdHJ1Y3R1cmVkIGFwcGVuZCBhbmQgdGhlIGN1cnJlbnQgc2Nhbm5lZCBjb2RlIGlzIHBhcnQgb2Ygb25lIHRoZW4gdGhlCgkgICAgICogc2VxdWVuY2UgbnVtYmVyIGlzIGdpdmVuIHdpdGggaXQuCgkgICAgICovCgkgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVsiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0UiXSA9IDldID0gIlNUUlVDVFVSRURfQVBQRU5EX1NFUVVFTkNFIjsKCSAgICAvKioKCSAgICAgKiBJZiB0aGUgY29kZSBmb3JtYXQgc3VwcG9ydHMgc3RydWN0dXJlZCBhcHBlbmQgYW5kIHRoZSBjdXJyZW50IHNjYW5uZWQgY29kZSBpcyBwYXJ0IG9mIG9uZSB0aGVuIHRoZQoJICAgICAqIHBhcml0eSBpcyBnaXZlbiB3aXRoIGl0LgoJICAgICAqLwoJICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbIlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWSJdID0gMTBdID0gIlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWSI7Cgl9KShSZXN1bHRNZXRhZGF0YVR5cGUgfHwgKFJlc3VsdE1ldGFkYXRhVHlwZSA9IHt9KSk7CglSZXN1bHRNZXRhZGF0YVR5cGUkMS5kZWZhdWx0ID0gUmVzdWx0TWV0YWRhdGFUeXBlOwoKCXZhciBEZWNvZGVyJDEgPSB7fTsKCgl2YXIgQ2hlY2tzdW1FeGNlcHRpb24kMSA9IHt9OwoKCXZhciBfX2V4dGVuZHMkOCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGVja3N1bUV4Y2VwdGlvbiQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgRXhjZXB0aW9uXzEkNCA9IEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uCgkgKi8KCXZhciBDaGVja3N1bUV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkOChDaGVja3N1bUV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBDaGVja3N1bUV4Y2VwdGlvbigpIHsKCSAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoJICAgIH0KCSAgICBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7CgkgICAgfTsKCSAgICBDaGVja3N1bUV4Y2VwdGlvbi5raW5kID0gJ0NoZWNrc3VtRXhjZXB0aW9uJzsKCSAgICByZXR1cm4gQ2hlY2tzdW1FeGNlcHRpb247Cgl9KEV4Y2VwdGlvbl8xJDQuZGVmYXVsdCkpOwoJQ2hlY2tzdW1FeGNlcHRpb24kMS5kZWZhdWx0ID0gQ2hlY2tzdW1FeGNlcHRpb247CgoJdmFyIEdlbmVyaWNHRiQxID0ge307CgoJdmFyIEdlbmVyaWNHRlBvbHkkMSA9IHt9OwoKCXZhciBBYnN0cmFjdEdlbmVyaWNHRiQxID0ge307CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEdlbmVyaWNHRiQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNSA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBvdmVyCgkgKiB0aGUgR2Fsb2lzIEZpZWxkcy4gT3BlcmF0aW9ucyB1c2UgYSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbCBpbiBjYWxjdWxhdGlvbnMuPC9wPgoJICoKCSAqIDxwPlRocm91Z2hvdXQgdGhpcyBwYWNrYWdlLCBlbGVtZW50cyBvZiB0aGUgR0YgYXJlIHJlcHJlc2VudGVkIGFzIGFuIHtAY29kZSBpbnR9CgkgKiBmb3IgY29udmVuaWVuY2UgYW5kIHNwZWVkIChidXQgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5KS4KCSAqIDwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICogQGF1dGhvciBEYXZpZCBPbGl2aWVyCgkgKi8KCXZhciBBYnN0cmFjdEdlbmVyaWNHRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBBYnN0cmFjdEdlbmVyaWNHRigpIHsKCSAgICB9CgkgICAgLyoqCgkgICAgICogQHJldHVybiAyIHRvIHRoZSBwb3dlciBvZiBhIGluIEdGKHNpemUpCgkgICAgICovCgkgICAgQWJzdHJhY3RHZW5lcmljR0YucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChhKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlW2FdOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBiYXNlIDIgbG9nIG9mIGEgaW4gR0Yoc2l6ZSkKCSAgICAgKi8KCSAgICBBYnN0cmFjdEdlbmVyaWNHRi5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGEgLyppbnQqLykgewoJICAgICAgICBpZiAoYSA9PT0gMCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDUuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiB0aGlzLmxvZ1RhYmxlW2FdOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogSW1wbGVtZW50cyBib3RoIGFkZGl0aW9uIGFuZCBzdWJ0cmFjdGlvbiAtLSB0aGV5IGFyZSB0aGUgc2FtZSBpbiBHRihzaXplKS4KCSAgICAgKgoJICAgICAqIEByZXR1cm4gc3VtL2RpZmZlcmVuY2Ugb2YgYSBhbmQgYgoJICAgICAqLwoJICAgIEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHsKCSAgICAgICAgcmV0dXJuIGEgXiBiOwoJICAgIH07CgkgICAgcmV0dXJuIEFic3RyYWN0R2VuZXJpY0dGOwoJfSgpKTsKCUFic3RyYWN0R2VuZXJpY0dGJDEuZGVmYXVsdCA9IEFic3RyYWN0R2VuZXJpY0dGOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoR2VuZXJpY0dGUG9seSQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbiB7Ki8KCXZhciBBYnN0cmFjdEdlbmVyaWNHRl8xJDEgPSBBYnN0cmFjdEdlbmVyaWNHRiQxOwoJdmFyIFN5c3RlbV8xID0gU3lzdGVtJDE7Cgl2YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNCA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiA8cD5SZXByZXNlbnRzIGEgcG9seW5vbWlhbCB3aG9zZSBjb2VmZmljaWVudHMgYXJlIGVsZW1lbnRzIG9mIGEgR0YuCgkgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW1tdXRhYmxlLjwvcD4KCSAqCgkgKiA8cD5NdWNoIGNyZWRpdCBpcyBkdWUgdG8gV2lsbGlhbSBSdWNrbGlkZ2Ugc2luY2UgcG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBhbiBpbmRpcmVjdAoJICogcG9ydCBvZiBoaXMgQysrIFJlZWQtU29sb21vbiBpbXBsZW1lbnRhdGlvbi48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEdlbmVyaWNHRlBvbHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgLyoqCgkgICAgICogQHBhcmFtIGZpZWxkIHRoZSB7QGxpbmsgR2VuZXJpY0dGfSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGZpZWxkIHRvIHVzZQoJICAgICAqIHRvIHBlcmZvcm0gY29tcHV0YXRpb25zCgkgICAgICogQHBhcmFtIGNvZWZmaWNpZW50cyBjb2VmZmljaWVudHMgYXMgaW50cyByZXByZXNlbnRpbmcgZWxlbWVudHMgb2YgR0Yoc2l6ZSksIGFycmFuZ2VkCgkgICAgICogZnJvbSBtb3N0IHNpZ25pZmljYW50IChoaWdoZXN0LXBvd2VyIHRlcm0pIGNvZWZmaWNpZW50IHRvIGxlYXN0IHNpZ25pZmljYW50CgkgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYXJndW1lbnQgaXMgbnVsbCBvciBlbXB0eSwKCSAgICAgKiBvciBpZiBsZWFkaW5nIGNvZWZmaWNpZW50IGlzIDAgYW5kIHRoaXMgaXMgbm90IGEKCSAgICAgKiBjb25zdGFudCBwb2x5bm9taWFsICh0aGF0IGlzLCBpdCBpcyBub3QgdGhlIG1vbm9taWFsICIwIikKCSAgICAgKi8KCSAgICBmdW5jdGlvbiBHZW5lcmljR0ZQb2x5KGZpZWxkLCBjb2VmZmljaWVudHMpIHsKCSAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ0LmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7CgkgICAgICAgIHZhciBjb2VmZmljaWVudHNMZW5ndGggPSBjb2VmZmljaWVudHMubGVuZ3RoOwoJICAgICAgICBpZiAoY29lZmZpY2llbnRzTGVuZ3RoID4gMSAmJiBjb2VmZmljaWVudHNbMF0gPT09IDApIHsKCSAgICAgICAgICAgIC8vIExlYWRpbmcgdGVybSBtdXN0IGJlIG5vbi16ZXJvIGZvciBhbnl0aGluZyBleGNlcHQgdGhlIGNvbnN0YW50IHBvbHlub21pYWwgIjAiCgkgICAgICAgICAgICB2YXIgZmlyc3ROb25aZXJvID0gMTsKCSAgICAgICAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiYgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT09IDApIHsKCSAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKzsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGlmIChmaXJzdE5vblplcm8gPT09IGNvZWZmaWNpZW50c0xlbmd0aCkgewoJICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gSW50MzJBcnJheS5mcm9tKFswXSk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZWZmaWNpZW50c0xlbmd0aCAtIGZpcnN0Tm9uWmVybyk7CgkgICAgICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkoY29lZmZpY2llbnRzLCBmaXJzdE5vblplcm8sIHRoaXMuY29lZmZpY2llbnRzLCAwLCB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGgpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBjb2VmZmljaWVudHM7CgkgICAgICAgIH0KCSAgICB9CgkgICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuZ2V0Q29lZmZpY2llbnRzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWwKCSAgICAgKi8KCSAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5nZXREZWdyZWUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGlzIHBvbHlub21pYWwgaXMgdGhlIG1vbm9taWFsICIwIgoJICAgICAqLwoJICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzWzBdID09PSAwOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBjb2VmZmljaWVudCBvZiB4XmRlZ3JlZSB0ZXJtIGluIHRoaXMgcG9seW5vbWlhbAoJICAgICAqLwoJICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmdldENvZWZmaWNpZW50ID0gZnVuY3Rpb24gKGRlZ3JlZSAvKmludCovKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1t0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gZGVncmVlXTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludAoJICAgICAqLwoJICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmV2YWx1YXRlQXQgPSBmdW5jdGlvbiAoYSAvKmludCovKSB7CgkgICAgICAgIGlmIChhID09PSAwKSB7CgkgICAgICAgICAgICAvLyBKdXN0IHJldHVybiB0aGUgeF4wIGNvZWZmaWNpZW50CgkgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7CgkgICAgICAgIHZhciByZXN1bHQ7CgkgICAgICAgIGlmIChhID09PSAxKSB7CgkgICAgICAgICAgICAvLyBKdXN0IHRoZSBzdW0gb2YgdGhlIGNvZWZmaWNpZW50cwoJICAgICAgICAgICAgcmVzdWx0ID0gMDsKCSAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGNvZWZmaWNpZW50cy5sZW5ndGg7IGkgIT09IGxlbmd0aF8xOyBpKyspIHsKCSAgICAgICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSBjb2VmZmljaWVudHNbaV07CgkgICAgICAgICAgICAgICAgcmVzdWx0ID0gQWJzdHJhY3RHZW5lcmljR0ZfMSQxLmRlZmF1bHQuYWRkT3JTdWJ0cmFjdChyZXN1bHQsIGNvZWZmaWNpZW50KTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CgkgICAgICAgIH0KCSAgICAgICAgcmVzdWx0ID0gY29lZmZpY2llbnRzWzBdOwoJICAgICAgICB2YXIgc2l6ZSA9IGNvZWZmaWNpZW50cy5sZW5ndGg7CgkgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7CgkgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2l6ZTsgaSsrKSB7CgkgICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRl8xJDEuZGVmYXVsdC5hZGRPclN1YnRyYWN0KGZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdCksIGNvZWZmaWNpZW50c1tpXSk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHJlc3VsdDsKCSAgICB9OwoJICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmFkZE9yU3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ0LmRlZmF1bHQoJ0dlbmVyaWNHRlBvbHlzIGRvIG5vdCBoYXZlIHNhbWUgR2VuZXJpY0dGIGZpZWxkJyk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHsKCSAgICAgICAgICAgIHJldHVybiBvdGhlcjsKCSAgICAgICAgfQoJICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHsKCSAgICAgICAgICAgIHJldHVybiB0aGlzOwoJICAgICAgICB9CgkgICAgICAgIHZhciBzbWFsbGVyQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7CgkgICAgICAgIHZhciBsYXJnZXJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7CgkgICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHsKCSAgICAgICAgICAgIHZhciB0ZW1wID0gc21hbGxlckNvZWZmaWNpZW50czsKCSAgICAgICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHMgPSBsYXJnZXJDb2VmZmljaWVudHM7CgkgICAgICAgICAgICBsYXJnZXJDb2VmZmljaWVudHMgPSB0ZW1wOwoJICAgICAgICB9CgkgICAgICAgIHZhciBzdW1EaWZmID0gbmV3IEludDMyQXJyYXkobGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCk7CgkgICAgICAgIHZhciBsZW5ndGhEaWZmID0gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCAtIHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoOwoJICAgICAgICAvLyBDb3B5IGhpZ2gtb3JkZXIgdGVybXMgb25seSBmb3VuZCBpbiBoaWdoZXItZGVncmVlIHBvbHlub21pYWwncyBjb2VmZmljaWVudHMKCSAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkobGFyZ2VyQ29lZmZpY2llbnRzLCAwLCBzdW1EaWZmLCAwLCBsZW5ndGhEaWZmKTsKCSAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHsKCSAgICAgICAgICAgIHN1bURpZmZbaV0gPSBBYnN0cmFjdEdlbmVyaWNHRl8xJDEuZGVmYXVsdC5hZGRPclN1YnRyYWN0KHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJDb2VmZmljaWVudHNbaV0pOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTsKCSAgICB9OwoJICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7CgkgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNC5kZWZhdWx0KCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpOwoJICAgICAgICB9CgkgICAgICAgIGlmICh0aGlzLmlzWmVybygpIHx8IG90aGVyLmlzWmVybygpKSB7CgkgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGFDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50czsKCSAgICAgICAgdmFyIGFMZW5ndGggPSBhQ29lZmZpY2llbnRzLmxlbmd0aDsKCSAgICAgICAgdmFyIGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7CgkgICAgICAgIHZhciBiTGVuZ3RoID0gYkNvZWZmaWNpZW50cy5sZW5ndGg7CgkgICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoYUxlbmd0aCArIGJMZW5ndGggLSAxKTsKCSAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTGVuZ3RoOyBpKyspIHsKCSAgICAgICAgICAgIHZhciBhQ29lZmYgPSBhQ29lZmZpY2llbnRzW2ldOwoJICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHsKCSAgICAgICAgICAgICAgICBwcm9kdWN0W2kgKyBqXSA9IEFic3RyYWN0R2VuZXJpY0dGXzEkMS5kZWZhdWx0LmFkZE9yU3VidHJhY3QocHJvZHVjdFtpICsgal0sIGZpZWxkLm11bHRpcGx5KGFDb2VmZiwgYkNvZWZmaWNpZW50c1tqXSkpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcHJvZHVjdCk7CgkgICAgfTsKCSAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5tdWx0aXBseVNjYWxhciA9IGZ1bmN0aW9uIChzY2FsYXIgLyppbnQqLykgewoJICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7CgkgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHNjYWxhciA9PT0gMSkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXM7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHNpemUgPSB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7CgkgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7CgkgICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7CgkgICAgICAgIHZhciBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50czsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsKCSAgICAgICAgICAgIHByb2R1Y3RbaV0gPSBmaWVsZC5tdWx0aXBseShjb2VmZmljaWVudHNbaV0sIHNjYWxhcik7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTsKCSAgICB9OwoJICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLm11bHRpcGx5QnlNb25vbWlhbCA9IGZ1bmN0aW9uIChkZWdyZWUgLyppbnQqLywgY29lZmZpY2llbnQgLyppbnQqLykgewoJICAgICAgICBpZiAoZGVncmVlIDwgMCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDQuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpOwoJICAgICAgICB9CgkgICAgICAgIHZhciBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50czsKCSAgICAgICAgdmFyIHNpemUgPSBjb2VmZmljaWVudHMubGVuZ3RoOwoJICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUgKyBkZWdyZWUpOwoJICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkOwoJICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgewoJICAgICAgICAgICAgcHJvZHVjdFtpXSA9IGZpZWxkLm11bHRpcGx5KGNvZWZmaWNpZW50c1tpXSwgY29lZmZpY2llbnQpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcHJvZHVjdCk7CgkgICAgfTsKCSAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQ0LmRlZmF1bHQoJ0dlbmVyaWNHRlBvbHlzIGRvIG5vdCBoYXZlIHNhbWUgR2VuZXJpY0dGIGZpZWxkJyk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkNC5kZWZhdWx0KCdEaXZpZGUgYnkgMCcpOwoJICAgICAgICB9CgkgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7CgkgICAgICAgIHZhciBxdW90aWVudCA9IGZpZWxkLmdldFplcm8oKTsKCSAgICAgICAgdmFyIHJlbWFpbmRlciA9IHRoaXM7CgkgICAgICAgIHZhciBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gb3RoZXIuZ2V0Q29lZmZpY2llbnQob3RoZXIuZ2V0RGVncmVlKCkpOwoJICAgICAgICB2YXIgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pOwoJICAgICAgICB3aGlsZSAocmVtYWluZGVyLmdldERlZ3JlZSgpID49IG90aGVyLmdldERlZ3JlZSgpICYmICFyZW1haW5kZXIuaXNaZXJvKCkpIHsKCSAgICAgICAgICAgIHZhciBkZWdyZWVEaWZmZXJlbmNlID0gcmVtYWluZGVyLmdldERlZ3JlZSgpIC0gb3RoZXIuZ2V0RGVncmVlKCk7CgkgICAgICAgICAgICB2YXIgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pOwoJICAgICAgICAgICAgdmFyIHRlcm0gPSBvdGhlci5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpOwoJICAgICAgICAgICAgdmFyIGl0ZXJhdGlvblF1b3RpZW50ID0gZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7CgkgICAgICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZE9yU3VidHJhY3QoaXRlcmF0aW9uUXVvdGllbnQpOwoJICAgICAgICAgICAgcmVtYWluZGVyID0gcmVtYWluZGVyLmFkZE9yU3VidHJhY3QodGVybSk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyXTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIHJlc3VsdCA9ICcnOwoJICAgICAgICBmb3IgKHZhciBkZWdyZWUgPSB0aGlzLmdldERlZ3JlZSgpOyBkZWdyZWUgPj0gMDsgZGVncmVlLS0pIHsKCSAgICAgICAgICAgIHZhciBjb2VmZmljaWVudCA9IHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTsKCSAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCAhPT0gMCkgewoJICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA8IDApIHsKCSAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnOwoJICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudCA9IC1jb2VmZmljaWVudDsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgKyAnOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgPT09IDAgfHwgY29lZmZpY2llbnQgIT09IDEpIHsKCSAgICAgICAgICAgICAgICAgICAgdmFyIGFscGhhUG93ZXIgPSB0aGlzLmZpZWxkLmxvZyhjb2VmZmljaWVudCk7CgkgICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYVBvd2VyID09PSAwKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzEnOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFscGhhUG93ZXIgPT09IDEpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnYSc7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2FeJzsKCSAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhbHBoYVBvd2VyOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgIT09IDApIHsKCSAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd4JzsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneF4nOwoJICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGRlZ3JlZTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gcmVzdWx0OwoJICAgIH07CgkgICAgcmV0dXJuIEdlbmVyaWNHRlBvbHk7Cgl9KCkpOwoJR2VuZXJpY0dGUG9seSQxLmRlZmF1bHQgPSBHZW5lcmljR0ZQb2x5OwoKCXZhciBBcml0aG1ldGljRXhjZXB0aW9uJDEgPSB7fTsKCgl2YXIgX19leHRlbmRzJDcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJpdGhtZXRpY0V4Y2VwdGlvbiQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgRXhjZXB0aW9uXzEkMyA9IEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uCgkgKi8KCXZhciBBcml0aG1ldGljRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikgewoJICAgIF9fZXh0ZW5kcyQ3KEFyaXRobWV0aWNFeGNlcHRpb24sIF9zdXBlcik7CgkgICAgZnVuY3Rpb24gQXJpdGhtZXRpY0V4Y2VwdGlvbigpIHsKCSAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoJICAgIH0KCSAgICBBcml0aG1ldGljRXhjZXB0aW9uLmtpbmQgPSAnQXJpdGhtZXRpY0V4Y2VwdGlvbic7CgkgICAgcmV0dXJuIEFyaXRobWV0aWNFeGNlcHRpb247Cgl9KEV4Y2VwdGlvbl8xJDMuZGVmYXVsdCkpOwoJQXJpdGhtZXRpY0V4Y2VwdGlvbiQxLmRlZmF1bHQgPSBBcml0aG1ldGljRXhjZXB0aW9uOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCgl2YXIgX19leHRlbmRzJDYgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoR2VuZXJpY0dGJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uIHsqLwoJdmFyIEdlbmVyaWNHRlBvbHlfMSQxID0gR2VuZXJpY0dGUG9seSQxOwoJdmFyIEFic3RyYWN0R2VuZXJpY0dGXzEgPSBBYnN0cmFjdEdlbmVyaWNHRiQxOwoJdmFyIEludGVnZXJfMSQxID0gSW50ZWdlciQxOwoJdmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDMgPSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24kMTsKCXZhciBBcml0aG1ldGljRXhjZXB0aW9uXzEgPSBBcml0aG1ldGljRXhjZXB0aW9uJDE7CgkvKioKCSAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBwZXJmb3JtaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zIG92ZXIKCSAqIHRoZSBHYWxvaXMgRmllbGRzLiBPcGVyYXRpb25zIHVzZSBhIGdpdmVuIHByaW1pdGl2ZSBwb2x5bm9taWFsIGluIGNhbGN1bGF0aW9ucy48L3A+CgkgKgoJICogPHA+VGhyb3VnaG91dCB0aGlzIHBhY2thZ2UsIGVsZW1lbnRzIG9mIHRoZSBHRiBhcmUgcmVwcmVzZW50ZWQgYXMgYW4ge0Bjb2RlIGludH0KCSAqIGZvciBjb252ZW5pZW5jZSBhbmQgc3BlZWQgKGJ1dCBhdCB0aGUgY29zdCBvZiBtZW1vcnkpLgoJICogPC9wPgoJICoKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKiBAYXV0aG9yIERhdmlkIE9saXZpZXIKCSAqLwoJdmFyIEdlbmVyaWNHRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkNihHZW5lcmljR0YsIF9zdXBlcik7CgkgICAgLyoqCgkgICAgICogQ3JlYXRlIGEgcmVwcmVzZW50YXRpb24gb2YgR0Yoc2l6ZSkgdXNpbmcgdGhlIGdpdmVuIHByaW1pdGl2ZSBwb2x5bm9taWFsLgoJICAgICAqCgkgICAgICogQHBhcmFtIHByaW1pdGl2ZSBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgcmVwcmVzZW50ZWQgYnkKCSAgICAgKiAgdGhlIGJpdHMgb2YgYW4gaW50LCB3aGVyZSB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0IHJlcHJlc2VudHMgdGhlIGNvbnN0YW50CgkgICAgICogIGNvZWZmaWNpZW50CgkgICAgICogQHBhcmFtIHNpemUgdGhlIHNpemUgb2YgdGhlIGZpZWxkCgkgICAgICogQHBhcmFtIGIgdGhlIGZhY3RvciBiIGluIHRoZSBnZW5lcmF0b3IgcG9seW5vbWlhbCBjYW4gYmUgMC0gb3IgMS1iYXNlZAoJICAgICAqICAoZyh4KSA9ICh4K2FeYikoeCthXihiKzEpKS4uLih4K2FeKGIrMnQtMSkpKS4KCSAgICAgKiAgSW4gbW9zdCBjYXNlcyBpdCBzaG91bGQgYmUgMSwgYnV0IGZvciBRUiBjb2RlIGl0IGlzIDAuCgkgICAgICovCgkgICAgZnVuY3Rpb24gR2VuZXJpY0dGKHByaW1pdGl2ZSAvKmludCovLCBzaXplIC8qaW50Ki8sIGdlbmVyYXRvckJhc2UgLyppbnQqLykgewoJICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzOwoJICAgICAgICBfdGhpcy5wcmltaXRpdmUgPSBwcmltaXRpdmU7CgkgICAgICAgIF90aGlzLnNpemUgPSBzaXplOwoJICAgICAgICBfdGhpcy5nZW5lcmF0b3JCYXNlID0gZ2VuZXJhdG9yQmFzZTsKCSAgICAgICAgdmFyIGV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7CgkgICAgICAgIHZhciB4ID0gMTsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsKCSAgICAgICAgICAgIGV4cFRhYmxlW2ldID0geDsKCSAgICAgICAgICAgIHggKj0gMjsgLy8gd2UncmUgYXNzdW1pbmcgdGhlIGdlbmVyYXRvciBhbHBoYSBpcyAyCgkgICAgICAgICAgICBpZiAoeCA+PSBzaXplKSB7CgkgICAgICAgICAgICAgICAgeCBePSBwcmltaXRpdmU7CgkgICAgICAgICAgICAgICAgeCAmPSBzaXplIC0gMTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBfdGhpcy5leHBUYWJsZSA9IGV4cFRhYmxlOwoJICAgICAgICB2YXIgbG9nVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplIC0gMTsgaSsrKSB7CgkgICAgICAgICAgICBsb2dUYWJsZVtleHBUYWJsZVtpXV0gPSBpOwoJICAgICAgICB9CgkgICAgICAgIF90aGlzLmxvZ1RhYmxlID0gbG9nVGFibGU7CgkgICAgICAgIC8vIGxvZ1RhYmxlWzBdID09IDAgYnV0IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHVzZWQKCSAgICAgICAgX3RoaXMuemVybyA9IG5ldyBHZW5lcmljR0ZQb2x5XzEkMS5kZWZhdWx0KF90aGlzLCBJbnQzMkFycmF5LmZyb20oWzBdKSk7CgkgICAgICAgIF90aGlzLm9uZSA9IG5ldyBHZW5lcmljR0ZQb2x5XzEkMS5kZWZhdWx0KF90aGlzLCBJbnQzMkFycmF5LmZyb20oWzFdKSk7CgkgICAgICAgIHJldHVybiBfdGhpczsKCSAgICB9CgkgICAgR2VuZXJpY0dGLnByb3RvdHlwZS5nZXRaZXJvID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy56ZXJvOwoJICAgIH07CgkgICAgR2VuZXJpY0dGLnByb3RvdHlwZS5nZXRPbmUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLm9uZTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gdGhlIG1vbm9taWFsIHJlcHJlc2VudGluZyBjb2VmZmljaWVudCAqIHheZGVncmVlCgkgICAgICovCgkgICAgR2VuZXJpY0dGLnByb3RvdHlwZS5idWlsZE1vbm9taWFsID0gZnVuY3Rpb24gKGRlZ3JlZSAvKmludCovLCBjb2VmZmljaWVudCAvKmludCovKSB7CgkgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEkMy5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7CgkgICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvOwoJICAgICAgICB9CgkgICAgICAgIHZhciBjb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkZWdyZWUgKyAxKTsKCSAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7CgkgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seV8xJDEuZGVmYXVsdCh0aGlzLCBjb2VmZmljaWVudHMpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGEKCSAgICAgKi8KCSAgICBHZW5lcmljR0YucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbiAoYSAvKmludCovKSB7CgkgICAgICAgIGlmIChhID09PSAwKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLnNpemUgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIHByb2R1Y3Qgb2YgYSBhbmQgYiBpbiBHRihzaXplKQoJICAgICAqLwoJICAgIEdlbmVyaWNHRi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkgewoJICAgICAgICAgICAgcmV0dXJuIDA7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLnNpemUgLSAxKV07CgkgICAgfTsKCSAgICBHZW5lcmljR0YucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnNpemU7CgkgICAgfTsKCSAgICBHZW5lcmljR0YucHJvdG90eXBlLmdldEdlbmVyYXRvckJhc2UgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvckJhc2U7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgR2VuZXJpY0dGLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuICgnR0YoMHgnICsgSW50ZWdlcl8xJDEuZGVmYXVsdC50b0hleFN0cmluZyh0aGlzLnByaW1pdGl2ZSkgKyAnLCcgKyB0aGlzLnNpemUgKyAnKScpOwoJICAgIH07CgkgICAgR2VuZXJpY0dGLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykgewoJICAgICAgICByZXR1cm4gbyA9PT0gdGhpczsKCSAgICB9OwoJICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEyID0gbmV3IEdlbmVyaWNHRigweDEwNjksIDQwOTYsIDEpOyAvLyB4XjEyICsgeF42ICsgeF41ICsgeF4zICsgMQoJICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEwID0gbmV3IEdlbmVyaWNHRigweDQwOSwgMTAyNCwgMSk7IC8vIHheMTAgKyB4XjMgKyAxCgkgICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfNiA9IG5ldyBHZW5lcmljR0YoMHg0MywgNjQsIDEpOyAvLyB4XjYgKyB4ICsgMQoJICAgIEdlbmVyaWNHRi5BWlRFQ19QQVJBTSA9IG5ldyBHZW5lcmljR0YoMHgxMywgMTYsIDEpOyAvLyB4XjQgKyB4ICsgMQoJICAgIEdlbmVyaWNHRi5RUl9DT0RFX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTFkLCAyNTYsIDApOyAvLyB4XjggKyB4XjQgKyB4XjMgKyB4XjIgKyAxCgkgICAgR2VuZXJpY0dGLkRBVEFfTUFUUklYX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTJkLCAyNTYsIDEpOyAvLyB4XjggKyB4XjUgKyB4XjMgKyB4XjIgKyAxCgkgICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfOCA9IEdlbmVyaWNHRi5EQVRBX01BVFJJWF9GSUVMRF8yNTY7CgkgICAgR2VuZXJpY0dGLk1BWElDT0RFX0ZJRUxEXzY0ID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjsKCSAgICByZXR1cm4gR2VuZXJpY0dGOwoJfShBYnN0cmFjdEdlbmVyaWNHRl8xLmRlZmF1bHQpKTsKCUdlbmVyaWNHRiQxLmRlZmF1bHQgPSBHZW5lcmljR0Y7CgoJdmFyIFJlZWRTb2xvbW9uRGVjb2RlciQxID0ge307CgoJdmFyIFJlZWRTb2xvbW9uRXhjZXB0aW9uJDEgPSB7fTsKCgl2YXIgX19leHRlbmRzJDUgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVlZFNvbG9tb25FeGNlcHRpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIEV4Y2VwdGlvbl8xJDIgPSBFeGNlcHRpb24kMTsKCS8qKgoJICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLgoJICovCgl2YXIgUmVlZFNvbG9tb25FeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJDUoUmVlZFNvbG9tb25FeGNlcHRpb24sIF9zdXBlcik7CgkgICAgZnVuY3Rpb24gUmVlZFNvbG9tb25FeGNlcHRpb24oKSB7CgkgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpczsKCSAgICB9CgkgICAgUmVlZFNvbG9tb25FeGNlcHRpb24ua2luZCA9ICdSZWVkU29sb21vbkV4Y2VwdGlvbic7CgkgICAgcmV0dXJuIFJlZWRTb2xvbW9uRXhjZXB0aW9uOwoJfShFeGNlcHRpb25fMSQyLmRlZmF1bHQpKTsKCVJlZWRTb2xvbW9uRXhjZXB0aW9uJDEuZGVmYXVsdCA9IFJlZWRTb2xvbW9uRXhjZXB0aW9uOwoKCXZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb24kMSA9IHt9OwoKCXZhciBfX2V4dGVuZHMkNCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CgkgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8CgkgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTsKCSAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgfTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9CgkgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTsKCSAgICB9OwoJfSkoKTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbGxlZ2FsU3RhdGVFeGNlcHRpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIEV4Y2VwdGlvbl8xJDEgPSBFeGNlcHRpb24kMTsKCS8qKgoJICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLgoJICovCgl2YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikgewoJICAgIF9fZXh0ZW5kcyQ0KElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKSB7CgkgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpczsKCSAgICB9CgkgICAgSWxsZWdhbFN0YXRlRXhjZXB0aW9uLmtpbmQgPSAnSWxsZWdhbFN0YXRlRXhjZXB0aW9uJzsKCSAgICByZXR1cm4gSWxsZWdhbFN0YXRlRXhjZXB0aW9uOwoJfShFeGNlcHRpb25fMSQxLmRlZmF1bHQpKTsKCUlsbGVnYWxTdGF0ZUV4Y2VwdGlvbiQxLmRlZmF1bHQgPSBJbGxlZ2FsU3RhdGVFeGNlcHRpb247CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWVkU29sb21vbkRlY29kZXIkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24geyovCgl2YXIgR2VuZXJpY0dGXzEkMSA9IEdlbmVyaWNHRiQxOwoJdmFyIEdlbmVyaWNHRlBvbHlfMSA9IEdlbmVyaWNHRlBvbHkkMTsKCXZhciBSZWVkU29sb21vbkV4Y2VwdGlvbl8xID0gUmVlZFNvbG9tb25FeGNlcHRpb24kMTsKCXZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMSA9IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiQxOwoJLyoqCgkgKiA8cD5JbXBsZW1lbnRzIFJlZWQtU29sb21vbiBkZWNvZGluZywgYXMgdGhlIG5hbWUgaW1wbGllcy48L3A+CgkgKgoJICogPHA+VGhlIGFsZ29yaXRobSB3aWxsIG5vdCBiZSBleHBsYWluZWQgaGVyZSwgYnV0IHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlcyB3ZXJlIGhlbHBmdWwKCSAqIGluIGNyZWF0aW5nIHRoaXMgaW1wbGVtZW50YXRpb246PC9wPgoJICoKCSAqIDx1bD4KCSAqIDxsaT5CcnVjZSBNYWdncy4KCSAqIDxhIGhyZWY9Imh0dHA6Ly93d3cuY3MuY211LmVkdS9hZnMvY3MuY211LmVkdS9wcm9qZWN0L3BzY2ljby1ndXliL3JlYWx3b3JsZC93d3cvcnNfZGVjb2RlLnBzIj4KCSAqICJEZWNvZGluZyBSZWVkLVNvbG9tb24gQ29kZXMiPC9hPiAoc2VlIGRpc2N1c3Npb24gb2YgRm9ybmV5J3MgRm9ybXVsYSk8L2xpPgoJICogPGxpPkouSS4gSGFsbC4gPGEgaHJlZj0id3d3Lm10aC5tc3UuZWR1L35qaGFsbC9jbGFzc2VzL2NvZGVub3Rlcy9HUlMucGRmIj4KCSAqICJDaGFwdGVyIDUuIEdlbmVyYWxpemVkIFJlZWQtU29sb21vbiBDb2RlcyI8L2E+CgkgKiAoc2VlIGRpc2N1c3Npb24gb2YgRXVjbGlkZWFuIGFsZ29yaXRobSk8L2xpPgoJICogPC91bD4KCSAqCgkgKiA8cD5NdWNoIGNyZWRpdCBpcyBkdWUgdG8gV2lsbGlhbSBSdWNrbGlkZ2Ugc2luY2UgcG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBhbiBpbmRpcmVjdAoJICogcG9ydCBvZiBoaXMgQysrIFJlZWQtU29sb21vbiBpbXBsZW1lbnRhdGlvbi48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqIEBhdXRob3IgV2lsbGlhbSBSdWNrbGlkZ2UKCSAqIEBhdXRob3Igc2FuZm9yZHNxdWlyZXMKCSAqLwoJdmFyIFJlZWRTb2xvbW9uRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBSZWVkU29sb21vbkRlY29kZXIoZmllbGQpIHsKCSAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkOwoJICAgIH0KCSAgICAvKioKCSAgICAgKiA8cD5EZWNvZGVzIGdpdmVuIHNldCBvZiByZWNlaXZlZCBjb2Rld29yZHMsIHdoaWNoIGluY2x1ZGUgYm90aCBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uCgkgICAgICogY29kZXdvcmRzLiBSZWFsbHksIHRoaXMgbWVhbnMgaXQgdXNlcyBSZWVkLVNvbG9tb24gdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycywgaW4tcGxhY2UsCgkgICAgICogaW4gdGhlIGlucHV0LjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSByZWNlaXZlZCBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcwoJICAgICAqIEBwYXJhbSB0d29TIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBhdmFpbGFibGUKCSAgICAgKiBAdGhyb3dzIFJlZWRTb2xvbW9uRXhjZXB0aW9uIGlmIGRlY29kaW5nIGZhaWxzIGZvciBhbnkgcmVhc29uCgkgICAgICovCgkgICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVjZWl2ZWQsIHR3b1MgLyppbnQqLykgewoJICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkOwoJICAgICAgICB2YXIgcG9seSA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdChmaWVsZCwgcmVjZWl2ZWQpOwoJICAgICAgICB2YXIgc3luZHJvbWVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheSh0d29TKTsKCSAgICAgICAgdmFyIG5vRXJyb3IgPSB0cnVlOwoJICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3b1M7IGkrKykgewoJICAgICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBwb2x5LmV2YWx1YXRlQXQoZmllbGQuZXhwKGkgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpKTsKCSAgICAgICAgICAgIHN5bmRyb21lQ29lZmZpY2llbnRzW3N5bmRyb21lQ29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBpXSA9IGV2YWxSZXN1bHQ7CgkgICAgICAgICAgICBpZiAoZXZhbFJlc3VsdCAhPT0gMCkgewoJICAgICAgICAgICAgICAgIG5vRXJyb3IgPSBmYWxzZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBpZiAobm9FcnJvcikgewoJICAgICAgICAgICAgcmV0dXJuOwoJICAgICAgICB9CgkgICAgICAgIHZhciBzeW5kcm9tZSA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdChmaWVsZCwgc3luZHJvbWVDb2VmZmljaWVudHMpOwoJICAgICAgICB2YXIgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKGZpZWxkLmJ1aWxkTW9ub21pYWwodHdvUywgMSksIHN5bmRyb21lLCB0d29TKTsKCSAgICAgICAgdmFyIHNpZ21hID0gc2lnbWFPbWVnYVswXTsKCSAgICAgICAgdmFyIG9tZWdhID0gc2lnbWFPbWVnYVsxXTsKCSAgICAgICAgdmFyIGVycm9yTG9jYXRpb25zID0gdGhpcy5maW5kRXJyb3JMb2NhdGlvbnMoc2lnbWEpOwoJICAgICAgICB2YXIgZXJyb3JNYWduaXR1ZGVzID0gdGhpcy5maW5kRXJyb3JNYWduaXR1ZGVzKG9tZWdhLCBlcnJvckxvY2F0aW9ucyk7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JMb2NhdGlvbnMubGVuZ3RoOyBpKyspIHsKCSAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHJlY2VpdmVkLmxlbmd0aCAtIDEgLSBmaWVsZC5sb2coZXJyb3JMb2NhdGlvbnNbaV0pOwoJICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkgewoJICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0JhZCBlcnJvciBsb2NhdGlvbicpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgcmVjZWl2ZWRbcG9zaXRpb25dID0gR2VuZXJpY0dGXzEkMS5kZWZhdWx0LmFkZE9yU3VidHJhY3QocmVjZWl2ZWRbcG9zaXRpb25dLCBlcnJvck1hZ25pdHVkZXNbaV0pOwoJICAgICAgICB9CgkgICAgfTsKCSAgICBSZWVkU29sb21vbkRlY29kZXIucHJvdG90eXBlLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobSA9IGZ1bmN0aW9uIChhLCBiLCBSIC8qaW50Ki8pIHsKCSAgICAgICAgLy8gQXNzdW1lIGEncyBkZWdyZWUgaXMgPj0gYidzCgkgICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkgewoJICAgICAgICAgICAgdmFyIHRlbXAgPSBhOwoJICAgICAgICAgICAgYSA9IGI7CgkgICAgICAgICAgICBiID0gdGVtcDsKCSAgICAgICAgfQoJICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkOwoJICAgICAgICB2YXIgckxhc3QgPSBhOwoJICAgICAgICB2YXIgciA9IGI7CgkgICAgICAgIHZhciB0TGFzdCA9IGZpZWxkLmdldFplcm8oKTsKCSAgICAgICAgdmFyIHQgPSBmaWVsZC5nZXRPbmUoKTsKCSAgICAgICAgLy8gUnVuIEV1Y2xpZGVhbiBhbGdvcml0aG0gdW50aWwgcidzIGRlZ3JlZSBpcyBsZXNzIHRoYW4gUi8yCgkgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IChSIC8gMiB8IDApKSB7CgkgICAgICAgICAgICB2YXIgckxhc3RMYXN0ID0gckxhc3Q7CgkgICAgICAgICAgICB2YXIgdExhc3RMYXN0ID0gdExhc3Q7CgkgICAgICAgICAgICByTGFzdCA9IHI7CgkgICAgICAgICAgICB0TGFzdCA9IHQ7CgkgICAgICAgICAgICAvLyBEaXZpZGUgckxhc3RMYXN0IGJ5IHJMYXN0LCB3aXRoIHF1b3RpZW50IGluIHEgYW5kIHJlbWFpbmRlciBpbiByCgkgICAgICAgICAgICBpZiAockxhc3QuaXNaZXJvKCkpIHsKCSAgICAgICAgICAgICAgICAvLyBPb3BzLCBFdWNsaWRlYW4gYWxnb3JpdGhtIGFscmVhZHkgdGVybWluYXRlZD8KCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb25fMS5kZWZhdWx0KCdyX3tpLTF9IHdhcyB6ZXJvJyk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICByID0gckxhc3RMYXN0OwoJICAgICAgICAgICAgdmFyIHEgPSBmaWVsZC5nZXRaZXJvKCk7CgkgICAgICAgICAgICB2YXIgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IHJMYXN0LmdldENvZWZmaWNpZW50KHJMYXN0LmdldERlZ3JlZSgpKTsKCSAgICAgICAgICAgIHZhciBkbHRJbnZlcnNlID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTsKCSAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpICYmICFyLmlzWmVybygpKSB7CgkgICAgICAgICAgICAgICAgdmFyIGRlZ3JlZURpZmYgPSByLmdldERlZ3JlZSgpIC0gckxhc3QuZ2V0RGVncmVlKCk7CgkgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7CgkgICAgICAgICAgICAgICAgcSA9IHEuYWRkT3JTdWJ0cmFjdChmaWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7CgkgICAgICAgICAgICAgICAgciA9IHIuYWRkT3JTdWJ0cmFjdChyTGFzdC5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHQgPSBxLm11bHRpcGx5KHRMYXN0KS5hZGRPclN1YnRyYWN0KHRMYXN0TGFzdCk7CgkgICAgICAgICAgICBpZiAoci5nZXREZWdyZWUoKSA+PSByTGFzdC5nZXREZWdyZWUoKSkgewoJICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCdEaXZpc2lvbiBhbGdvcml0aG0gZmFpbGVkIHRvIHJlZHVjZSBwb2x5bm9taWFsPycpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHZhciBzaWdtYVRpbGRlQXRaZXJvID0gdC5nZXRDb2VmZmljaWVudCgwKTsKCSAgICAgICAgaWYgKHNpZ21hVGlsZGVBdFplcm8gPT09IDApIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbl8xLmRlZmF1bHQoJ3NpZ21hVGlsZGUoMCkgd2FzIHplcm8nKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgaW52ZXJzZSA9IGZpZWxkLmludmVyc2Uoc2lnbWFUaWxkZUF0WmVybyk7CgkgICAgICAgIHZhciBzaWdtYSA9IHQubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7CgkgICAgICAgIHZhciBvbWVnYSA9IHIubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7CgkgICAgICAgIHJldHVybiBbc2lnbWEsIG9tZWdhXTsKCSAgICB9OwoJICAgIFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGUuZmluZEVycm9yTG9jYXRpb25zID0gZnVuY3Rpb24gKGVycm9yTG9jYXRvcikgewoJICAgICAgICAvLyBUaGlzIGlzIGEgZGlyZWN0IGFwcGxpY2F0aW9uIG9mIENoaWVuJ3Mgc2VhcmNoCgkgICAgICAgIHZhciBudW1FcnJvcnMgPSBlcnJvckxvY2F0b3IuZ2V0RGVncmVlKCk7CgkgICAgICAgIGlmIChudW1FcnJvcnMgPT09IDEpIHsgLy8gc2hvcnRjdXQKCSAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW2Vycm9yTG9jYXRvci5nZXRDb2VmZmljaWVudCgxKV0pOwoJICAgICAgICB9CgkgICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpOwoJICAgICAgICB2YXIgZSA9IDA7CgkgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7CgkgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykgewoJICAgICAgICAgICAgaWYgKGVycm9yTG9jYXRvci5ldmFsdWF0ZUF0KGkpID09PSAwKSB7CgkgICAgICAgICAgICAgICAgcmVzdWx0W2VdID0gZmllbGQuaW52ZXJzZShpKTsKCSAgICAgICAgICAgICAgICBlKys7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGUgIT09IG51bUVycm9ycykgewoJICAgICAgICAgICAgdGhyb3cgbmV3IFJlZWRTb2xvbW9uRXhjZXB0aW9uXzEuZGVmYXVsdCgnRXJyb3IgbG9jYXRvciBkZWdyZWUgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIHJvb3RzJyk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHJlc3VsdDsKCSAgICB9OwoJICAgIFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGUuZmluZEVycm9yTWFnbml0dWRlcyA9IGZ1bmN0aW9uIChlcnJvckV2YWx1YXRvciwgZXJyb3JMb2NhdGlvbnMpIHsKCSAgICAgICAgLy8gVGhpcyBpcyBkaXJlY3RseSBhcHBseWluZyBGb3JuZXkncyBGb3JtdWxhCgkgICAgICAgIHZhciBzID0gZXJyb3JMb2NhdGlvbnMubGVuZ3RoOwoJICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkocyk7CgkgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7CgkgICAgICAgICAgICB2YXIgeGlJbnZlcnNlID0gZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7CgkgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxOwoJICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHsKCSAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaikgewoJICAgICAgICAgICAgICAgICAgICAvLyBkZW5vbWluYXRvciA9IGZpZWxkLm11bHRpcGx5KGRlbm9taW5hdG9yLAoJICAgICAgICAgICAgICAgICAgICAvLyAgICBHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdCgxLCBmaWVsZC5tdWx0aXBseShlcnJvckxvY2F0aW9uc1tqXSwgeGlJbnZlcnNlKSkpCgkgICAgICAgICAgICAgICAgICAgIC8vIEFib3ZlIHNob3VsZCB3b3JrIGJ1dCBmYWlscyBvbiBzb21lIEFwcGxlIGFuZCBMaW51eCBKREtzIGR1ZSB0byBhIEhvdHNwb3QgYnVnLgoJICAgICAgICAgICAgICAgICAgICAvLyBCZWxvdyBpcyBhIGZ1bm55LWxvb2tpbmcgd29ya2Fyb3VuZCBmcm9tIFN0ZXZlbiBQYXJrZXMKCSAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBmaWVsZC5tdWx0aXBseShlcnJvckxvY2F0aW9uc1tqXSwgeGlJbnZlcnNlKTsKCSAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1QbHVzMSA9ICh0ZXJtICYgMHgxKSA9PT0gMCA/IHRlcm0gfCAxIDogdGVybSAmIH4xOwoJICAgICAgICAgICAgICAgICAgICBkZW5vbWluYXRvciA9IGZpZWxkLm11bHRpcGx5KGRlbm9taW5hdG9yLCB0ZXJtUGx1czEpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHJlc3VsdFtpXSA9IGZpZWxkLm11bHRpcGx5KGVycm9yRXZhbHVhdG9yLmV2YWx1YXRlQXQoeGlJbnZlcnNlKSwgZmllbGQuaW52ZXJzZShkZW5vbWluYXRvcikpOwoJICAgICAgICAgICAgaWYgKGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSAhPT0gMCkgewoJICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGZpZWxkLm11bHRpcGx5KHJlc3VsdFtpXSwgeGlJbnZlcnNlKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gcmVzdWx0OwoJICAgIH07CgkgICAgcmV0dXJuIFJlZWRTb2xvbW9uRGVjb2RlcjsKCX0oKSk7CglSZWVkU29sb21vbkRlY29kZXIkMS5kZWZhdWx0ID0gUmVlZFNvbG9tb25EZWNvZGVyOwoKCXZhciBCaXRNYXRyaXhQYXJzZXIkMSA9IHt9OwoKCXZhciBWZXJzaW9uJDEgPSB7fTsKCgl2YXIgRm9ybWF0SW5mb3JtYXRpb24kMSA9IHt9OwoKCXZhciBFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHt9OwoKCXZhciBBcmd1bWVudEV4Y2VwdGlvbiQxID0ge307CgoJdmFyIF9fZXh0ZW5kcyQzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKCSAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHwKCSAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9OwoJICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICB9OwoJICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH0KCSAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpOwoJICAgIH07Cgl9KSgpOwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEFyZ3VtZW50RXhjZXB0aW9uJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBFeGNlcHRpb25fMSA9IEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uCgkgKi8KCXZhciBBcmd1bWVudEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHsKCSAgICBfX2V4dGVuZHMkMyhBcmd1bWVudEV4Y2VwdGlvbiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBBcmd1bWVudEV4Y2VwdGlvbigpIHsKCSAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoJICAgIH0KCSAgICBBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0FyZ3VtZW50RXhjZXB0aW9uJzsKCSAgICByZXR1cm4gQXJndW1lbnRFeGNlcHRpb247Cgl9KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTsKCUFyZ3VtZW50RXhjZXB0aW9uJDEuZGVmYXVsdCA9IEFyZ3VtZW50RXhjZXB0aW9uOwoKCShmdW5jdGlvbiAoZXhwb3J0cykgewoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CglleHBvcnRzLkVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzID0gdm9pZCAwOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki8KCXZhciBBcmd1bWVudEV4Y2VwdGlvbl8xID0gQXJndW1lbnRFeGNlcHRpb24kMTsKCXZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiQxOwoJdmFyIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzOwoJKGZ1bmN0aW9uIChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcykgewoJICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzWyJMIl0gPSAwXSA9ICJMIjsKCSAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1siTSJdID0gMV0gPSAiTSI7CgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbIlEiXSA9IDJdID0gIlEiOwoJICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzWyJIIl0gPSAzXSA9ICJIIjsKCX0pKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzID0gZXhwb3J0cy5FcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyB8fCAoZXhwb3J0cy5FcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyA9IHt9KSk7CgkvKioKCSAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi41LjEuIFRoaXMgZW51bSBlbmNhcHN1bGF0ZXMgdGhlIGZvdXIgZXJyb3IgY29ycmVjdGlvbiBsZXZlbHMKCSAqIGRlZmluZWQgYnkgdGhlIFFSIGNvZGUgc3RhbmRhcmQuPC9wPgoJICoKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBFcnJvckNvcnJlY3Rpb25MZXZlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBFcnJvckNvcnJlY3Rpb25MZXZlbCh2YWx1ZSwgc3RyaW5nVmFsdWUsIGJpdHMgLyppbnQqLykgewoJICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7CgkgICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTsKCSAgICAgICAgdGhpcy5iaXRzID0gYml0czsKCSAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuc2V0KGJpdHMsIHRoaXMpOwoJICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfVkFMVUUuc2V0KHZhbHVlLCB0aGlzKTsKCSAgICB9CgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTsKCSAgICB9OwoJICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLnByb3RvdHlwZS5nZXRCaXRzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5iaXRzOwoJICAgIH07CgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzKSB7CgkgICAgICAgIHN3aXRjaCAocykgewoJICAgICAgICAgICAgY2FzZSAnTCc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5MOwoJICAgICAgICAgICAgY2FzZSAnTSc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5NOwoJICAgICAgICAgICAgY2FzZSAnUSc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5ROwoJICAgICAgICAgICAgY2FzZSAnSCc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5IOwoJICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdChzICsgJ25vdCBhdmFpbGFibGUnKTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTsKCSAgICB9OwoJICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykgewoJICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRXJyb3JDb3JyZWN0aW9uTGV2ZWwpKSB7CgkgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIG90aGVyID0gbzsKCSAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHBhcmFtIGJpdHMgaW50IGNvbnRhaW5pbmcgdGhlIHR3byBiaXRzIGVuY29kaW5nIGEgUVIgQ29kZSdzIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwKCSAgICAgKiBAcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsIHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsCgkgICAgICovCgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZm9yQml0cyA9IGZ1bmN0aW9uIChiaXRzIC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKGJpdHMgPCAwIHx8IGJpdHMgPj0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuc2l6ZSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuZ2V0KGJpdHMpOwoJICAgIH07CgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMgPSBuZXcgTWFwKCk7CgkgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX1ZBTFVFID0gbmV3IE1hcCgpOwoJICAgIC8qKiBMID0gfjclIGNvcnJlY3Rpb24gKi8KCSAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5MID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLkwsICdMJywgMHgwMSk7CgkgICAgLyoqIE0gPSB+MTUlIGNvcnJlY3Rpb24gKi8KCSAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5NID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLk0sICdNJywgMHgwMCk7CgkgICAgLyoqIFEgPSB+MjUlIGNvcnJlY3Rpb24gKi8KCSAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5RID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLlEsICdRJywgMHgwMyk7CgkgICAgLyoqIEggPSB+MzAlIGNvcnJlY3Rpb24gKi8KCSAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5IID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLkgsICdIJywgMHgwMik7CgkgICAgcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsOwoJfSgpKTsKCWV4cG9ydHMuZGVmYXVsdCA9IEVycm9yQ29ycmVjdGlvbkxldmVsOwoKCX0oRXJyb3JDb3JyZWN0aW9uTGV2ZWwpKTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fdmFsdWVzJDYgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHsKCSAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDsKCSAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTsKCSAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09ICJudW1iZXIiKSByZXR1cm4gewoJICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7CgkgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwOwoJICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9OwoJICAgICAgICB9CgkgICAgfTsKCSAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyAiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS4iIDogIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC4iKTsKCX07CglPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybWF0SW5mb3JtYXRpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki8KCXZhciBFcnJvckNvcnJlY3Rpb25MZXZlbF8xID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWw7Cgl2YXIgSW50ZWdlcl8xID0gSW50ZWdlciQxOwoJLyoqCgkgKiA8cD5FbmNhcHN1bGF0ZXMgYSBRUiBDb2RlJ3MgZm9ybWF0IGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGRhdGEgbWFzayB1c2VkIGFuZAoJICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqIEBzZWUgRGF0YU1hc2sKCSAqIEBzZWUgRXJyb3JDb3JyZWN0aW9uTGV2ZWwKCSAqLwoJdmFyIEZvcm1hdEluZm9ybWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIEZvcm1hdEluZm9ybWF0aW9uKGZvcm1hdEluZm8gLyppbnQqLykgewoJICAgICAgICAvLyBCaXRzIDMsNAoJICAgICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWxfMS5kZWZhdWx0LmZvckJpdHMoKGZvcm1hdEluZm8gPj4gMykgJiAweDAzKTsKCSAgICAgICAgLy8gQm90dG9tIDMgYml0cwoJICAgICAgICB0aGlzLmRhdGFNYXNrID0gLyooYnl0ZSkgKi8gKGZvcm1hdEluZm8gJiAweDA3KTsKCSAgICB9CgkgICAgRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyA9IGZ1bmN0aW9uIChhIC8qaW50Ki8sIGIgLyppbnQqLykgewoJICAgICAgICByZXR1cm4gSW50ZWdlcl8xLmRlZmF1bHQuYml0Q291bnQoYSBeIGIpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHBhcmFtIG1hc2tlZEZvcm1hdEluZm8xIGZvcm1hdCBpbmZvIGluZGljYXRvciwgd2l0aCBtYXNrIHN0aWxsIGFwcGxpZWQKCSAgICAgKiBAcGFyYW0gbWFza2VkRm9ybWF0SW5mbzIgc2Vjb25kIGNvcHkgb2Ygc2FtZSBpbmZvOyBib3RoIGFyZSBjaGVja2VkIGF0IHRoZSBzYW1lIHRpbWUKCSAgICAgKiAgdG8gZXN0YWJsaXNoIGJlc3QgbWF0Y2gKCSAgICAgKiBAcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb3JtYXQgaXQgc3BlY2lmaWVzLCBvciB7QGNvZGUgbnVsbH0KCSAgICAgKiAgaWYgZG9lc24ndCBzZWVtIHRvIG1hdGNoIGFueSBrbm93biBwYXR0ZXJuCgkgICAgICovCgkgICAgRm9ybWF0SW5mb3JtYXRpb24uZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24gPSBmdW5jdGlvbiAobWFza2VkRm9ybWF0SW5mbzEgLyppbnQqLywgbWFza2VkRm9ybWF0SW5mbzIgLyppbnQqLykgewoJICAgICAgICB2YXIgZm9ybWF0SW5mbyA9IEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEsIG1hc2tlZEZvcm1hdEluZm8yKTsKCSAgICAgICAgaWYgKGZvcm1hdEluZm8gIT09IG51bGwpIHsKCSAgICAgICAgICAgIHJldHVybiBmb3JtYXRJbmZvOwoJICAgICAgICB9CgkgICAgICAgIC8vIFNob3VsZCByZXR1cm4gbnVsbCwgYnV0LCBzb21lIFFSIGNvZGVzIGFwcGFyZW50bHkKCSAgICAgICAgLy8gZG8gbm90IG1hc2sgdGhpcyBpbmZvLiBUcnkgYWdhaW4gYnkgYWN0dWFsbHkgbWFza2luZyB0aGUgcGF0dGVybgoJICAgICAgICAvLyBmaXJzdAoJICAgICAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSBeIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIsIG1hc2tlZEZvcm1hdEluZm8yIF4gRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fTUFTS19RUik7CgkgICAgfTsKCSAgICBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uID0gZnVuY3Rpb24gKG1hc2tlZEZvcm1hdEluZm8xIC8qaW50Ki8sIG1hc2tlZEZvcm1hdEluZm8yIC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIGVfMSwgX2E7CgkgICAgICAgIC8vIEZpbmQgdGhlIGludCBpbiBGT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQIHdpdGggZmV3ZXN0IGJpdHMgZGlmZmVyaW5nCgkgICAgICAgIHZhciBiZXN0RGlmZmVyZW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOwoJICAgICAgICB2YXIgYmVzdEZvcm1hdEluZm8gPSAwOwoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyQ2KEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVApLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgdmFyIGRlY29kZUluZm8gPSBfYy52YWx1ZTsKCSAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SW5mbyA9IGRlY29kZUluZm9bMF07CgkgICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8xIHx8IHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8yKSB7CgkgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGV4YWN0IG1hdGNoCgkgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oZGVjb2RlSW5mb1sxXSk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIHZhciBiaXRzRGlmZmVyZW5jZSA9IEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcobWFza2VkRm9ybWF0SW5mbzEsIHRhcmdldEluZm8pOwoJICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7CgkgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTsKCSAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgaWYgKG1hc2tlZEZvcm1hdEluZm8xICE9PSBtYXNrZWRGb3JtYXRJbmZvMikgewoJICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHRyeSB0aGUgb3RoZXIgb3B0aW9uCgkgICAgICAgICAgICAgICAgICAgIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvMiwgdGFyZ2V0SW5mbyk7CgkgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SW5mbyA9IGRlY29kZUluZm9bMV07CgkgICAgICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9CgkgICAgICAgIGZpbmFsbHkgewoJICAgICAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gSGFtbWluZyBkaXN0YW5jZSBvZiB0aGUgMzIgbWFza2VkIGNvZGVzIGlzIDcsIGJ5IGNvbnN0cnVjdGlvbiwgc28gPD0gMyBiaXRzCgkgICAgICAgIC8vIGRpZmZlcmluZyBtZWFucyB3ZSBmb3VuZCBhIG1hdGNoCgkgICAgICAgIGlmIChiZXN0RGlmZmVyZW5jZSA8PSAzKSB7CgkgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGJlc3RGb3JtYXRJbmZvKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gbnVsbDsKCSAgICB9OwoJICAgIEZvcm1hdEluZm9ybWF0aW9uLnByb3RvdHlwZS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7CgkgICAgfTsKCSAgICBGb3JtYXRJbmZvcm1hdGlvbi5wcm90b3R5cGUuZ2V0RGF0YU1hc2sgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmRhdGFNYXNrOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIEZvcm1hdEluZm9ybWF0aW9uLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuICh0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsLmdldEJpdHMoKSA8PCAzKSB8IHRoaXMuZGF0YU1hc2s7CgkgICAgfTsKCSAgICAvKkBPdmVycmlkZSovCgkgICAgRm9ybWF0SW5mb3JtYXRpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7CgkgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBGb3JtYXRJbmZvcm1hdGlvbikpIHsKCSAgICAgICAgICAgIHJldHVybiBmYWxzZTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgb3RoZXIgPSBvOwoJICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9PT0gb3RoZXIuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgJiYKCSAgICAgICAgICAgIHRoaXMuZGF0YU1hc2sgPT09IG90aGVyLmRhdGFNYXNrOwoJICAgIH07CgkgICAgRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fTUFTS19RUiA9IDB4NTQxMjsKCSAgICAvKioKCSAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYsIEFubmV4IEMsIFRhYmxlIEMuMQoJICAgICAqLwoJICAgIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAgPSBbCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1NDEyLCAweDAwXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1MTI1LCAweDAxXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1RTdDLCAweDAyXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1QjRCLCAweDAzXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0NUY5LCAweDA0XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0MENFLCAweDA1XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0Rjk3LCAweDA2XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0QUEwLCAweDA3XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3N0M0LCAweDA4XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3MkYzLCAweDA5XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3REFBLCAweDBBXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3ODlELCAweDBCXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2NjJGLCAweDBDXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2MzE4LCAweDBEXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2QzQxLCAweDBFXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2OTc2LCAweDBGXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxNjg5LCAweDEwXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxM0JFLCAweDExXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxQ0U3LCAweDEyXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxOUQwLCAweDEzXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwNzYyLCAweDE0XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwMjU1LCAweDE1XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwRDBDLCAweDE2XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwODNCLCAweDE3XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzNTVGLCAweDE4XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzMDY4LCAweDE5XSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzRjMxLCAweDFBXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzQTA2LCAweDFCXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyNEI0LCAweDFDXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyMTgzLCAweDFEXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyRURBLCAweDFFXSksCgkgICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyQkVELCAweDFGXSksCgkgICAgXTsKCSAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb247Cgl9KCkpOwoJRm9ybWF0SW5mb3JtYXRpb24kMS5kZWZhdWx0ID0gRm9ybWF0SW5mb3JtYXRpb247CgoJdmFyIEVDQmxvY2tzJDEgPSB7fTsKCgl2YXIgX192YWx1ZXMkNSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykgewoJICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwOwoJICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pOwoJICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gIm51bWJlciIpIHJldHVybiB7CgkgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7CgkgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07CgkgICAgICAgIH0KCSAgICB9OwoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/ICJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLiIgOiAiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLiIpOwoJfTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShFQ0Jsb2NrcyQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKioKCSAqIDxwPkVuY2Fwc3VsYXRlcyBhIHNldCBvZiBlcnJvci1jb3JyZWN0aW9uIGJsb2NrcyBpbiBvbmUgc3ltYm9sIHZlcnNpb24uIE1vc3QgdmVyc2lvbnMgd2lsbAoJICogdXNlIGJsb2NrcyBvZiBkaWZmZXJpbmcgc2l6ZXMgd2l0aGluIG9uZSB2ZXJzaW9uLCBzbywgdGhpcyBlbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yCgkgKiBlYWNoIHNldCBvZiBibG9ja3MuIEl0IGFsc28gaG9sZHMgdGhlIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBwZXIgYmxvY2sgc2luY2UgaXQKCSAqIHdpbGwgYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBibG9ja3Mgd2l0aGluIG9uZSB2ZXJzaW9uLjwvcD4KCSAqLwoJdmFyIEVDQmxvY2tzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIEVDQmxvY2tzKGVjQ29kZXdvcmRzUGVyQmxvY2sgLyppbnQqLykgewoJICAgICAgICB2YXIgZWNCbG9ja3MgPSBbXTsKCSAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHsKCSAgICAgICAgICAgIGVjQmxvY2tzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayA9IGVjQ29kZXdvcmRzUGVyQmxvY2s7CgkgICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrczsKCSAgICB9CgkgICAgRUNCbG9ja3MucHJvdG90eXBlLmdldEVDQ29kZXdvcmRzUGVyQmxvY2sgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2s7CgkgICAgfTsKCSAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0TnVtQmxvY2tzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgZV8xLCBfYTsKCSAgICAgICAgdmFyIHRvdGFsID0gMDsKCSAgICAgICAgdmFyIGVjQmxvY2tzID0gdGhpcy5lY0Jsb2NrczsKCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIGZvciAodmFyIGVjQmxvY2tzXzEgPSBfX3ZhbHVlcyQ1KGVjQmxvY2tzKSwgZWNCbG9ja3NfMV8xID0gZWNCbG9ja3NfMS5uZXh0KCk7ICFlY0Jsb2Nrc18xXzEuZG9uZTsgZWNCbG9ja3NfMV8xID0gZWNCbG9ja3NfMS5uZXh0KCkpIHsKCSAgICAgICAgICAgICAgICB2YXIgZWNCbG9jayA9IGVjQmxvY2tzXzFfMS52YWx1ZTsKCSAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH0KCSAgICAgICAgZmluYWxseSB7CgkgICAgICAgICAgICB0cnkgewoJICAgICAgICAgICAgICAgIGlmIChlY0Jsb2Nrc18xXzEgJiYgIWVjQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGVjQmxvY2tzXzEucmV0dXJuKSkgX2EuY2FsbChlY0Jsb2Nrc18xKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gdG90YWw7CgkgICAgfTsKCSAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0VG90YWxFQ0NvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayAqIHRoaXMuZ2V0TnVtQmxvY2tzKCk7CgkgICAgfTsKCSAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0RUNCbG9ja3MgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzOwoJICAgIH07CgkgICAgcmV0dXJuIEVDQmxvY2tzOwoJfSgpKTsKCUVDQmxvY2tzJDEuZGVmYXVsdCA9IEVDQmxvY2tzOwoKCXZhciBFQ0IkMSA9IHt9OwoKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShFQ0IkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLyoqCgkgKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yIG9uZSBlcnJvci1jb3JyZWN0aW9uIGJsb2NrIGluIG9uZSBzeW1ib2wgdmVyc2lvbi4KCSAqIFRoaXMgaW5jbHVkZXMgdGhlIG51bWJlciBvZiBkYXRhIGNvZGV3b3JkcywgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgYSBibG9jayB3aXRoIHRoZXNlCgkgKiBwYXJhbWV0ZXJzIGlzIHVzZWQgY29uc2VjdXRpdmVseSBpbiB0aGUgUVIgY29kZSB2ZXJzaW9uJ3MgZm9ybWF0LjwvcD4KCSAqLwoJdmFyIEVDQiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBFQ0IoY291bnQgLyppbnQqLywgZGF0YUNvZGV3b3JkcyAvKmludCovKSB7CgkgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDsKCSAgICAgICAgdGhpcy5kYXRhQ29kZXdvcmRzID0gZGF0YUNvZGV3b3JkczsKCSAgICB9CgkgICAgRUNCLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7CgkgICAgfTsKCSAgICBFQ0IucHJvdG90eXBlLmdldERhdGFDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2Rld29yZHM7CgkgICAgfTsKCSAgICByZXR1cm4gRUNCOwoJfSgpKTsKCUVDQiQxLmRlZmF1bHQgPSBFQ0I7CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCXZhciBfX3ZhbHVlcyQ0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7CgkgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7CgkgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7CgkgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSAibnVtYmVyIikgcmV0dXJuIHsKCSAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkgewoJICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDsKCSAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gIk9iamVjdCBpcyBub3QgaXRlcmFibGUuIiA6ICJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuIik7Cgl9OwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb24kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki8KCXZhciBCaXRNYXRyaXhfMSQzID0gQml0TWF0cml4JDE7Cgl2YXIgRm9ybWF0SW5mb3JtYXRpb25fMSQxID0gRm9ybWF0SW5mb3JtYXRpb24kMTsKCXZhciBFQ0Jsb2Nrc18xID0gRUNCbG9ja3MkMTsKCXZhciBFQ0JfMSA9IEVDQiQxOwoJdmFyIEZvcm1hdEV4Y2VwdGlvbl8xJDIgPSBGb3JtYXRFeGNlcHRpb24kMTsKCXZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQyID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJDE7CgkvKioKCSAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBECgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIFZlcnNpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyIC8qaW50Ki8sIGFsaWdubWVudFBhdHRlcm5DZW50ZXJzKSB7CgkgICAgICAgIHZhciBlXzEsIF9hOwoJICAgICAgICB2YXIgZWNCbG9ja3MgPSBbXTsKCSAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHsKCSAgICAgICAgICAgIGVjQmxvY2tzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7CgkgICAgICAgIHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnMgPSBhbGlnbm1lbnRQYXR0ZXJuQ2VudGVyczsKCSAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IGVjQmxvY2tzOwoJICAgICAgICB2YXIgdG90YWwgPSAwOwoJICAgICAgICB2YXIgZWNDb2Rld29yZHMgPSBlY0Jsb2Nrc1swXS5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCk7CgkgICAgICAgIHZhciBlY2JBcnJheSA9IGVjQmxvY2tzWzBdLmdldEVDQmxvY2tzKCk7CgkgICAgICAgIHRyeSB7CgkgICAgICAgICAgICBmb3IgKHZhciBlY2JBcnJheV8xID0gX192YWx1ZXMkNChlY2JBcnJheSksIGVjYkFycmF5XzFfMSA9IGVjYkFycmF5XzEubmV4dCgpOyAhZWNiQXJyYXlfMV8xLmRvbmU7IGVjYkFycmF5XzFfMSA9IGVjYkFycmF5XzEubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgdmFyIGVjQmxvY2sgPSBlY2JBcnJheV8xXzEudmFsdWU7CgkgICAgICAgICAgICAgICAgdG90YWwgKz0gZWNCbG9jay5nZXRDb3VudCgpICogKGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpICsgZWNDb2Rld29yZHMpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9CgkgICAgICAgIGZpbmFsbHkgewoJICAgICAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgICAgICBpZiAoZWNiQXJyYXlfMV8xICYmICFlY2JBcnJheV8xXzEuZG9uZSAmJiAoX2EgPSBlY2JBcnJheV8xLnJldHVybikpIF9hLmNhbGwoZWNiQXJyYXlfMSk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgdGhpcy50b3RhbENvZGV3b3JkcyA9IHRvdGFsOwoJICAgIH0KCSAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRWZXJzaW9uTnVtYmVyID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uTnVtYmVyOwoJICAgIH07CgkgICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzOwoJICAgIH07CgkgICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0VG90YWxDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzOwoJICAgIH07CgkgICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0RGltZW5zaW9uRm9yVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIDE3ICsgNCAqIHRoaXMudmVyc2lvbk51bWJlcjsKCSAgICB9OwoJICAgIFZlcnNpb24ucHJvdG90eXBlLmdldEVDQmxvY2tzRm9yTGV2ZWwgPSBmdW5jdGlvbiAoZWNMZXZlbCkgewoJICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2Nrc1tlY0xldmVsLmdldFZhbHVlKCldOwoJICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogb3JpZ2luYWwgd2FzIHVzaW5nIG9yZGluYWwsIGFuZCB1c2luZyB0aGUgb3JkZXIgb2YgbGV2ZWxzIGFzIGRlZmluZWQgaW4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwgZW51bSAoTE1RSCkKCSAgICAgICAgLy8gSSB3aWxsIHVzZSB0aGUgZGlyZWN0IHZhbHVlIGZyb20gRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgZW51bSB3aGljaCBpbiB0eXBlc2NyaXB0IGdvZXMgdG8gYSBudW1iZXIKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPkRlZHVjZXMgdmVyc2lvbiBpbmZvcm1hdGlvbiBwdXJlbHkgZnJvbSBRUiBDb2RlIGRpbWVuc2lvbnMuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGRpbWVuc2lvbiBkaW1lbnNpb24gaW4gbW9kdWxlcwoJICAgICAqIEByZXR1cm4gVmVyc2lvbiBmb3IgYSBRUiBDb2RlIG9mIHRoYXQgZGltZW5zaW9uCgkgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCAxIG1vZCA0CgkgICAgICovCgkgICAgVmVyc2lvbi5nZXRQcm92aXNpb25hbFZlcnNpb25Gb3JEaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltZW5zaW9uIC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKGRpbWVuc2lvbiAlIDQgIT09IDEpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMSQyLmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbkZvck51bWJlcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiovKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEkMi5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlciA9IGZ1bmN0aW9uICh2ZXJzaW9uTnVtYmVyIC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPCAxIHx8IHZlcnNpb25OdW1iZXIgPiA0MCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDIuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBWZXJzaW9uLlZFUlNJT05TW3ZlcnNpb25OdW1iZXIgLSAxXTsKCSAgICB9OwoJICAgIFZlcnNpb24uZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uID0gZnVuY3Rpb24gKHZlcnNpb25CaXRzIC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIGJlc3REaWZmZXJlbmNlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7CgkgICAgICAgIHZhciBiZXN0VmVyc2lvbiA9IDA7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVmVyc2lvbi5WRVJTSU9OX0RFQ09ERV9JTkZPLmxlbmd0aDsgaSsrKSB7CgkgICAgICAgICAgICB2YXIgdGFyZ2V0VmVyc2lvbiA9IFZlcnNpb24uVkVSU0lPTl9ERUNPREVfSU5GT1tpXTsKCSAgICAgICAgICAgIC8vIERvIHRoZSB2ZXJzaW9uIGluZm8gYml0cyBtYXRjaCBleGFjdGx5PyBkb25lLgoJICAgICAgICAgICAgaWYgKHRhcmdldFZlcnNpb24gPT09IHZlcnNpb25CaXRzKSB7CgkgICAgICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlcihpICsgNyk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VlIGlmIHRoaXMgaXMgdGhlIGNsb3Nlc3QgdG8gYSByZWFsIHZlcnNpb24gaW5mbyBiaXQgc3RyaW5nCgkgICAgICAgICAgICAvLyB3ZSBoYXZlIHNlZW4gc28gZmFyCgkgICAgICAgICAgICB2YXIgYml0c0RpZmZlcmVuY2UgPSBGb3JtYXRJbmZvcm1hdGlvbl8xJDEuZGVmYXVsdC5udW1CaXRzRGlmZmVyaW5nKHZlcnNpb25CaXRzLCB0YXJnZXRWZXJzaW9uKTsKCSAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7CgkgICAgICAgICAgICAgICAgYmVzdFZlcnNpb24gPSBpICsgNzsKCSAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIC8vIFdlIGNhbiB0b2xlcmF0ZSB1cCB0byAzIGJpdHMgb2YgZXJyb3Igc2luY2Ugbm8gdHdvIHZlcnNpb24gaW5mbyBjb2Rld29yZHMgd2lsbAoJICAgICAgICAvLyBkaWZmZXIgaW4gbGVzcyB0aGFuIDggYml0cy4KCSAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHsKCSAgICAgICAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIoYmVzdFZlcnNpb24pOwoJICAgICAgICB9CgkgICAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgY2xvc2UgZW5vdWdoIG1hdGNoLCBmYWlsCgkgICAgICAgIHJldHVybiBudWxsOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IEUKCSAgICAgKi8KCSAgICBWZXJzaW9uLnByb3RvdHlwZS5idWlsZEZ1bmN0aW9uUGF0dGVybiA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpOwoJICAgICAgICB2YXIgYml0TWF0cml4ID0gbmV3IEJpdE1hdHJpeF8xJDMuZGVmYXVsdChkaW1lbnNpb24pOwoJICAgICAgICAvLyBUb3AgbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdAoJICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIDAsIDksIDkpOwoJICAgICAgICAvLyBUb3AgcmlnaHQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXQKCSAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbihkaW1lbnNpb24gLSA4LCAwLCA4LCA5KTsKCSAgICAgICAgLy8gQm90dG9tIGxlZnQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXQKCSAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSA4LCA5LCA4KTsKCSAgICAgICAgLy8gQWxpZ25tZW50IHBhdHRlcm5zCgkgICAgICAgIHZhciBtYXggPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzLmxlbmd0aDsKCSAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXg7IHgrKykgewoJICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3hdIC0gMjsKCSAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWF4OyB5KyspIHsKCSAgICAgICAgICAgICAgICBpZiAoKHggPT09IDAgJiYgKHkgPT09IDAgfHwgeSA9PT0gbWF4IC0gMSkpIHx8ICh4ID09PSBtYXggLSAxICYmIHkgPT09IDApKSB7CgkgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudCBwYXR0ZXJucyBuZWFyIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnMKCSAgICAgICAgICAgICAgICAgICAgY29udGludWU7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIC8vIFZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuCgkgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oNiwgOSwgMSwgZGltZW5zaW9uIC0gMTcpOwoJICAgICAgICAvLyBIb3Jpem9udGFsIHRpbWluZyBwYXR0ZXJuCgkgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oOSwgNiwgZGltZW5zaW9uIC0gMTcsIDEpOwoJICAgICAgICBpZiAodGhpcy52ZXJzaW9uTnVtYmVyID4gNikgewoJICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvLCB0b3AgcmlnaHQKCSAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gMTEsIDAsIDMsIDYpOwoJICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvLCBib3R0b20gbGVmdAoJICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSAxMSwgNiwgMyk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGJpdE1hdHJpeDsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBWZXJzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuICcnICsgdGhpcy52ZXJzaW9uTnVtYmVyOwoJICAgIH07CgkgICAgLyoqCgkgICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRC4KCSAgICAgICAqIEVsZW1lbnQgaSByZXByZXNlbnRzIHRoZSByYXcgdmVyc2lvbiBiaXRzIHRoYXQgc3BlY2lmeSB2ZXJzaW9uIGkgKyA3CgkgICAgICAgKi8KCSAgICBWZXJzaW9uLlZFUlNJT05fREVDT0RFX0lORk8gPSBJbnQzMkFycmF5LmZyb20oWwoJICAgICAgICAweDA3Qzk0LCAweDA4NUJDLCAweDA5QTk5LCAweDBBNEQzLCAweDBCQkY2LAoJICAgICAgICAweDBDNzYyLCAweDBEODQ3LCAweDBFNjBELCAweDBGOTI4LCAweDEwQjc4LAoJICAgICAgICAweDExNDVELCAweDEyQTE3LCAweDEzNTMyLCAweDE0OUE2LCAweDE1NjgzLAoJICAgICAgICAweDE2OEM5LCAweDE3N0VDLCAweDE4RUM0LCAweDE5MUUxLCAweDFBRkFCLAoJICAgICAgICAweDFCMDhFLCAweDFDQzFBLCAweDFEMzNGLCAweDFFRDc1LCAweDFGMjUwLAoJICAgICAgICAweDIwOUQ1LCAweDIxNkYwLCAweDIyOEJBLCAweDIzNzlGLCAweDI0QjBCLAoJICAgICAgICAweDI1NDJFLCAweDI2QTY0LCAweDI3NTQxLCAweDI4QzY5CgkgICAgXSk7CgkgICAgLyoqCgkgICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgNi41LjEgVGFibGUgOQoJICAgICAgICovCgkgICAgVmVyc2lvbi5WRVJTSU9OUyA9IFsKCSAgICAgICAgbmV3IFZlcnNpb24oMSwgbmV3IEludDMyQXJyYXkoMCksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoNywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxMCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxMywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxNywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgOSkpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMiwgSW50MzJBcnJheS5mcm9tKFs2LCAxOF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDEwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAzNCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE2LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAyOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAyMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMywgSW50MzJBcnJheS5mcm9tKFs2LCAyMl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE1LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA1NSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA0NCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxMykpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA4MCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAyNCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA5KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbig1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDEwOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCA0MykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExKSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTIpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDYsIEludDMyQXJyYXkuZnJvbShbNiwgMzRdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgNjgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDcsIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIDM4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDc4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDMxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTMpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxNCkpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNCwgNDJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgOTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMzgpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzOSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxOCksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE5KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTUpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDksIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCAzNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDM3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMykpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMTAsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDY4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgNjkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDMpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA0NCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxOSksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDIwKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTYpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDExLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIwLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA4MSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA1MCksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDUxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTIpLCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAxMykpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMTIsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDkyKSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgOTMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMzYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAyMCksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDEzLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2Ml0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMzcpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAzOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAyMCksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDEyLCAxMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDEyKSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigxNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDYsIDY2XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA0MCksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDQxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDE3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDEzKSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigxNSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDgsIDcwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDg3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgODgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgNDEpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCA0MikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDEzKSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigxNiwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDk4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgOTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNywgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCA0NikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMTkpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAyMCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMTcsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxMDcpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAxMDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMjIpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgMTUpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDE4LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTIwKSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDksIDQzKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxOSwgMTUpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDE5LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTEzKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTE0KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDQ0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDQ1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAyMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDksIDEzKSwgbmV3IEVDQl8xLmRlZmF1bHQoMTYsIDE0KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigyMCwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDEwNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDEwOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgzLCA0MSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCA0MikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMTYpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDIxLCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDExNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDExNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgNDIpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMTcpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDIyLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDExMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNiwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMzQsIDEzKSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigyMywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIxKSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNiwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgMTYpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDI0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1NCwgODAsIDEwNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMTcpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMTgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTYsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMwLCAxNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE3KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigyNSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMTA2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTA3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDgsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMjYsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxMTUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMjgsIDIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMzMsIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTcpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDI3LCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAxMjIpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDQ1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMjMpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNiwgMjQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTIsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjgsIDE2KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigyOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDExNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxMTgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgzMSwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzEsIDE2KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigyOSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAxMTYpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAxMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMjEsIDQ1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMjMpLCBuZXcgRUNCXzEuZGVmYXVsdCgzNywgMjQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjYsIDE2KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigzMCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAxMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMTE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCA0NyksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCA0OCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNSwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjMsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjUsIDE2KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigzMSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxMywgMTE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjksIDQ3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQyLCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDI4LCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMzIsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDExNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzUsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDM1LCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMzMsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMSwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjksIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQ2LCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMzQsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNDQsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNTksIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTcpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDM1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTIsIDEyMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDEyMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxMiwgNDcpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNiwgNDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMzksIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQxLCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMzYsIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMjEpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgMTIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzQsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQ2LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDY0LCAxNikpKSwKCSAgICAgICAgbmV3IFZlcnNpb24oMzcsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgMTIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDI5LCA0NiksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCA0NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0OSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjQsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNDYsIDE2KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbigzOCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDEyMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDE4LCAxMjMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzIsIDQ3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQ4LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0MiwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgzMiwgMTYpKSksCgkgICAgICAgIG5ldyBWZXJzaW9uKDM5LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjAsIDExNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDExOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCg0MCwgNDcpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCA0OCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0MywgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMiwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNjcsIDE2KSkpLAoJICAgICAgICBuZXcgVmVyc2lvbig0MCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAxMTgpLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTgsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzEsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgyMCwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCg2MSwgMTYpKSkKCSAgICBdOwoJICAgIHJldHVybiBWZXJzaW9uOwoJfSgpKTsKCVZlcnNpb24kMS5kZWZhdWx0ID0gVmVyc2lvbjsKCgl2YXIgRGF0YU1hc2sgPSB7fTsKCgkoZnVuY3Rpb24gKGV4cG9ydHMpIHsKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJZXhwb3J0cy5EYXRhTWFza1ZhbHVlcyA9IHZvaWQgMDsKCXZhciBEYXRhTWFza1ZhbHVlczsKCShmdW5jdGlvbiAoRGF0YU1hc2tWYWx1ZXMpIHsKCSAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1siREFUQV9NQVNLXzAwMCJdID0gMF0gPSAiREFUQV9NQVNLXzAwMCI7CgkgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbIkRBVEFfTUFTS18wMDEiXSA9IDFdID0gIkRBVEFfTUFTS18wMDEiOwoJICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzWyJEQVRBX01BU0tfMDEwIl0gPSAyXSA9ICJEQVRBX01BU0tfMDEwIjsKCSAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1siREFUQV9NQVNLXzAxMSJdID0gM10gPSAiREFUQV9NQVNLXzAxMSI7CgkgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbIkRBVEFfTUFTS18xMDAiXSA9IDRdID0gIkRBVEFfTUFTS18xMDAiOwoJICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzWyJEQVRBX01BU0tfMTAxIl0gPSA1XSA9ICJEQVRBX01BU0tfMTAxIjsKCSAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1siREFUQV9NQVNLXzExMCJdID0gNl0gPSAiREFUQV9NQVNLXzExMCI7CgkgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbIkRBVEFfTUFTS18xMTEiXSA9IDddID0gIkRBVEFfTUFTS18xMTEiOwoJfSkoRGF0YU1hc2tWYWx1ZXMgPSBleHBvcnRzLkRhdGFNYXNrVmFsdWVzIHx8IChleHBvcnRzLkRhdGFNYXNrVmFsdWVzID0ge30pKTsKCS8qKgoJICogPHA+RW5jYXBzdWxhdGVzIGRhdGEgbWFza3MgZm9yIHRoZSBkYXRhIGJpdHMgaW4gYSBRUiBjb2RlLCBwZXIgSVNPIDE4MDA0OjIwMDYgNi44LiBJbXBsZW1lbnRhdGlvbnMKCSAqIG9mIHRoaXMgY2xhc3MgY2FuIHVuLW1hc2sgYSByYXcgQml0TWF0cml4LiBGb3Igc2ltcGxpY2l0eSwgdGhleSB3aWxsIHVubWFzayB0aGUgZW50aXJlIEJpdE1hdHJpeCwKCSAqIGluY2x1ZGluZyBhcmVhcyB1c2VkIGZvciBmaW5kZXIgcGF0dGVybnMsIHRpbWluZyBwYXR0ZXJucywgZXRjLiBUaGVzZSBhcmVhcyBzaG91bGQgYmUgdW51c2VkCgkgKiBhZnRlciB0aGUgcG9pbnQgdGhleSBhcmUgdW5tYXNrZWQgYW55d2F5LjwvcD4KCSAqCgkgKiA8cD5Ob3RlIHRoYXQgdGhlIGRpYWdyYW0gaW4gc2VjdGlvbiA2LjguMSBpcyBtaXNsZWFkaW5nIHNpbmNlIGl0IGluZGljYXRlcyB0aGF0IGkgaXMgY29sdW1uIHBvc2l0aW9uCgkgKiBhbmQgaiBpcyByb3cgcG9zaXRpb24uIEluIGZhY3QsIGFzIHRoZSB0ZXh0IHNheXMsIGkgaXMgcm93IHBvc2l0aW9uIGFuZCBqIGlzIGNvbHVtbiBwb3NpdGlvbi48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIERhdGFNYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIC8vIFNlZSBJU08gMTgwMDQ6MjAwNiA2LjguMQoJICAgIGZ1bmN0aW9uIERhdGFNYXNrKHZhbHVlLCBpc01hc2tlZCkgewoJICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7CgkgICAgICAgIHRoaXMuaXNNYXNrZWQgPSBpc01hc2tlZDsKCSAgICB9CgkgICAgLy8gRW5kIG9mIGVudW0gY29uc3RhbnRzLgoJICAgIC8qKgoJICAgICAqIDxwPkltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCByZXZlcnNlIHRoZSBkYXRhIG1hc2tpbmcgcHJvY2VzcyBhcHBsaWVkIHRvIGEgUVIgQ29kZSBhbmQKCSAgICAgKiBtYWtlIGl0cyBiaXRzIHJlYWR5IHRvIHJlYWQuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGJpdHMgcmVwcmVzZW50YXRpb24gb2YgUVIgQ29kZSBiaXRzCgkgICAgICogQHBhcmFtIGRpbWVuc2lvbiBkaW1lbnNpb24gb2YgUVIgQ29kZSwgcmVwcmVzZW50ZWQgYnkgYml0cywgYmVpbmcgdW5tYXNrZWQKCSAgICAgKi8KCSAgICBEYXRhTWFzay5wcm90b3R5cGUudW5tYXNrQml0TWF0cml4ID0gZnVuY3Rpb24gKGJpdHMsIGRpbWVuc2lvbiAvKmludCovKSB7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHsKCSAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHsKCSAgICAgICAgICAgICAgICBpZiAodGhpcy5pc01hc2tlZChpLCBqKSkgewoJICAgICAgICAgICAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgfTsKCSAgICBEYXRhTWFzay52YWx1ZXMgPSBuZXcgTWFwKFsKCSAgICAgICAgLyoqCgkgICAgICAgICAqIDAwMDogbWFzayBiaXRzIGZvciB3aGljaCAoeCArIHkpIG1vZCAyID09IDAKCSAgICAgICAgICovCgkgICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMCwgZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovKSB7IHJldHVybiAoKGkgKyBqKSAmIDB4MDEpID09PSAwOyB9KV0sCgkgICAgICAgIC8qKgoJICAgICAgICAgKiAwMDE6IG1hc2sgYml0cyBmb3Igd2hpY2ggeCBtb2QgMiA9PSAwCgkgICAgICAgICAqLwoJICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDEsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKGkgJiAweDAxKSA9PT0gMDsgfSldLAoJICAgICAgICAvKioKCSAgICAgICAgICogMDEwOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHkgbW9kIDMgPT0gMAoJICAgICAgICAgKi8KCSAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDEwLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuIGogJSAzID09PSAwOyB9KV0sCgkgICAgICAgIC8qKgoJICAgICAgICAgKiAwMTE6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHggKyB5KSBtb2QgMyA9PSAwCgkgICAgICAgICAqLwoJICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTEsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKGkgKyBqKSAlIDMgPT09IDA7IH0pXSwKCSAgICAgICAgLyoqCgkgICAgICAgICAqIDEwMDogbWFzayBiaXRzIGZvciB3aGljaCAoeC8yICsgeS8zKSBtb2QgMiA9PSAwCgkgICAgICAgICAqLwoJICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKChNYXRoLmZsb29yKGkgLyAyKSArIE1hdGguZmxvb3IoaiAvIDMpKSAmIDB4MDEpID09PSAwOyB9KV0sCgkgICAgICAgIC8qKgoJICAgICAgICAgKiAxMDE6IG1hc2sgYml0cyBmb3Igd2hpY2ggeHkgbW9kIDIgKyB4eSBtb2QgMyA9PSAwCgkgICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0IHh5IG1vZCA2ID09IDAKCSAgICAgICAgICovCgkgICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAxLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMSwgZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovKSB7IHJldHVybiAoaSAqIGopICUgNiA9PT0gMDsgfSldLAoJICAgICAgICAvKioKCSAgICAgICAgICogMTEwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4eSBtb2QgMiArIHh5IG1vZCAzKSBtb2QgMiA9PSAwCgkgICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0IHh5IG1vZCA2IDwgMwoJICAgICAgICAgKi8KCSAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTEwLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuICgoaSAqIGopICUgNikgPCAzOyB9KV0sCgkgICAgICAgIC8qKgoJICAgICAgICAgKiAxMTE6IG1hc2sgYml0cyBmb3Igd2hpY2ggKCh4K3kpbW9kIDIgKyB4eSBtb2QgMykgbW9kIDIgPT0gMAoJICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCAoeCArIHkgKyB4eSBtb2QgMykgbW9kIDIgPT0gMAoJICAgICAgICAgKi8KCSAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTExLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuICgoaSArIGogKyAoKGkgKiBqKSAlIDMpKSAmIDB4MDEpID09PSAwOyB9KV0sCgkgICAgXSk7CgkgICAgcmV0dXJuIERhdGFNYXNrOwoJfSgpKTsKCWV4cG9ydHMuZGVmYXVsdCA9IERhdGFNYXNrOwoKCX0oRGF0YU1hc2spKTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpdE1hdHJpeFBhcnNlciQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7Cgl2YXIgVmVyc2lvbl8xJDEgPSBWZXJzaW9uJDE7Cgl2YXIgRm9ybWF0SW5mb3JtYXRpb25fMSA9IEZvcm1hdEluZm9ybWF0aW9uJDE7Cgl2YXIgRGF0YU1hc2tfMSA9IERhdGFNYXNrOwoJdmFyIEZvcm1hdEV4Y2VwdGlvbl8xJDEgPSBGb3JtYXRFeGNlcHRpb24kMTsKCS8qKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEJpdE1hdHJpeFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gYml0TWF0cml4IHtAbGluayBCaXRNYXRyaXh9IHRvIHBhcnNlCgkgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCA+PSAyMSBhbmQgMSBtb2QgNAoJICAgICAqLwoJICAgIGZ1bmN0aW9uIEJpdE1hdHJpeFBhcnNlcihiaXRNYXRyaXgpIHsKCSAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTsKCSAgICAgICAgaWYgKGRpbWVuc2lvbiA8IDIxIHx8IChkaW1lbnNpb24gJiAweDAzKSAhPT0gMSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xJDEuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMuYml0TWF0cml4ID0gYml0TWF0cml4OwoJICAgIH0KCSAgICAvKioKCSAgICAgKiA8cD5SZWFkcyBmb3JtYXQgaW5mb3JtYXRpb24gZnJvbSBvbmUgb2YgaXRzIHR3byBsb2NhdGlvbnMgd2l0aGluIHRoZSBRUiBDb2RlLjwvcD4KCSAgICAgKgoJICAgICAqIEByZXR1cm4ge0BsaW5rIEZvcm1hdEluZm9ybWF0aW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBRUiBDb2RlJ3MgZm9ybWF0IGluZm8KCSAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBib3RoIGZvcm1hdCBpbmZvcm1hdGlvbiBsb2NhdGlvbnMgY2Fubm90IGJlIHBhcnNlZCBhcwoJICAgICAqIHRoZSB2YWxpZCBlbmNvZGluZyBvZiBmb3JtYXQgaW5mb3JtYXRpb24KCSAgICAgKi8KCSAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRGb3JtYXRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gbnVsbCAmJiB0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IHVuZGVmaW5lZCkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbzsKCSAgICAgICAgfQoJICAgICAgICAvLyBSZWFkIHRvcC1sZWZ0IGZvcm1hdCBpbmZvIGJpdHMKCSAgICAgICAgdmFyIGZvcm1hdEluZm9CaXRzMSA9IDA7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7CgkgICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoaSwgOCwgZm9ybWF0SW5mb0JpdHMxKTsKCSAgICAgICAgfQoJICAgICAgICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uCgkgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg3LCA4LCBmb3JtYXRJbmZvQml0czEpOwoJICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgOCwgZm9ybWF0SW5mb0JpdHMxKTsKCSAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDgsIDcsIGZvcm1hdEluZm9CaXRzMSk7CgkgICAgICAgIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi4KCSAgICAgICAgZm9yICh2YXIgaiA9IDU7IGogPj0gMDsgai0tKSB7CgkgICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgaiwgZm9ybWF0SW5mb0JpdHMxKTsKCSAgICAgICAgfQoJICAgICAgICAvLyBSZWFkIHRoZSB0b3AtcmlnaHQvYm90dG9tLWxlZnQgcGF0dGVybiB0b28KCSAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpOwoJICAgICAgICB2YXIgZm9ybWF0SW5mb0JpdHMyID0gMDsKCSAgICAgICAgdmFyIGpNaW4gPSBkaW1lbnNpb24gLSA3OwoJICAgICAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gMTsgaiA+PSBqTWluOyBqLS0pIHsKCSAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMiA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0czIpOwoJICAgICAgICB9CgkgICAgICAgIGZvciAodmFyIGkgPSBkaW1lbnNpb24gLSA4OyBpIDwgZGltZW5zaW9uOyBpKyspIHsKCSAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMiA9IHRoaXMuY29weUJpdChpLCA4LCBmb3JtYXRJbmZvQml0czIpOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IEZvcm1hdEluZm9ybWF0aW9uXzEuZGVmYXVsdC5kZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihmb3JtYXRJbmZvQml0czEsIGZvcm1hdEluZm9CaXRzMik7CgkgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IG51bGwpIHsKCSAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87CgkgICAgICAgIH0KCSAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xJDEuZGVmYXVsdCgpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogPHA+UmVhZHMgdmVyc2lvbiBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPgoJICAgICAqCgkgICAgICogQHJldHVybiB7QGxpbmsgVmVyc2lvbn0gZW5jYXBzdWxhdGluZyB0aGUgUVIgQ29kZSdzIHZlcnNpb24KCSAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBib3RoIHZlcnNpb24gaW5mb3JtYXRpb24gbG9jYXRpb25zIGNhbm5vdCBiZSBwYXJzZWQgYXMKCSAgICAgKiB0aGUgdmFsaWQgZW5jb2Rpbmcgb2YgdmVyc2lvbiBpbmZvcm1hdGlvbgoJICAgICAqLwoJICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIGlmICh0aGlzLnBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHsKCSAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpOwoJICAgICAgICB2YXIgcHJvdmlzaW9uYWxWZXJzaW9uID0gTWF0aC5mbG9vcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7CgkgICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24gPD0gNikgewoJICAgICAgICAgICAgcmV0dXJuIFZlcnNpb25fMSQxLmRlZmF1bHQuZ2V0VmVyc2lvbkZvck51bWJlcihwcm92aXNpb25hbFZlcnNpb24pOwoJICAgICAgICB9CgkgICAgICAgIC8vIFJlYWQgdG9wLXJpZ2h0IHZlcnNpb24gaW5mbzogMyB3aWRlIGJ5IDYgdGFsbAoJICAgICAgICB2YXIgdmVyc2lvbkJpdHMgPSAwOwoJICAgICAgICB2YXIgaWpNaW4gPSBkaW1lbnNpb24gLSAxMTsKCSAgICAgICAgZm9yICh2YXIgaiA9IDU7IGogPj0gMDsgai0tKSB7CgkgICAgICAgICAgICBmb3IgKHZhciBpID0gZGltZW5zaW9uIC0gOTsgaSA+PSBpak1pbjsgaS0tKSB7CgkgICAgICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHZhciB0aGVQYXJzZWRWZXJzaW9uID0gVmVyc2lvbl8xJDEuZGVmYXVsdC5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpOwoJICAgICAgICBpZiAodGhlUGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGVQYXJzZWRWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSA9PT0gZGltZW5zaW9uKSB7CgkgICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uOwoJICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247CgkgICAgICAgIH0KCSAgICAgICAgLy8gSG1tLCBmYWlsZWQuIFRyeSBib3R0b20gbGVmdDogNiB3aWRlIGJ5IDMgdGFsbAoJICAgICAgICB2ZXJzaW9uQml0cyA9IDA7CgkgICAgICAgIGZvciAodmFyIGkgPSA1OyBpID49IDA7IGktLSkgewoJICAgICAgICAgICAgZm9yICh2YXIgaiA9IGRpbWVuc2lvbiAtIDk7IGogPj0gaWpNaW47IGotLSkgewoJICAgICAgICAgICAgICAgIHZlcnNpb25CaXRzID0gdGhpcy5jb3B5Qml0KGksIGosIHZlcnNpb25CaXRzKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICB0aGVQYXJzZWRWZXJzaW9uID0gVmVyc2lvbl8xJDEuZGVmYXVsdC5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpOwoJICAgICAgICBpZiAodGhlUGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGVQYXJzZWRWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSA9PT0gZGltZW5zaW9uKSB7CgkgICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uOwoJICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247CgkgICAgICAgIH0KCSAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xJDEuZGVmYXVsdCgpOwoJICAgIH07CgkgICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5jb3B5Qml0ID0gZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovLCB2ZXJzaW9uQml0cyAvKmludCovKSB7CgkgICAgICAgIHZhciBiaXQgPSB0aGlzLmlzTWlycm9yID8gdGhpcy5iaXRNYXRyaXguZ2V0KGosIGkpIDogdGhpcy5iaXRNYXRyaXguZ2V0KGksIGopOwoJICAgICAgICByZXR1cm4gYml0ID8gKHZlcnNpb25CaXRzIDw8IDEpIHwgMHgxIDogdmVyc2lvbkJpdHMgPDwgMTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPlJlYWRzIHRoZSBiaXRzIGluIHRoZSB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRpbmcgdGhlIGZpbmRlciBwYXR0ZXJuIGluIHRoZQoJICAgICAqIGNvcnJlY3Qgb3JkZXIgaW4gb3JkZXIgdG8gcmVjb25zdHJ1Y3QgdGhlIGNvZGV3b3JkcyBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZQoJICAgICAqIFFSIENvZGUuPC9wPgoJICAgICAqCgkgICAgICogQHJldHVybiBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZQoJICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgaXMgbm90IHJlYWQKCSAgICAgKi8KCSAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHZhciBmb3JtYXRJbmZvID0gdGhpcy5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKTsKCSAgICAgICAgdmFyIHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9uKCk7CgkgICAgICAgIC8vIEdldCB0aGUgZGF0YSBtYXNrIGZvciB0aGUgZm9ybWF0IHVzZWQgaW4gdGhpcyBRUiBDb2RlLiBUaGlzIHdpbGwgZXhjbHVkZQoJICAgICAgICAvLyBzb21lIGJpdHMgZnJvbSByZWFkaW5nIGFzIHdlIHdpbmQgdGhyb3VnaCB0aGUgYml0IG1hdHJpeC4KCSAgICAgICAgdmFyIGRhdGFNYXNrID0gRGF0YU1hc2tfMS5kZWZhdWx0LnZhbHVlcy5nZXQoZm9ybWF0SW5mby5nZXREYXRhTWFzaygpKTsKCSAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpOwoJICAgICAgICBkYXRhTWFzay51bm1hc2tCaXRNYXRyaXgodGhpcy5iaXRNYXRyaXgsIGRpbWVuc2lvbik7CgkgICAgICAgIHZhciBmdW5jdGlvblBhdHRlcm4gPSB2ZXJzaW9uLmJ1aWxkRnVuY3Rpb25QYXR0ZXJuKCk7CgkgICAgICAgIHZhciByZWFkaW5nVXAgPSB0cnVlOwoJICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKTsKCSAgICAgICAgdmFyIHJlc3VsdE9mZnNldCA9IDA7CgkgICAgICAgIHZhciBjdXJyZW50Qnl0ZSA9IDA7CgkgICAgICAgIHZhciBiaXRzUmVhZCA9IDA7CgkgICAgICAgIC8vIFJlYWQgY29sdW1ucyBpbiBwYWlycywgZnJvbSByaWdodCB0byBsZWZ0CgkgICAgICAgIGZvciAodmFyIGogPSBkaW1lbnNpb24gLSAxOyBqID4gMDsgaiAtPSAyKSB7CgkgICAgICAgICAgICBpZiAoaiA9PT0gNikgewoJICAgICAgICAgICAgICAgIC8vIFNraXAgd2hvbGUgY29sdW1uIHdpdGggdmVydGljYWwgYWxpZ25tZW50IHBhdHRlcm4KCSAgICAgICAgICAgICAgICAvLyBzYXZlcyB0aW1lIGFuZCBtYWtlcyB0aGUgb3RoZXIgY29kZSBwcm9jZWVkIG1vcmUgY2xlYW5seQoJICAgICAgICAgICAgICAgIGotLTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIC8vIFJlYWQgYWx0ZXJuYXRpbmdseSBmcm9tIGJvdHRvbSB0byB0b3AgdGhlbiB0b3AgdG8gYm90dG9tCgkgICAgICAgICAgICBmb3IgKHZhciBjb3VudCA9IDA7IGNvdW50IDwgZGltZW5zaW9uOyBjb3VudCsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIGkgPSByZWFkaW5nVXAgPyBkaW1lbnNpb24gLSAxIC0gY291bnQgOiBjb3VudDsKCSAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCAyOyBjb2wrKykgewoJICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYml0cyBjb3ZlcmVkIGJ5IHRoZSBmdW5jdGlvbiBwYXR0ZXJuCgkgICAgICAgICAgICAgICAgICAgIGlmICghZnVuY3Rpb25QYXR0ZXJuLmdldChqIC0gY29sLCBpKSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBhIGJpdAoJICAgICAgICAgICAgICAgICAgICAgICAgYml0c1JlYWQrKzsKCSAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxOwoJICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0TWF0cml4LmdldChqIC0gY29sLCBpKSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBtYWRlIGEgd2hvbGUgYnl0ZSwgc2F2ZSBpdCBvZmYKCSAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzUmVhZCA9PT0gOCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSAvKihieXRlKSAqLyBjdXJyZW50Qnl0ZTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUmVhZCA9IDA7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgPSAwOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgcmVhZGluZ1VwID0gIXJlYWRpbmdVcDsgLy8gcmVhZGluZ1VwIF49IHRydWU7IC8vIHJlYWRpbmdVcCA9ICFyZWFkaW5nVXA7IC8vIHN3aXRjaCBkaXJlY3Rpb25zCgkgICAgICAgIH0KCSAgICAgICAgaWYgKHJlc3VsdE9mZnNldCAhPT0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEkMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHJlc3VsdDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldmVydCB0aGUgbWFzayByZW1vdmFsIGRvbmUgd2hpbGUgcmVhZGluZyB0aGUgY29kZSB3b3Jkcy4gVGhlIGJpdCBtYXRyaXggc2hvdWxkIHJldmVydCB0byBpdHMgb3JpZ2luYWwgc3RhdGUuCgkgICAgICovCgkgICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZW1hc2sgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gPT09IG51bGwpIHsKCSAgICAgICAgICAgIHJldHVybjsgLy8gV2UgaGF2ZSBubyBmb3JtYXQgaW5mb3JtYXRpb24sIGFuZCBoYXZlIG5vIGRhdGEgbWFzawoJICAgICAgICB9CgkgICAgICAgIHZhciBkYXRhTWFzayA9IERhdGFNYXNrXzEuZGVmYXVsdC52YWx1ZXNbdGhpcy5wYXJzZWRGb3JtYXRJbmZvLmdldERhdGFNYXNrKCldOwoJICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7CgkgICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFByZXBhcmUgdGhlIHBhcnNlciBmb3IgYSBtaXJyb3JlZCBvcGVyYXRpb24uCgkgICAgICogVGhpcyBmbGFnIGhhcyBlZmZlY3Qgb25seSBvbiB0aGUge0BsaW5rICNyZWFkRm9ybWF0SW5mb3JtYXRpb24oKX0gYW5kIHRoZQoJICAgICAqIHtAbGluayAjcmVhZFZlcnNpb24oKX0uIEJlZm9yZSBwcm9jZWVkaW5nIHdpdGgge0BsaW5rICNyZWFkQ29kZXdvcmRzKCl9IHRoZQoJICAgICAqIHtAbGluayAjbWlycm9yKCl9IG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkLgoJICAgICAqCgkgICAgICogQHBhcmFtIG1pcnJvciBXaGV0aGVyIHRvIHJlYWQgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm9ybWF0aW9uIG1pcnJvcmVkLgoJICAgICAqLwoJICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUuc2V0TWlycm9yID0gZnVuY3Rpb24gKGlzTWlycm9yKSB7CgkgICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IG51bGw7CgkgICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IG51bGw7CgkgICAgICAgIHRoaXMuaXNNaXJyb3IgPSBpc01pcnJvcjsKCSAgICB9OwoJICAgIC8qKiBNaXJyb3IgdGhlIGJpdCBtYXRyaXggaW4gb3JkZXIgdG8gYXR0ZW1wdCBhIHNlY29uZCByZWFkaW5nLiAqLwoJICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgYml0TWF0cml4ID0gdGhpcy5iaXRNYXRyaXg7CgkgICAgICAgIGZvciAodmFyIHggPSAwLCB3aWR0aCA9IGJpdE1hdHJpeC5nZXRXaWR0aCgpOyB4IDwgd2lkdGg7IHgrKykgewoJICAgICAgICAgICAgZm9yICh2YXIgeSA9IHggKyAxLCBoZWlnaHQgPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7IHkgPCBoZWlnaHQ7IHkrKykgewoJICAgICAgICAgICAgICAgIGlmIChiaXRNYXRyaXguZ2V0KHgsIHkpICE9PSBiaXRNYXRyaXguZ2V0KHksIHgpKSB7CgkgICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHksIHgpOwoJICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXguZmxpcCh4LCB5KTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICB9OwoJICAgIHJldHVybiBCaXRNYXRyaXhQYXJzZXI7Cgl9KCkpOwoJQml0TWF0cml4UGFyc2VyJDEuZGVmYXVsdCA9IEJpdE1hdHJpeFBhcnNlcjsKCgl2YXIgRGF0YUJsb2NrJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fdmFsdWVzJDMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHsKCSAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDsKCSAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTsKCSAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09ICJudW1iZXIiKSByZXR1cm4gewoJICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7CgkgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwOwoJICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9OwoJICAgICAgICB9CgkgICAgfTsKCSAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyAiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS4iIDogIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC4iKTsKCX07CglPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUJsb2NrJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSQxID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJDE7CgkvKioKCSAqIDxwPkVuY2Fwc3VsYXRlcyBhIGJsb2NrIG9mIGRhdGEgd2l0aGluIGEgUVIgQ29kZS4gUVIgQ29kZXMgbWF5IHNwbGl0IHRoZWlyIGRhdGEgaW50bwoJICogbXVsdGlwbGUgYmxvY2tzLCBlYWNoIG9mIHdoaWNoIGlzIGEgdW5pdCBvZiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkcy4gRWFjaAoJICogaXMgcmVwcmVzZW50ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIERhdGFCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBEYXRhQmxvY2sobnVtRGF0YUNvZGV3b3JkcyAvKmludCovLCBjb2Rld29yZHMpIHsKCSAgICAgICAgdGhpcy5udW1EYXRhQ29kZXdvcmRzID0gbnVtRGF0YUNvZGV3b3JkczsKCSAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7CgkgICAgfQoJICAgIC8qKgoJICAgICAqIDxwPldoZW4gUVIgQ29kZXMgdXNlIG11bHRpcGxlIGRhdGEgYmxvY2tzLCB0aGV5IGFyZSBhY3R1YWxseSBpbnRlcmxlYXZlZC4KCSAgICAgKiBUaGF0IGlzLCB0aGUgZmlyc3QgYnl0ZSBvZiBkYXRhIGJsb2NrIDEgdG8gbiBpcyB3cml0dGVuLCB0aGVuIHRoZSBzZWNvbmQgYnl0ZXMsIGFuZCBzbyBvbi4gVGhpcwoJICAgICAqIG1ldGhvZCB3aWxsIHNlcGFyYXRlIHRoZSBkYXRhIGludG8gb3JpZ2luYWwgYmxvY2tzLjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSByYXdDb2Rld29yZHMgYnl0ZXMgYXMgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBRUiBDb2RlCgkgICAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBvZiB0aGUgUVIgQ29kZQoJICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWwgb2YgdGhlIFFSIENvZGUKCSAgICAgKiBAcmV0dXJuIERhdGFCbG9ja3MgY29udGFpbmluZyBvcmlnaW5hbCBieXRlcywgImRlLWludGVybGVhdmVkIiBmcm9tIHJlcHJlc2VudGF0aW9uIGluIHRoZQoJICAgICAqICAgICAgICAgUVIgQ29kZQoJICAgICAqLwoJICAgIERhdGFCbG9jay5nZXREYXRhQmxvY2tzID0gZnVuY3Rpb24gKHJhd0NvZGV3b3JkcywgdmVyc2lvbiwgZWNMZXZlbCkgewoJICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjsKCSAgICAgICAgaWYgKHJhd0NvZGV3b3Jkcy5sZW5ndGggIT09IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xJDEuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvbiBhbmQKCSAgICAgICAgLy8gZXJyb3IgY29ycmVjdGlvbiBsZXZlbAoJICAgICAgICB2YXIgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7CgkgICAgICAgIC8vIEZpcnN0IGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBibG9ja3MKCSAgICAgICAgdmFyIHRvdGFsQmxvY2tzID0gMDsKCSAgICAgICAgdmFyIGVjQmxvY2tBcnJheSA9IGVjQmxvY2tzLmdldEVDQmxvY2tzKCk7CgkgICAgICAgIHRyeSB7CgkgICAgICAgICAgICBmb3IgKHZhciBlY0Jsb2NrQXJyYXlfMSA9IF9fdmFsdWVzJDMoZWNCbG9ja0FycmF5KSwgZWNCbG9ja0FycmF5XzFfMSA9IGVjQmxvY2tBcnJheV8xLm5leHQoKTsgIWVjQmxvY2tBcnJheV8xXzEuZG9uZTsgZWNCbG9ja0FycmF5XzFfMSA9IGVjQmxvY2tBcnJheV8xLm5leHQoKSkgewoJICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNCbG9ja0FycmF5XzFfMS52YWx1ZTsKCSAgICAgICAgICAgICAgICB0b3RhbEJsb2NrcyArPSBlY0Jsb2NrLmdldENvdW50KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH0KCSAgICAgICAgZmluYWxseSB7CgkgICAgICAgICAgICB0cnkgewoJICAgICAgICAgICAgICAgIGlmIChlY0Jsb2NrQXJyYXlfMV8xICYmICFlY0Jsb2NrQXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gZWNCbG9ja0FycmF5XzEucmV0dXJuKSkgX2EuY2FsbChlY0Jsb2NrQXJyYXlfMSk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHMKCSAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7CgkgICAgICAgIHZhciBudW1SZXN1bHRCbG9ja3MgPSAwOwoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgZm9yICh2YXIgZWNCbG9ja0FycmF5XzIgPSBfX3ZhbHVlcyQzKGVjQmxvY2tBcnJheSksIGVjQmxvY2tBcnJheV8yXzEgPSBlY0Jsb2NrQXJyYXlfMi5uZXh0KCk7ICFlY0Jsb2NrQXJyYXlfMl8xLmRvbmU7IGVjQmxvY2tBcnJheV8yXzEgPSBlY0Jsb2NrQXJyYXlfMi5uZXh0KCkpIHsKCSAgICAgICAgICAgICAgICB2YXIgZWNCbG9jayA9IGVjQmxvY2tBcnJheV8yXzEudmFsdWU7CgkgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlY0Jsb2NrLmdldENvdW50KCk7IGkrKykgewoJICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpOwoJICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQmxvY2tDb2Rld29yZHMgPSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCkgKyBudW1EYXRhQ29kZXdvcmRzOwoJICAgICAgICAgICAgICAgICAgICByZXN1bHRbbnVtUmVzdWx0QmxvY2tzKytdID0gbmV3IERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzLCBuZXcgVWludDhBcnJheShudW1CbG9ja0NvZGV3b3JkcykpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfQoJICAgICAgICBmaW5hbGx5IHsKCSAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgaWYgKGVjQmxvY2tBcnJheV8yXzEgJiYgIWVjQmxvY2tBcnJheV8yXzEuZG9uZSAmJiAoX2IgPSBlY0Jsb2NrQXJyYXlfMi5yZXR1cm4pKSBfYi5jYWxsKGVjQmxvY2tBcnJheV8yKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH0KCSAgICAgICAgfQoJICAgICAgICAvLyBBbGwgYmxvY2tzIGhhdmUgdGhlIHNhbWUgYW1vdW50IG9mIGRhdGEsIGV4Y2VwdCB0aGF0IHRoZSBsYXN0IG4KCSAgICAgICAgLy8gKHdoZXJlIG4gbWF5IGJlIDApIGhhdmUgMSBtb3JlIGJ5dGUuIEZpZ3VyZSBvdXQgd2hlcmUgdGhlc2Ugc3RhcnQuCgkgICAgICAgIHZhciBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDsKCSAgICAgICAgdmFyIGxvbmdlckJsb2Nrc1N0YXJ0QXQgPSByZXN1bHQubGVuZ3RoIC0gMTsKCSAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoZWNrIGxlbmd0aCBpcyBjb3JyZWN0IGhlcmUKCSAgICAgICAgd2hpbGUgKGxvbmdlckJsb2Nrc1N0YXJ0QXQgPj0gMCkgewoJICAgICAgICAgICAgdmFyIG51bUNvZGV3b3JkcyA9IHJlc3VsdFtsb25nZXJCbG9ja3NTdGFydEF0XS5jb2Rld29yZHMubGVuZ3RoOwoJICAgICAgICAgICAgaWYgKG51bUNvZGV3b3JkcyA9PT0gc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzKSB7CgkgICAgICAgICAgICAgICAgYnJlYWs7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBsb25nZXJCbG9ja3NTdGFydEF0LS07CgkgICAgICAgIH0KCSAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdCsrOwoJICAgICAgICB2YXIgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgLSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCk7CgkgICAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IGxvbmdlcgoJICAgICAgICAvLyBmaXJzdCBmaWxsIG91dCBhcyBtYW55IGVsZW1lbnRzIGFzIGFsbCBvZiB0aGVtIGhhdmUKCSAgICAgICAgdmFyIHJhd0NvZGV3b3Jkc09mZnNldCA9IDA7CgkgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkrKykgewoJICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykgewoJICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaV0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIC8vIEZpbGwgb3V0IHRoZSBsYXN0IGRhdGEgYmxvY2sgaW4gdGhlIGxvbmdlciBvbmVzCgkgICAgICAgIGZvciAodmFyIGogPSBsb25nZXJCbG9ja3NTdGFydEF0OyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHsKCSAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHNdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTsKCSAgICAgICAgfQoJICAgICAgICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzCgkgICAgICAgIHZhciBtYXggPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDsKCSAgICAgICAgZm9yICh2YXIgaSA9IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpIDwgbWF4OyBpKyspIHsKCSAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHsKCSAgICAgICAgICAgICAgICB2YXIgaU9mZnNldCA9IGogPCBsb25nZXJCbG9ja3NTdGFydEF0ID8gaSA6IGkgKyAxOwoJICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaU9mZnNldF0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiByZXN1bHQ7CgkgICAgfTsKCSAgICBEYXRhQmxvY2sucHJvdG90eXBlLmdldE51bURhdGFDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLm51bURhdGFDb2Rld29yZHM7CgkgICAgfTsKCSAgICBEYXRhQmxvY2sucHJvdG90eXBlLmdldENvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzOwoJICAgIH07CgkgICAgcmV0dXJuIERhdGFCbG9jazsKCX0oKSk7CglEYXRhQmxvY2skMS5kZWZhdWx0ID0gRGF0YUJsb2NrOwoKCXZhciBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEgPSB7fTsKCgl2YXIgQml0U291cmNlJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpdFNvdXJjZSQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbiB7Ki8KCXZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiA8cD5UaGlzIHByb3ZpZGVzIGFuIGVhc3kgYWJzdHJhY3Rpb24gdG8gcmVhZCBiaXRzIGF0IGEgdGltZSBmcm9tIGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIHdoZXJlIHRoZQoJICogbnVtYmVyIG9mIGJpdHMgcmVhZCBpcyBub3Qgb2Z0ZW4gYSBtdWx0aXBsZSBvZiA4LjwvcD4KCSAqCgkgKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50IC0tIHVubGVzcyB0aGUgY2FsbGVyIG1vZGlmaWVzIHRoZSBieXRlcyBhcnJheQoJICogaXQgcGFzc2VkIGluLCBpbiB3aGljaCBjYXNlIGFsbCBiZXRzIGFyZSBvZmYuPC9wPgoJICoKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBCaXRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgLyoqCgkgICAgICogQHBhcmFtIGJ5dGVzIGJ5dGVzIGZyb20gd2hpY2ggdGhpcyB3aWxsIHJlYWQgYml0cy4gQml0cyB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgZmlyc3QgYnl0ZSBmaXJzdC4KCSAgICAgKiBCaXRzIGFyZSByZWFkIHdpdGhpbiBhIGJ5dGUgZnJvbSBtb3N0LXNpZ25pZmljYW50IHRvIGxlYXN0LXNpZ25pZmljYW50IGJpdC4KCSAgICAgKi8KCSAgICBmdW5jdGlvbiBCaXRTb3VyY2UoYnl0ZXMpIHsKCSAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzOwoJICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAwOwoJICAgICAgICB0aGlzLmJpdE9mZnNldCA9IDA7CgkgICAgfQoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCBiaXQgaW4gY3VycmVudCBieXRlIHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LgoJICAgICAqLwoJICAgIEJpdFNvdXJjZS5wcm90b3R5cGUuZ2V0Qml0T2Zmc2V0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5iaXRPZmZzZXQ7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgYnl0ZSBpbiBpbnB1dCBieXRlIGFycmF5IHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LgoJICAgICAqLwoJICAgIEJpdFNvdXJjZS5wcm90b3R5cGUuZ2V0Qnl0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBudW1CaXRzIG51bWJlciBvZiBiaXRzIHRvIHJlYWQKCSAgICAgKiBAcmV0dXJuIGludCByZXByZXNlbnRpbmcgdGhlIGJpdHMgcmVhZC4gVGhlIGJpdHMgd2lsbCBhcHBlYXIgYXMgdGhlIGxlYXN0LXNpZ25pZmljYW50CgkgICAgICogICAgICAgICBiaXRzIG9mIHRoZSBpbnQKCSAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBudW1CaXRzIGlzbid0IGluIFsxLDMyXSBvciBtb3JlIHRoYW4gaXMgYXZhaWxhYmxlCgkgICAgICovCgkgICAgQml0U291cmNlLnByb3RvdHlwZS5yZWFkQml0cyA9IGZ1bmN0aW9uIChudW1CaXRzIC8qaW50Ki8pIHsKCSAgICAgICAgaWYgKG51bUJpdHMgPCAxIHx8IG51bUJpdHMgPiAzMiB8fCBudW1CaXRzID4gdGhpcy5hdmFpbGFibGUoKSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJycgKyBudW1CaXRzKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgcmVzdWx0ID0gMDsKCSAgICAgICAgdmFyIGJpdE9mZnNldCA9IHRoaXMuYml0T2Zmc2V0OwoJICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IHRoaXMuYnl0ZU9mZnNldDsKCSAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlczsKCSAgICAgICAgLy8gRmlyc3QsIHJlYWQgcmVtYWluZGVyIGZyb20gY3VycmVudCBieXRlCgkgICAgICAgIGlmIChiaXRPZmZzZXQgPiAwKSB7CgkgICAgICAgICAgICB2YXIgYml0c0xlZnQgPSA4IC0gYml0T2Zmc2V0OwoJICAgICAgICAgICAgdmFyIHRvUmVhZCA9IG51bUJpdHMgPCBiaXRzTGVmdCA/IG51bUJpdHMgOiBiaXRzTGVmdDsKCSAgICAgICAgICAgIHZhciBiaXRzVG9Ob3RSZWFkID0gYml0c0xlZnQgLSB0b1JlYWQ7CgkgICAgICAgICAgICB2YXIgbWFzayA9ICgweEZGID4+ICg4IC0gdG9SZWFkKSkgPDwgYml0c1RvTm90UmVhZDsKCSAgICAgICAgICAgIHJlc3VsdCA9IChieXRlc1tieXRlT2Zmc2V0XSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQ7CgkgICAgICAgICAgICBudW1CaXRzIC09IHRvUmVhZDsKCSAgICAgICAgICAgIGJpdE9mZnNldCArPSB0b1JlYWQ7CgkgICAgICAgICAgICBpZiAoYml0T2Zmc2V0ID09PSA4KSB7CgkgICAgICAgICAgICAgICAgYml0T2Zmc2V0ID0gMDsKCSAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gTmV4dCByZWFkIHdob2xlIGJ5dGVzCgkgICAgICAgIGlmIChudW1CaXRzID4gMCkgewoJICAgICAgICAgICAgd2hpbGUgKG51bUJpdHMgPj0gOCkgewoJICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgfCAoYnl0ZXNbYnl0ZU9mZnNldF0gJiAweEZGKTsKCSAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7CgkgICAgICAgICAgICAgICAgbnVtQml0cyAtPSA4OwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgLy8gRmluYWxseSByZWFkIGEgcGFydGlhbCBieXRlCgkgICAgICAgICAgICBpZiAobnVtQml0cyA+IDApIHsKCSAgICAgICAgICAgICAgICB2YXIgYml0c1RvTm90UmVhZCA9IDggLSBudW1CaXRzOwoJICAgICAgICAgICAgICAgIHZhciBtYXNrID0gKDB4RkYgPj4gYml0c1RvTm90UmVhZCkgPDwgYml0c1RvTm90UmVhZDsKCSAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IG51bUJpdHMpIHwgKChieXRlc1tieXRlT2Zmc2V0XSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQpOwoJICAgICAgICAgICAgICAgIGJpdE9mZnNldCArPSBudW1CaXRzOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHRoaXMuYml0T2Zmc2V0ID0gYml0T2Zmc2V0OwoJICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0OwoJICAgICAgICByZXR1cm4gcmVzdWx0OwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBiZSByZWFkIHN1Y2Nlc3NmdWxseQoJICAgICAqLwoJICAgIEJpdFNvdXJjZS5wcm90b3R5cGUuYXZhaWxhYmxlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gOCAqICh0aGlzLmJ5dGVzLmxlbmd0aCAtIHRoaXMuYnl0ZU9mZnNldCkgLSB0aGlzLmJpdE9mZnNldDsKCSAgICB9OwoJICAgIHJldHVybiBCaXRTb3VyY2U7Cgl9KCkpOwoJQml0U291cmNlJDEuZGVmYXVsdCA9IEJpdFNvdXJjZTsKCgl2YXIgRGVjb2RlclJlc3VsdCQxID0ge307CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWNvZGVyUmVzdWx0JDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki8KCS8qKgoJICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBtYXRyaXggb2YgYml0cy4gVGhpcyB0eXBpY2FsbHkKCSAqIGFwcGxpZXMgdG8gMkQgYmFyY29kZSBmb3JtYXRzLiBGb3Igbm93IGl0IGNvbnRhaW5zIHRoZSByYXcgYnl0ZXMgb2J0YWluZWQsCgkgKiBhcyB3ZWxsIGFzIGEgU3RyaW5nIGludGVycHJldGF0aW9uIG9mIHRob3NlIGJ5dGVzLCBpZiBhcHBsaWNhYmxlLjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgRGVjb2RlclJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocmF3Qnl0ZXM6IFVpbnQ4QXJyYXksCgkgICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RyaW5nLAoJICAgIC8vICAgICAgICAgICAgICAgICAgICAgIExpc3Q8VWludDhBcnJheT4gYnl0ZVNlZ21lbnRzLAoJICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyBlY0xldmVsKSB7CgkgICAgLy8gICB0aGlzKHJhd0J5dGVzLCB0ZXh0LCBieXRlU2VnbWVudHMsIGVjTGV2ZWwsIC0xLCAtMSkKCSAgICAvLyB9CgkgICAgZnVuY3Rpb24gRGVjb2RlclJlc3VsdChyYXdCeXRlcywgdGV4dCwgYnl0ZVNlZ21lbnRzLCBlY0xldmVsLCBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIsIHN0cnVjdHVyZWRBcHBlbmRQYXJpdHkpIHsKCSAgICAgICAgaWYgKHN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciA9PT0gdm9pZCAwKSB7IHN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciA9IC0xOyB9CgkgICAgICAgIGlmIChzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID09PSB2b2lkIDApIHsgc3RydWN0dXJlZEFwcGVuZFBhcml0eSA9IC0xOyB9CgkgICAgICAgIHRoaXMucmF3Qnl0ZXMgPSByYXdCeXRlczsKCSAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDsKCSAgICAgICAgdGhpcy5ieXRlU2VnbWVudHMgPSBieXRlU2VnbWVudHM7CgkgICAgICAgIHRoaXMuZWNMZXZlbCA9IGVjTGV2ZWw7CgkgICAgICAgIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyOwoJICAgICAgICB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSBzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5OwoJICAgICAgICB0aGlzLm51bUJpdHMgPSAocmF3Qnl0ZXMgPT09IHVuZGVmaW5lZCB8fCByYXdCeXRlcyA9PT0gbnVsbCkgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aDsKCSAgICB9CgkgICAgLyoqCgkgICAgICogQHJldHVybiByYXcgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSByZXN1bHQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZQoJICAgICAqLwoJICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldFJhd0J5dGVzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5yYXdCeXRlczsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gaG93IG1hbnkgYml0cyBvZiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9IGFyZSB2YWxpZDsgdHlwaWNhbGx5IDggdGltZXMgaXRzIGxlbmd0aAoJICAgICAqIEBzaW5jZSAzLjMuMAoJICAgICAqLwoJICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldE51bUJpdHMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLm51bUJpdHM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gbnVtQml0cyBvdmVycmlkZXMgdGhlIG51bWJlciBvZiBiaXRzIHRoYXQgYXJlIHZhbGlkIGluIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX0KCSAgICAgKiBAc2luY2UgMy4zLjAKCSAgICAgKi8KCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5zZXROdW1CaXRzID0gZnVuY3Rpb24gKG51bUJpdHMgLyppbnQqLykgewoJICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXN1bHQKCSAgICAgKi8KCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy50ZXh0OwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBsaXN0IG9mIGJ5dGUgc2VnbWVudHMgaW4gdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlCgkgICAgICovCgkgICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0Qnl0ZVNlZ21lbnRzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5ieXRlU2VnbWVudHM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCB1c2VkLCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGUKCSAgICAgKi8KCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRFQ0xldmVsID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5lY0xldmVsOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBudW1iZXIgb2YgZXJyb3JzIGNvcnJlY3RlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlCgkgICAgICovCgkgICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0RXJyb3JzQ29ycmVjdGVkID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNDb3JyZWN0ZWQ7CgkgICAgfTsKCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5zZXRFcnJvcnNDb3JyZWN0ZWQgPSBmdW5jdGlvbiAoZXJyb3JzQ29ycmVjdGVkIC8qSW50ZWdlciovKSB7CgkgICAgICAgIHRoaXMuZXJyb3JzQ29ycmVjdGVkID0gZXJyb3JzQ29ycmVjdGVkOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBudW1iZXIgb2YgZXJhc3VyZXMgY29ycmVjdGVkLCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGUKCSAgICAgKi8KCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRFcmFzdXJlcyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuZXJhc3VyZXM7CgkgICAgfTsKCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5zZXRFcmFzdXJlcyA9IGZ1bmN0aW9uIChlcmFzdXJlcyAvKkludGVnZXIqLykgewoJICAgICAgICB0aGlzLmVyYXN1cmVzID0gZXJhc3VyZXM7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIGFyYml0cmFyeSBhZGRpdGlvbmFsIG1ldGFkYXRhCgkgICAgICovCgkgICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0T3RoZXIgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLm90aGVyOwoJICAgIH07CgkgICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuc2V0T3RoZXIgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyOwoJICAgIH07CgkgICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuaGFzU3RydWN0dXJlZEFwcGVuZCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuc3RydWN0dXJlZEFwcGVuZFBhcml0eSA+PSAwICYmIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID49IDA7CgkgICAgfTsKCSAgICBEZWNvZGVyUmVzdWx0LnByb3RvdHlwZS5nZXRTdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5OwoJICAgIH07CgkgICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0U3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXI7CgkgICAgfTsKCSAgICByZXR1cm4gRGVjb2RlclJlc3VsdDsKCX0oKSk7CglEZWNvZGVyUmVzdWx0JDEuZGVmYXVsdCA9IERlY29kZXJSZXN1bHQ7CgoJdmFyIE1vZGUgPSB7fTsKCgkoZnVuY3Rpb24gKGV4cG9ydHMpIHsKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJZXhwb3J0cy5Nb2RlVmFsdWVzID0gdm9pZCAwOwoJdmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJDE7Cgl2YXIgTW9kZVZhbHVlczsKCShmdW5jdGlvbiAoTW9kZVZhbHVlcykgewoJICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1siVEVSTUlOQVRPUiJdID0gMF0gPSAiVEVSTUlOQVRPUiI7CgkgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzWyJOVU1FUklDIl0gPSAxXSA9ICJOVU1FUklDIjsKCSAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbIkFMUEhBTlVNRVJJQyJdID0gMl0gPSAiQUxQSEFOVU1FUklDIjsKCSAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbIlNUUlVDVFVSRURfQVBQRU5EIl0gPSAzXSA9ICJTVFJVQ1RVUkVEX0FQUEVORCI7CgkgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzWyJCWVRFIl0gPSA0XSA9ICJCWVRFIjsKCSAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbIkVDSSJdID0gNV0gPSAiRUNJIjsKCSAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbIktBTkpJIl0gPSA2XSA9ICJLQU5KSSI7CgkgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzWyJGTkMxX0ZJUlNUX1BPU0lUSU9OIl0gPSA3XSA9ICJGTkMxX0ZJUlNUX1BPU0lUSU9OIjsKCSAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbIkZOQzFfU0VDT05EX1BPU0lUSU9OIl0gPSA4XSA9ICJGTkMxX1NFQ09ORF9QT1NJVElPTiI7CgkgICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgIkhhbnppIiBpcyBhIHRyYW5zbGl0ZXJhdGlvbiBvZiB0aGlzIG1vZGUgbmFtZS4gKi8KCSAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbIkhBTlpJIl0gPSA5XSA9ICJIQU5aSSI7Cgl9KShNb2RlVmFsdWVzID0gZXhwb3J0cy5Nb2RlVmFsdWVzIHx8IChleHBvcnRzLk1vZGVWYWx1ZXMgPSB7fSkpOwoJLyoqCgkgKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4xLCBUYWJsZXMgMiBhbmQgMy4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBtb2RlcyBpbiB3aGljaAoJICogZGF0YSBjYW4gYmUgZW5jb2RlZCB0byBiaXRzIGluIHRoZSBRUiBjb2RlIHN0YW5kYXJkLjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgTW9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBNb2RlKHZhbHVlLCBzdHJpbmdWYWx1ZSwgY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMsIGJpdHMgLyppbnQqLykgewoJICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7CgkgICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTsKCSAgICAgICAgdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucyA9IGNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zOwoJICAgICAgICB0aGlzLmJpdHMgPSBiaXRzOwoJICAgICAgICBNb2RlLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTsKCSAgICAgICAgTW9kZS5GT1JfVkFMVUUuc2V0KHZhbHVlLCB0aGlzKTsKCSAgICB9CgkgICAgLyoqCgkgICAgICogQHBhcmFtIGJpdHMgZm91ciBiaXRzIGVuY29kaW5nIGEgUVIgQ29kZSBkYXRhIG1vZGUKCSAgICAgKiBAcmV0dXJuIE1vZGUgZW5jb2RlZCBieSB0aGVzZSBiaXRzCgkgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYml0cyBkbyBub3QgY29ycmVzcG9uZCB0byBhIGtub3duIG1vZGUKCSAgICAgKi8KCSAgICBNb2RlLmZvckJpdHMgPSBmdW5jdGlvbiAoYml0cyAvKmludCovKSB7CgkgICAgICAgIHZhciBtb2RlID0gTW9kZS5GT1JfQklUUy5nZXQoYml0cyk7CgkgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG1vZGUpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIG1vZGU7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIGluIHF1ZXN0aW9uCgkgICAgICogQHJldHVybiBudW1iZXIgb2YgYml0cyB1c2VkLCBpbiB0aGlzIFFSIENvZGUgc3ltYm9sIHtAbGluayBWZXJzaW9ufSwgdG8gZW5jb2RlIHRoZQoJICAgICAqICAgICAgICAgY291bnQgb2YgY2hhcmFjdGVycyB0aGF0IHdpbGwgZm9sbG93IGVuY29kZWQgaW4gdGhpcyBNb2RlCgkgICAgICovCgkgICAgTW9kZS5wcm90b3R5cGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzID0gZnVuY3Rpb24gKHZlcnNpb24pIHsKCSAgICAgICAgdmFyIHZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKTsKCSAgICAgICAgdmFyIG9mZnNldDsKCSAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPD0gOSkgewoJICAgICAgICAgICAgb2Zmc2V0ID0gMDsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIGlmICh2ZXJzaW9uTnVtYmVyIDw9IDI2KSB7CgkgICAgICAgICAgICBvZmZzZXQgPSAxOwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgb2Zmc2V0ID0gMjsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9uc1tvZmZzZXRdOwoJICAgIH07CgkgICAgTW9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnZhbHVlOwoJICAgIH07CgkgICAgTW9kZS5wcm90b3R5cGUuZ2V0Qml0cyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYml0czsKCSAgICB9OwoJICAgIE1vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7CgkgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBNb2RlKSkgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIHZhciBvdGhlciA9IG87CgkgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTsKCSAgICB9OwoJICAgIE1vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTsKCSAgICB9OwoJICAgIE1vZGUuRk9SX0JJVFMgPSBuZXcgTWFwKCk7CgkgICAgTW9kZS5GT1JfVkFMVUUgPSBuZXcgTWFwKCk7CgkgICAgTW9kZS5URVJNSU5BVE9SID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5URVJNSU5BVE9SLCAnVEVSTUlOQVRPUicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDAwKTsgLy8gTm90IHJlYWxseSBhIG1vZGUuLi4KCSAgICBNb2RlLk5VTUVSSUMgPSBuZXcgTW9kZShNb2RlVmFsdWVzLk5VTUVSSUMsICdOVU1FUklDJywgSW50MzJBcnJheS5mcm9tKFsxMCwgMTIsIDE0XSksIDB4MDEpOwoJICAgIE1vZGUuQUxQSEFOVU1FUklDID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5BTFBIQU5VTUVSSUMsICdBTFBIQU5VTUVSSUMnLCBJbnQzMkFycmF5LmZyb20oWzksIDExLCAxM10pLCAweDAyKTsKCSAgICBNb2RlLlNUUlVDVFVSRURfQVBQRU5EID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5TVFJVQ1RVUkVEX0FQUEVORCwgJ1NUUlVDVFVSRURfQVBQRU5EJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDMpOyAvLyBOb3Qgc3VwcG9ydGVkCgkgICAgTW9kZS5CWVRFID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5CWVRFLCAnQllURScsIEludDMyQXJyYXkuZnJvbShbOCwgMTYsIDE2XSksIDB4MDQpOwoJICAgIE1vZGUuRUNJID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5FQ0ksICdFQ0knLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNyk7IC8vIGNoYXJhY3RlciBjb3VudHMgZG9uJ3QgYXBwbHkKCSAgICBNb2RlLktBTkpJID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5LQU5KSSwgJ0tBTkpJJywgSW50MzJBcnJheS5mcm9tKFs4LCAxMCwgMTJdKSwgMHgwOCk7CgkgICAgTW9kZS5GTkMxX0ZJUlNUX1BPU0lUSU9OID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5GTkMxX0ZJUlNUX1BPU0lUSU9OLCAnRk5DMV9GSVJTVF9QT1NJVElPTicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDA1KTsKCSAgICBNb2RlLkZOQzFfU0VDT05EX1BPU0lUSU9OID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5GTkMxX1NFQ09ORF9QT1NJVElPTiwgJ0ZOQzFfU0VDT05EX1BPU0lUSU9OJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDkpOwoJICAgIC8qKiBTZWUgR0JUIDE4Mjg0LTIwMDA7ICJIYW56aSIgaXMgYSB0cmFuc2xpdGVyYXRpb24gb2YgdGhpcyBtb2RlIG5hbWUuICovCgkgICAgTW9kZS5IQU5aSSA9IG5ldyBNb2RlKE1vZGVWYWx1ZXMuSEFOWkksICdIQU5aSScsIEludDMyQXJyYXkuZnJvbShbOCwgMTAsIDEyXSksIDB4MEQpOwoJICAgIHJldHVybiBNb2RlOwoJfSgpKTsKCWV4cG9ydHMuZGVmYXVsdCA9IE1vZGU7CgoJfShNb2RlKSk7CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmRlY29kZXIgeyovCgl2YXIgQml0U291cmNlXzEgPSBCaXRTb3VyY2UkMTsKCXZhciBDaGFyYWN0ZXJTZXRFQ0lfMSA9IENoYXJhY3RlclNldEVDSTsKCXZhciBEZWNvZGVyUmVzdWx0XzEgPSBEZWNvZGVyUmVzdWx0JDE7Cgl2YXIgU3RyaW5nVXRpbHNfMSA9IFN0cmluZ1V0aWxzJDE7Cgl2YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSBGb3JtYXRFeGNlcHRpb24kMTsKCXZhciBTdHJpbmdCdWlsZGVyXzEgPSBTdHJpbmdCdWlsZGVyJDE7Cgl2YXIgU3RyaW5nRW5jb2RpbmdfMSA9IFN0cmluZ0VuY29kaW5nJDE7Cgl2YXIgTW9kZV8xID0gTW9kZTsKCS8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqLwoJLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqLwoJLyppbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247Ki8KCS8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovCgkvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovCgkvKioKCSAqIDxwPlFSIENvZGVzIGNhbiBlbmNvZGUgdGV4dCBhcyBiaXRzIGluIG9uZSBvZiBzZXZlcmFsIG1vZGVzLCBhbmQgY2FuIHVzZSBtdWx0aXBsZSBtb2RlcwoJICogaW4gb25lIFFSIENvZGUuIFRoaXMgY2xhc3MgZGVjb2RlcyB0aGUgYml0cyBiYWNrIGludG8gdGV4dC48L3A+CgkgKgoJICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjQuMyAtIDYuNC43PC9wPgoJICoKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBEZWNvZGVkQml0U3RyZWFtUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIERlY29kZWRCaXRTdHJlYW1QYXJzZXIoKSB7CgkgICAgfQoJICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlID0gZnVuY3Rpb24gKGJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsLCBoaW50cykgewoJICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRTb3VyY2VfMS5kZWZhdWx0KGJ5dGVzKTsKCSAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpOwoJICAgICAgICB2YXIgYnl0ZVNlZ21lbnRzID0gbmV3IEFycmF5KCk7IC8vIDEKCSAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IEkgZG8gbm90IHVzZSBjb25zdHJ1Y3RvciB3aXRoIHNpemUgMSBhcyBpbiBvcmlnaW5hbCBKYXZhIG1lYW5zIGNhcGFjaXR5IGFuZCB0aGUgYXJyYXkgbGVuZ3RoIGlzIGNoZWNrZWQgYmVsb3cKCSAgICAgICAgdmFyIHN5bWJvbFNlcXVlbmNlID0gLTE7CgkgICAgICAgIHZhciBwYXJpdHlEYXRhID0gLTE7CgkgICAgICAgIHRyeSB7CgkgICAgICAgICAgICB2YXIgY3VycmVudENoYXJhY3RlclNldEVDSSA9IG51bGw7CgkgICAgICAgICAgICB2YXIgZmMxSW5FZmZlY3QgPSBmYWxzZTsKCSAgICAgICAgICAgIHZhciBtb2RlID0gdm9pZCAwOwoJICAgICAgICAgICAgZG8gewoJICAgICAgICAgICAgICAgIC8vIFdoaWxlIHN0aWxsIGFub3RoZXIgc2VnbWVudCB0byByZWFkLi4uCgkgICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7CgkgICAgICAgICAgICAgICAgICAgIC8vIE9LLCBhc3N1bWUgd2UncmUgZG9uZS4gUmVhbGx5LCBhIFRFUk1JTkFUT1IgbW9kZSBzaG91bGQgaGF2ZSBiZWVuIHJlY29yZGVkIGhlcmUKCSAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1vZGVfMS5kZWZhdWx0LlRFUk1JTkFUT1I7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZUJpdHMgPSBiaXRzLnJlYWRCaXRzKDQpOwoJICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZV8xLmRlZmF1bHQuZm9yQml0cyhtb2RlQml0cyk7IC8vIG1vZGUgaXMgZW5jb2RlZCBieSA0IGJpdHMKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7CgkgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuVEVSTUlOQVRPUjoKCSAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkZOQzFfRklSU1RfUE9TSVRJT046CgkgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuRk5DMV9TRUNPTkRfUE9TSVRJT046CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBsaXR0bGUgd2l0aCBGTkMxIGV4Y2VwdCBhbHRlciB0aGUgcGFyc2VkIHJlc3VsdCBhIGJpdCBhY2NvcmRpbmcgdG8gdGhlIHNwZWMKCSAgICAgICAgICAgICAgICAgICAgICAgIGZjMUluRWZmZWN0ID0gdHJ1ZTsKCSAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LlNUUlVDVFVSRURfQVBQRU5EOgoJICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxNikgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXIgYW5kIHBhcml0eSBpcyBhZGRlZCBsYXRlciB0byB0aGUgcmVzdWx0IG1ldGFkYXRhCgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIG5leHQgOCBiaXRzIChzeW1ib2wgc2VxdWVuY2UgIykgYW5kIDggYml0cyAoZGF0YTogcGFyaXR5KSwgdGhlbiBjb250aW51ZQoJICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sU2VxdWVuY2UgPSBiaXRzLnJlYWRCaXRzKDgpOwoJICAgICAgICAgICAgICAgICAgICAgICAgcGFyaXR5RGF0YSA9IGJpdHMucmVhZEJpdHMoOCk7CgkgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5FQ0k6CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBkb2Vzbid0IGFwcGx5IHRvIEVDSQoJICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5wYXJzZUVDSVZhbHVlKGJpdHMpOwoJICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXJhY3RlclNldEVDSSA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlWYWx1ZSh2YWx1ZSk7CgkgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlclNldEVDSSA9PT0gbnVsbCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5IQU5aSToKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGhhbmRsZSBIYW56aSBtb2RlIHdoaWNoIGRvZXMgbm90IHN0YXJ0IHdpdGggY2hhcmFjdGVyIGNvdW50CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGluZXNlIG1vZGUgY29udGFpbnMgYSBzdWIgc2V0IGluZGljYXRvciByaWdodCBhZnRlciBtb2RlIGluZGljYXRvcgoJICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNldCA9IGJpdHMucmVhZEJpdHMoNCk7CgkgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRIYW56aSA9IGJpdHMucmVhZEJpdHMobW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikpOwoJICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNldCA9PT0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5HQjIzMTJfU1VCU0VUKSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVIYW56aVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudEhhbnppKTsKCSAgICAgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OgoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gIk5vcm1hbCIgUVIgY29kZSBtb2RlczoKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBtYW55IGNoYXJhY3RlcnMgd2lsbCBmb2xsb3csIGVuY29kZWQgaW4gdGhpcyBtb2RlPwoJICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gYml0cy5yZWFkQml0cyhtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKSk7CgkgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0Lk5VTUVSSUM6CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlTnVtZXJpY1NlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCk7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuQUxQSEFOVU1FUklDOgoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUFscGhhbnVtZXJpY1NlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCwgZmMxSW5FZmZlY3QpOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkJZVEU6CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlQnl0ZVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCwgY3VycmVudENoYXJhY3RlclNldEVDSSwgYnl0ZVNlZ21lbnRzLCBoaW50cyk7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuS0FOSkk6CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlS2FuamlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQpOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OgoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfSB3aGlsZSAobW9kZSAhPT0gTW9kZV8xLmRlZmF1bHQuVEVSTUlOQVRPUik7CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGlhZSAvKjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKi8pIHsKCSAgICAgICAgICAgIC8vIGZyb20gcmVhZEJpdHMoKSBjYWxscwoJICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gbmV3IERlY29kZXJSZXN1bHRfMS5kZWZhdWx0KGJ5dGVzLCByZXN1bHQudG9TdHJpbmcoKSwgYnl0ZVNlZ21lbnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBieXRlU2VnbWVudHMsIGVjTGV2ZWwgPT09IG51bGwgPyBudWxsIDogZWNMZXZlbC50b1N0cmluZygpLCBzeW1ib2xTZXF1ZW5jZSwgcGFyaXR5RGF0YSk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBTZWUgc3BlY2lmaWNhdGlvbiBHQlQgMTgyODQtMjAwMAoJICAgICAqLwoJICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlSGFuemlTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykgewoJICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS4KCSAgICAgICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIC8vIEVhY2ggY2hhcmFjdGVyIHdpbGwgcmVxdWlyZSAyIGJ5dGVzLiBSZWFkIHRoZSBjaGFyYWN0ZXJzIGFzIDItYnl0ZSBwYWlycwoJICAgICAgICAvLyBhbmQgZGVjb2RlIGFzIEdCMjMxMiBhZnRlcndhcmRzCgkgICAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSgyICogY291bnQpOwoJICAgICAgICB2YXIgb2Zmc2V0ID0gMDsKCSAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkgewoJICAgICAgICAgICAgLy8gRWFjaCAxMyBiaXRzIGVuY29kZXMgYSAyLWJ5dGUgY2hhcmFjdGVyCgkgICAgICAgICAgICB2YXIgdHdvQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDEzKTsKCSAgICAgICAgICAgIHZhciBhc3NlbWJsZWRUd29CeXRlcyA9ICgoKHR3b0J5dGVzIC8gMHgwNjApIDw8IDgpICYgMHhGRkZGRkZGRikgfCAodHdvQnl0ZXMgJSAweDA2MCk7CgkgICAgICAgICAgICBpZiAoYXNzZW1ibGVkVHdvQnl0ZXMgPCAweDAwM0JGKSB7CgkgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4QTFBMSB0byAweEFBRkUgcmFuZ2UKCSAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBBMUExOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4QjBBMSB0byAweEZBRkUgcmFuZ2UKCSAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBBNkExOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAvKihieXRlKSAqLyAoKGFzc2VtYmxlZFR3b0J5dGVzID4+IDgpICYgMHhGRik7CgkgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAvKihieXRlKSAqLyAoYXNzZW1ibGVkVHdvQnl0ZXMgJiAweEZGKTsKCSAgICAgICAgICAgIG9mZnNldCArPSAyOwoJICAgICAgICAgICAgY291bnQtLTsKCSAgICAgICAgfQoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZGVjb2RlKGJ1ZmZlciwgU3RyaW5nVXRpbHNfMS5kZWZhdWx0LkdCMjMxMikpOwoJICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IFRPRE86IGltcGxlbWVudCBHQjIzMTIgZGVjb2RlLiBTdHJpbmdWaWV3IGZyb20gTUROIGNvdWxkIGJlIGEgc3RhcnRpbmcgcG9pbnQKCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdChpZ25vcmVkKTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVLYW5qaVNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7CgkgICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLgoJICAgICAgICBpZiAoY291bnQgKiAxMyA+IGJpdHMuYXZhaWxhYmxlKCkpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gRWFjaCBjaGFyYWN0ZXIgd2lsbCByZXF1aXJlIDIgYnl0ZXMuIFJlYWQgdGhlIGNoYXJhY3RlcnMgYXMgMi1ieXRlIHBhaXJzCgkgICAgICAgIC8vIGFuZCBkZWNvZGUgYXMgU2hpZnRfSklTIGFmdGVyd2FyZHMKCSAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDIgKiBjb3VudCk7CgkgICAgICAgIHZhciBvZmZzZXQgPSAwOwoJICAgICAgICB3aGlsZSAoY291bnQgPiAwKSB7CgkgICAgICAgICAgICAvLyBFYWNoIDEzIGJpdHMgZW5jb2RlcyBhIDItYnl0ZSBjaGFyYWN0ZXIKCSAgICAgICAgICAgIHZhciB0d29CeXRlcyA9IGJpdHMucmVhZEJpdHMoMTMpOwoJICAgICAgICAgICAgdmFyIGFzc2VtYmxlZFR3b0J5dGVzID0gKCgodHdvQnl0ZXMgLyAweDBDMCkgPDwgOCkgJiAweEZGRkZGRkZGKSB8ICh0d29CeXRlcyAlIDB4MEMwKTsKCSAgICAgICAgICAgIGlmIChhc3NlbWJsZWRUd29CeXRlcyA8IDB4MDFGMDApIHsKCSAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHg4MTQwIHRvIDB4OUZGQyByYW5nZQoJICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MDgxNDA7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHhFMDQwIHRvIDB4RUJCRiByYW5nZQoJICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEMxNDA7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IC8qKGJ5dGUpICovIChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KTsKCSAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IC8qKGJ5dGUpICovIGFzc2VtYmxlZFR3b0J5dGVzOwoJICAgICAgICAgICAgb2Zmc2V0ICs9IDI7CgkgICAgICAgICAgICBjb3VudC0tOwoJICAgICAgICB9CgkgICAgICAgIC8vIFNoaWZ0X0pJUyBtYXkgbm90IGJlIHN1cHBvcnRlZCBpbiBzb21lIGVudmlyb25tZW50czoKCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShidWZmZXIsIFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5TSElGVF9KSVMpKTsKCSAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBUT0RPOiBpbXBsZW1lbnQgU0hJRlRfSklTIGRlY29kZS4gU3RyaW5nVmlldyBmcm9tIE1ETiBjb3VsZCBiZSBhIHN0YXJ0aW5nIHBvaW50CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoaWdub3JlZCk7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlQnl0ZVNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovLCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLCBieXRlU2VnbWVudHMsIGhpbnRzKSB7CgkgICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLgoJICAgICAgICBpZiAoOCAqIGNvdW50ID4gYml0cy5hdmFpbGFibGUoKSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgcmVhZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpOwoJICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHsKCSAgICAgICAgICAgIHJlYWRCeXRlc1tpXSA9IC8qKGJ5dGUpICovIGJpdHMucmVhZEJpdHMoOCk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGVuY29kaW5nOwoJICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlclNldEVDSSA9PT0gbnVsbCkgewoJICAgICAgICAgICAgLy8gVGhlIHNwZWMgaXNuJ3QgY2xlYXIgb24gdGhpcyBtb2RlOyBzZWUKCSAgICAgICAgICAgIC8vIHNlY3Rpb24gNi40LjU6IHQgZG9lcyBub3Qgc2F5IHdoaWNoIGVuY29kaW5nIHRvIGFzc3VtaW5nCgkgICAgICAgICAgICAvLyB1cG9uIGRlY29kaW5nLiBJIGhhdmUgc2VlbiBJU08tODg1OS0xIHVzZWQgYXMgd2VsbCBhcwoJICAgICAgICAgICAgLy8gU2hpZnRfSklTIC0tIHdpdGhvdXQgYW55dGhpbmcgbGlrZSBhbiBFQ0kgZGVzaWduYXRvciB0bwoJICAgICAgICAgICAgLy8gZ2l2ZSBhIGhpbnQuCgkgICAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5ndWVzc0VuY29kaW5nKHJlYWRCeXRlcywgaGludHMpOwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgZW5jb2RpbmcgPSBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLmdldE5hbWUoKTsKCSAgICAgICAgfQoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZGVjb2RlKHJlYWRCeXRlcywgZW5jb2RpbmcpKTsKCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdChpZ25vcmVkKTsKCSAgICAgICAgfQoJICAgICAgICBieXRlU2VnbWVudHMucHVzaChyZWFkQnl0ZXMpOwoJICAgIH07CgkgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLykgewoJICAgICAgICBpZiAodmFsdWUgPj0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5BTFBIQU5VTUVSSUNfQ0hBUlMubGVuZ3RoKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkFMUEhBTlVNRVJJQ19DSEFSU1t2YWx1ZV07CgkgICAgfTsKCSAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUFscGhhbnVtZXJpY1NlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovLCBmYzFJbkVmZmVjdCkgewoJICAgICAgICAvLyBSZWFkIHR3byBjaGFyYWN0ZXJzIGF0IGEgdGltZQoJICAgICAgICB2YXIgc3RhcnQgPSByZXN1bHQubGVuZ3RoKCk7CgkgICAgICAgIHdoaWxlIChjb3VudCA+IDEpIHsKCSAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTEpIHsKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgdmFyIG5leHRUd29DaGFyc0JpdHMgPSBiaXRzLnJlYWRCaXRzKDExKTsKCSAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcihuZXh0VHdvQ2hhcnNCaXRzIC8gNDUpKSk7CgkgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKG5leHRUd29DaGFyc0JpdHMgJSA0NSkpOwoJICAgICAgICAgICAgY291bnQgLT0gMjsKCSAgICAgICAgfQoJICAgICAgICBpZiAoY291bnQgPT09IDEpIHsKCSAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb25lIGNoYXJhY3RlciBsZWZ0CgkgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDYpIHsKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcihiaXRzLnJlYWRCaXRzKDYpKSk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gU2VlIHNlY3Rpb24gNi40LjguMSwgNi40LjguMgoJICAgICAgICBpZiAoZmMxSW5FZmZlY3QpIHsKCSAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFzc2FnZSB0aGUgcmVzdWx0IGEgYml0IGlmIGluIGFuIEZOQzEgbW9kZToKCSAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHJlc3VsdC5sZW5ndGgoKTsgaSsrKSB7CgkgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jaGFyQXQoaSkgPT09ICclJykgewoJICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHJlc3VsdC5sZW5ndGgoKSAtIDEgJiYgcmVzdWx0LmNoYXJBdChpICsgMSkgPT09ICclJykgewoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gJSUgaXMgcmVuZGVyZWQgYXMgJQoJICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZUNoYXJBdChpICsgMSk7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBhbHBoYSBtb2RlLCAlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gRk5DMSBzZXBhcmF0b3IgMHgxRAoJICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldENoYXJBdChpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MUQpKTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgIH07CgkgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVOdW1lcmljU2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHsKCSAgICAgICAgLy8gUmVhZCB0aHJlZSBkaWdpdHMgYXQgYSB0aW1lCgkgICAgICAgIHdoaWxlIChjb3VudCA+PSAzKSB7CgkgICAgICAgICAgICAvLyBFYWNoIDEwIGJpdHMgZW5jb2RlcyB0aHJlZSBkaWdpdHMKCSAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTApIHsKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgdmFyIHRocmVlRGlnaXRzQml0cyA9IGJpdHMucmVhZEJpdHMoMTApOwoJICAgICAgICAgICAgaWYgKHRocmVlRGlnaXRzQml0cyA+PSAxMDAwKSB7CgkgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0aHJlZURpZ2l0c0JpdHMgLyAxMDApKSk7CgkgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTApICUgMTApKTsKCSAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIodGhyZWVEaWdpdHNCaXRzICUgMTApKTsKCSAgICAgICAgICAgIGNvdW50IC09IDM7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGNvdW50ID09PSAyKSB7CgkgICAgICAgICAgICAvLyBUd28gZGlnaXRzIGxlZnQgb3ZlciB0byByZWFkLCBlbmNvZGVkIGluIDcgYml0cwoJICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA3KSB7CgkgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHZhciB0d29EaWdpdHNCaXRzID0gYml0cy5yZWFkQml0cyg3KTsKCSAgICAgICAgICAgIGlmICh0d29EaWdpdHNCaXRzID49IDEwMCkgewoJICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodHdvRGlnaXRzQml0cyAvIDEwKSkpOwoJICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcih0d29EaWdpdHNCaXRzICUgMTApKTsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIGlmIChjb3VudCA9PT0gMSkgewoJICAgICAgICAgICAgLy8gT25lIGRpZ2l0IGxlZnQgb3ZlciB0byByZWFkCgkgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHsKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgdmFyIGRpZ2l0Qml0cyA9IGJpdHMucmVhZEJpdHMoNCk7CgkgICAgICAgICAgICBpZiAoZGlnaXRCaXRzID49IDEwKSB7CgkgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIoZGlnaXRCaXRzKSk7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIucGFyc2VFQ0lWYWx1ZSA9IGZ1bmN0aW9uIChiaXRzKSB7CgkgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpOwoJICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4ODApID09PSAwKSB7CgkgICAgICAgICAgICAvLyBqdXN0IG9uZSBieXRlCgkgICAgICAgICAgICByZXR1cm4gZmlyc3RCeXRlICYgMHg3RjsKCSAgICAgICAgfQoJICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4QzApID09PSAweDgwKSB7CgkgICAgICAgICAgICAvLyB0d28gYnl0ZXMKCSAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gYml0cy5yZWFkQml0cyg4KTsKCSAgICAgICAgICAgIHJldHVybiAoKChmaXJzdEJ5dGUgJiAweDNGKSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgc2Vjb25kQnl0ZTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4RTApID09PSAweEMwKSB7CgkgICAgICAgICAgICAvLyB0aHJlZSBieXRlcwoJICAgICAgICAgICAgdmFyIHNlY29uZFRoaXJkQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDE2KTsKCSAgICAgICAgICAgIHJldHVybiAoKChmaXJzdEJ5dGUgJiAweDFGKSA8PCAxNikgJiAweEZGRkZGRkZGKSB8IHNlY29uZFRoaXJkQnl0ZXM7CgkgICAgICAgIH0KCSAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiwgNi40LjQgVGFibGUgNQoJICAgICAqLwoJICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQUxQSEFOVU1FUklDX0NIQVJTID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAkJSorLS4vOic7CgkgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5HQjIzMTJfU1VCU0VUID0gMTsKCSAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjsKCX0oKSk7CglEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVmYXVsdCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXI7CgoJdmFyIFFSQ29kZURlY29kZXJNZXRhRGF0YSQxID0ge307CgoJLyoKCSAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShRUkNvZGVEZWNvZGVyTWV0YURhdGEkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLyoqCgkgKiBNZXRhLWRhdGEgY29udGFpbmVyIGZvciBRUiBDb2RlIGRlY29kaW5nLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBtYXkgYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYmFjayB0byB0aGUKCSAqIGRlY29kaW5nIGNhbGxlci4gQ2FsbGVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvY2VzcyB0aGlzLgoJICoKCSAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24uRGVjb2RlclJlc3VsdCNnZXRPdGhlcigpCgkgKi8KCXZhciBRUkNvZGVEZWNvZGVyTWV0YURhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gUVJDb2RlRGVjb2Rlck1ldGFEYXRhKG1pcnJvcmVkKSB7CgkgICAgICAgIHRoaXMubWlycm9yZWQgPSBtaXJyb3JlZDsKCSAgICB9CgkgICAgLyoqCgkgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBRUiBDb2RlIHdhcyBtaXJyb3JlZC4KCSAgICAgKi8KCSAgICBRUkNvZGVEZWNvZGVyTWV0YURhdGEucHJvdG90eXBlLmlzTWlycm9yZWQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcmVkOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQXBwbHkgdGhlIHJlc3VsdCBwb2ludHMnIG9yZGVyIGNvcnJlY3Rpb24gZHVlIHRvIG1pcnJvcmluZy4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzIHRvIGFwcGx5IG1pcnJvciBjb3JyZWN0aW9uIHRvLgoJICAgICAqLwoJICAgIFFSQ29kZURlY29kZXJNZXRhRGF0YS5wcm90b3R5cGUuYXBwbHlNaXJyb3JlZENvcnJlY3Rpb24gPSBmdW5jdGlvbiAocG9pbnRzKSB7CgkgICAgICAgIGlmICghdGhpcy5taXJyb3JlZCB8fCBwb2ludHMgPT09IG51bGwgfHwgcG9pbnRzLmxlbmd0aCA8IDMpIHsKCSAgICAgICAgICAgIHJldHVybjsKCSAgICAgICAgfQoJICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHBvaW50c1swXTsKCSAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzJdOwoJICAgICAgICBwb2ludHNbMl0gPSBib3R0b21MZWZ0OwoJICAgICAgICAvLyBObyBuZWVkIHRvICdmaXgnIHRvcC1sZWZ0IGFuZCBhbGlnbm1lbnQgcGF0dGVybi4KCSAgICB9OwoJICAgIHJldHVybiBRUkNvZGVEZWNvZGVyTWV0YURhdGE7Cgl9KCkpOwoJUVJDb2RlRGVjb2Rlck1ldGFEYXRhJDEuZGVmYXVsdCA9IFFSQ29kZURlY29kZXJNZXRhRGF0YTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fdmFsdWVzJDIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHsKCSAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDsKCSAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTsKCSAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09ICJudW1iZXIiKSByZXR1cm4gewoJICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7CgkgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwOwoJICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9OwoJICAgICAgICB9CgkgICAgfTsKCSAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyAiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS4iIDogIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC4iKTsKCX07CglPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVjb2RlciQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyIHsqLwoJdmFyIENoZWNrc3VtRXhjZXB0aW9uXzEgPSBDaGVja3N1bUV4Y2VwdGlvbiQxOwoJdmFyIEJpdE1hdHJpeF8xJDIgPSBCaXRNYXRyaXgkMTsKCXZhciBHZW5lcmljR0ZfMSA9IEdlbmVyaWNHRiQxOwoJdmFyIFJlZWRTb2xvbW9uRGVjb2Rlcl8xID0gUmVlZFNvbG9tb25EZWNvZGVyJDE7Cgl2YXIgQml0TWF0cml4UGFyc2VyXzEgPSBCaXRNYXRyaXhQYXJzZXIkMTsKCXZhciBEYXRhQmxvY2tfMSA9IERhdGFCbG9jayQxOwoJdmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMTsKCXZhciBRUkNvZGVEZWNvZGVyTWV0YURhdGFfMSQxID0gUVJDb2RlRGVjb2Rlck1ldGFEYXRhJDE7CgkvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovCgkvKioKCSAqIDxwPlRoZSBtYWluIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgUVIgQ29kZSBkZWNvZGluZyAtLSBhcyBvcHBvc2VkIHRvIGxvY2F0aW5nIGFuZCBleHRyYWN0aW5nCgkgKiB0aGUgUVIgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBEZWNvZGVyKCkgewoJICAgICAgICB0aGlzLnJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXJfMS5kZWZhdWx0KEdlbmVyaWNHRl8xLmRlZmF1bHQuUVJfQ09ERV9GSUVMRF8yNTYpOwoJICAgIH0KCSAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBib29sZWFuW11bXSk6IERlY29kZXJSZXN1bHQgLyp0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHsKCSAgICAvLyAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpCgkgICAgLy8gfQoJICAgIC8qKgoJICAgICAqIDxwPkNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNhbiBkZWNvZGUgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEgMkQgYXJyYXkgb2YgYm9vbGVhbnMuCgkgICAgICogInRydWUiIGlzIHRha2VuIHRvIG1lYW4gYSBibGFjayBtb2R1bGUuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGltYWdlIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBRUiBDb2RlIG1vZHVsZXMKCSAgICAgKiBAcGFyYW0gaGludHMgZGVjb2RpbmcgaGludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBpbmZsdWVuY2UgZGVjb2RpbmcKCSAgICAgKiBAcmV0dXJuIHRleHQgYW5kIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBRUiBDb2RlCgkgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWQKCSAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHMKCSAgICAgKi8KCSAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCb29sZWFuQXJyYXkgPSBmdW5jdGlvbiAoaW1hZ2UsIGhpbnRzKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdE1hdHJpeChCaXRNYXRyaXhfMSQyLmRlZmF1bHQucGFyc2VGcm9tQm9vbGVhbkFycmF5KGltYWdlKSwgaGludHMpOwoJICAgIH07CgkgICAgLy8gcHVibGljIGRlY29kZUJpdE1hdHJpeChiaXRzOiBCaXRNYXRyaXgpOiBEZWNvZGVyUmVzdWx0IC8qdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24qLyB7CgkgICAgLy8gICByZXR1cm4gZGVjb2RlKGJpdHMsIG51bGwpCgkgICAgLy8gfQoJICAgIC8qKgoJICAgICAqIDxwPkRlY29kZXMgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciAidHJ1ZSIgaXMgdGFrZW4gdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+CgkgICAgICoKCSAgICAgKiBAcGFyYW0gYml0cyBib29sZWFucyByZXByZXNlbnRpbmcgd2hpdGUvYmxhY2sgUVIgQ29kZSBtb2R1bGVzCgkgICAgICogQHBhcmFtIGhpbnRzIGRlY29kaW5nIGhpbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gaW5mbHVlbmNlIGRlY29kaW5nCgkgICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZQoJICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkCgkgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzCgkgICAgICovCgkgICAgRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlQml0TWF0cml4ID0gZnVuY3Rpb24gKGJpdHMsIGhpbnRzKSB7CgkgICAgICAgIC8vIENvbnN0cnVjdCBhIHBhcnNlciBhbmQgcmVhZCB2ZXJzaW9uLCBlcnJvci1jb3JyZWN0aW9uIGxldmVsCgkgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgQml0TWF0cml4UGFyc2VyXzEuZGVmYXVsdChiaXRzKTsKCSAgICAgICAgdmFyIGV4ID0gbnVsbDsKCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTsKCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoZSAvKjogRm9ybWF0RXhjZXB0aW9uLCBDaGVja3N1bUV4Y2VwdGlvbiovKSB7CgkgICAgICAgICAgICBleCA9IGU7CgkgICAgICAgIH0KCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIC8vIFJldmVydCB0aGUgYml0IG1hdHJpeAoJICAgICAgICAgICAgcGFyc2VyLnJlbWFzaygpOwoJICAgICAgICAgICAgLy8gV2lsbCBiZSBhdHRlbXB0aW5nIGEgbWlycm9yZWQgcmVhZGluZyBvZiB0aGUgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm8uCgkgICAgICAgICAgICBwYXJzZXIuc2V0TWlycm9yKHRydWUpOwoJICAgICAgICAgICAgLy8gUHJlZW1wdGl2ZWx5IHJlYWQgdGhlIHZlcnNpb24uCgkgICAgICAgICAgICBwYXJzZXIucmVhZFZlcnNpb24oKTsKCSAgICAgICAgICAgIC8vIFByZWVtcHRpdmVseSByZWFkIHRoZSBmb3JtYXQgaW5mb3JtYXRpb24uCgkgICAgICAgICAgICBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCk7CgkgICAgICAgICAgICAvKgoJICAgICAgICAgICAgICogU2luY2Ugd2UncmUgaGVyZSwgdGhpcyBtZWFucyB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSBkZXRlY3RlZCBzb21lIGtpbmQKCSAgICAgICAgICAgICAqIG9mIHZlcnNpb24gYW5kIGZvcm1hdCBpbmZvcm1hdGlvbiB3aGVuIG1pcnJvcmVkLiBUaGlzIGlzIGEgZ29vZCBzaWduLAoJICAgICAgICAgICAgICogdGhhdCB0aGUgUVIgY29kZSBtYXkgYmUgbWlycm9yZWQsIGFuZCB3ZSBzaG91bGQgdHJ5IG9uY2UgbW9yZSB3aXRoIGEKCSAgICAgICAgICAgICAqIG1pcnJvcmVkIGNvbnRlbnQuCgkgICAgICAgICAgICAgKi8KCSAgICAgICAgICAgIC8vIFByZXBhcmUgZm9yIGEgbWlycm9yZWQgcmVhZGluZy4KCSAgICAgICAgICAgIHBhcnNlci5taXJyb3IoKTsKCSAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTsKCSAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIE5vdGlmeSB0aGUgY2FsbGVyIHRoYXQgdGhlIGNvZGUgd2FzIG1pcnJvcmVkLgoJICAgICAgICAgICAgcmVzdWx0LnNldE90aGVyKG5ldyBRUkNvZGVEZWNvZGVyTWV0YURhdGFfMSQxLmRlZmF1bHQodHJ1ZSkpOwoJICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoZSAvKkZvcm1hdEV4Y2VwdGlvbiB8IENoZWNrc3VtRXhjZXB0aW9uKi8pIHsKCSAgICAgICAgICAgIC8vIFRocm93IHRoZSBleGNlcHRpb24gZnJvbSB0aGUgb3JpZ2luYWwgcmVhZGluZwoJICAgICAgICAgICAgaWYgKGV4ICE9PSBudWxsKSB7CgkgICAgICAgICAgICAgICAgdGhyb3cgZXg7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB0aHJvdyBlOwoJICAgICAgICB9CgkgICAgfTsKCSAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCaXRNYXRyaXhQYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyLCBoaW50cykgewoJICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjsKCSAgICAgICAgdmFyIHZlcnNpb24gPSBwYXJzZXIucmVhZFZlcnNpb24oKTsKCSAgICAgICAgdmFyIGVjTGV2ZWwgPSBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCkuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKTsKCSAgICAgICAgLy8gUmVhZCBjb2Rld29yZHMKCSAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7CgkgICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3MKCSAgICAgICAgdmFyIGRhdGFCbG9ja3MgPSBEYXRhQmxvY2tfMS5kZWZhdWx0LmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKTsKCSAgICAgICAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXMKCSAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwOwoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgZm9yICh2YXIgZGF0YUJsb2Nrc18xID0gX192YWx1ZXMkMihkYXRhQmxvY2tzKSwgZGF0YUJsb2Nrc18xXzEgPSBkYXRhQmxvY2tzXzEubmV4dCgpOyAhZGF0YUJsb2Nrc18xXzEuZG9uZTsgZGF0YUJsb2Nrc18xXzEgPSBkYXRhQmxvY2tzXzEubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgdmFyIGRhdGFCbG9jayA9IGRhdGFCbG9ja3NfMV8xLnZhbHVlOwoJICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZGF0YUJsb2NrLmdldE51bURhdGFDb2Rld29yZHMoKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfQoJICAgICAgICBmaW5hbGx5IHsKCSAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgaWYgKGRhdGFCbG9ja3NfMV8xICYmICFkYXRhQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGRhdGFCbG9ja3NfMS5yZXR1cm4pKSBfYS5jYWxsKGRhdGFCbG9ja3NfMSk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHJlc3VsdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7CgkgICAgICAgIHZhciByZXN1bHRPZmZzZXQgPSAwOwoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgLy8gRXJyb3ItY29ycmVjdCBhbmQgY29weSBkYXRhIGJsb2NrcyB0b2dldGhlciBpbnRvIGEgc3RyZWFtIG9mIGJ5dGVzCgkgICAgICAgICAgICBmb3IgKHZhciBkYXRhQmxvY2tzXzIgPSBfX3ZhbHVlcyQyKGRhdGFCbG9ja3MpLCBkYXRhQmxvY2tzXzJfMSA9IGRhdGFCbG9ja3NfMi5uZXh0KCk7ICFkYXRhQmxvY2tzXzJfMS5kb25lOyBkYXRhQmxvY2tzXzJfMSA9IGRhdGFCbG9ja3NfMi5uZXh0KCkpIHsKCSAgICAgICAgICAgICAgICB2YXIgZGF0YUJsb2NrID0gZGF0YUJsb2Nrc18yXzEudmFsdWU7CgkgICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkQnl0ZXMgPSBkYXRhQmxvY2suZ2V0Q29kZXdvcmRzKCk7CgkgICAgICAgICAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHMgPSBkYXRhQmxvY2suZ2V0TnVtRGF0YUNvZGV3b3JkcygpOwoJICAgICAgICAgICAgICAgIHRoaXMuY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKTsKCSAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykgewoJICAgICAgICAgICAgICAgICAgICByZXN1bHRCeXRlc1tyZXN1bHRPZmZzZXQrK10gPSBjb2Rld29yZEJ5dGVzW2ldOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfQoJICAgICAgICBmaW5hbGx5IHsKCSAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgaWYgKGRhdGFCbG9ja3NfMl8xICYmICFkYXRhQmxvY2tzXzJfMS5kb25lICYmIChfYiA9IGRhdGFCbG9ja3NfMi5yZXR1cm4pKSBfYi5jYWxsKGRhdGFCbG9ja3NfMik7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gRGVjb2RlIHRoZSBjb250ZW50cyBvZiB0aGF0IHN0cmVhbSBvZiBieXRlcwoJICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcl8xLmRlZmF1bHQuZGVjb2RlKHJlc3VsdEJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsLCBoaW50cyk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiA8cD5HaXZlbiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyByZWNlaXZlZCwgcG9zc2libHkgY29ycnVwdGVkIGJ5IGVycm9ycywgYXR0ZW1wdHMgdG8KCSAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UgdXNpbmcgUmVlZC1Tb2xvbW9uIGVycm9yIGNvcnJlY3Rpb24uPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGNvZGV3b3JkQnl0ZXMgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMKCSAgICAgKiBAcGFyYW0gbnVtRGF0YUNvZGV3b3JkcyBudW1iZXIgb2YgY29kZXdvcmRzIHRoYXQgYXJlIGRhdGEgYnl0ZXMKCSAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHMKCSAgICAgKi8KCSAgICBEZWNvZGVyLnByb3RvdHlwZS5jb3JyZWN0RXJyb3JzID0gZnVuY3Rpb24gKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMgLyppbnQqLykgewoJICAgICAgICAvLyBjb25zdCBudW1Db2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aDsKCSAgICAgICAgLy8gRmlyc3QgcmVhZCBpbnRvIGFuIGFycmF5IG9mIGludHMKCSAgICAgICAgdmFyIGNvZGV3b3Jkc0ludHMgPSBuZXcgSW50MzJBcnJheShjb2Rld29yZEJ5dGVzKTsKCSAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG5vdCByZWFseSBuZWNlc3NhcnkgdG8gdHJhbnNmb3JtIHRvIGludHM/IGNvdWxkIHJlZGVzaWduIGV2ZXJ5dGhpbmcgdG8gd29yayB3aXRoIHVuc2lnbmVkIGJ5dGVzPwoJICAgICAgICAvLyBjb25zdCBjb2Rld29yZHNJbnRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKQoJICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrKSB7CgkgICAgICAgIC8vICAgY29kZXdvcmRzSW50c1tpXSA9IGNvZGV3b3JkQnl0ZXNbaV0gJiAweEZGCgkgICAgICAgIC8vIH0KCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIHRoaXMucnNEZWNvZGVyLmRlY29kZShjb2Rld29yZHNJbnRzLCBjb2Rld29yZEJ5dGVzLmxlbmd0aCAtIG51bURhdGFDb2Rld29yZHMpOwoJICAgICAgICB9CgkgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBSZWVkU29sb21vbkV4Y2VwdGlvbiovKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gQ29weSBiYWNrIGludG8gYXJyYXkgb2YgYnl0ZXMgLS0gb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSBieXRlcyB0aGF0IHdlcmUgZGF0YQoJICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IGVycm9ycyBpbiB0aGUgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHsKCSAgICAgICAgICAgIGNvZGV3b3JkQnl0ZXNbaV0gPSAvKihieXRlKSAqLyBjb2Rld29yZHNJbnRzW2ldOwoJICAgICAgICB9CgkgICAgfTsKCSAgICByZXR1cm4gRGVjb2RlcjsKCX0oKSk7CglEZWNvZGVyJDEuZGVmYXVsdCA9IERlY29kZXI7CgoJdmFyIERldGVjdG9yJDEgPSB7fTsKCgl2YXIgTWF0aFV0aWxzJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdGhVdGlscyQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3RvciB7Ki8KCS8qKgoJICogR2VuZXJhbCBtYXRoLXJlbGF0ZWQgYW5kIG51bWVyaWMgdXRpbGl0eSBmdW5jdGlvbnMuCgkgKi8KCXZhciBNYXRoVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gTWF0aFV0aWxzKCkgewoJICAgIH0KCSAgICAvKioKCSAgICAgKiBFbmRzIHVwIGJlaW5nIGEgYml0IGZhc3RlciB0aGFuIHtAbGluayBNYXRoI3JvdW5kKGZsb2F0KX0uIFRoaXMgbWVyZWx5IHJvdW5kcyBpdHMKCSAgICAgKiBhcmd1bWVudCB0byB0aGUgbmVhcmVzdCBpbnQsIHdoZXJlIHguNSByb3VuZHMgdXAgdG8geCsxLiBTZW1hbnRpY3Mgb2YgdGhpcyBzaG9ydGN1dAoJICAgICAqIGRpZmZlciBzbGlnaHRseSBmcm9tIHtAbGluayBNYXRoI3JvdW5kKGZsb2F0KX0gaW4gdGhhdCBoYWxmIHJvdW5kcyBkb3duIGZvciBuZWdhdGl2ZQoJICAgICAqIHZhbHVlcy4gLTIuNSByb3VuZHMgdG8gLTMsIG5vdCAtMi4gRm9yIHB1cnBvc2VzIGhlcmUgaXQgbWFrZXMgbm8gZGlmZmVyZW5jZS4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBkIHJlYWwgdmFsdWUgdG8gcm91bmQKCSAgICAgKiBAcmV0dXJuIG5lYXJlc3Qge0Bjb2RlIGludH0KCSAgICAgKi8KCSAgICBNYXRoVXRpbHMucm91bmQgPSBmdW5jdGlvbiAoZCAvKmZsb2F0Ki8pIHsKCSAgICAgICAgaWYgKE5hTiA9PT0gZCkKCSAgICAgICAgICAgIHJldHVybiAwOwoJICAgICAgICBpZiAoZCA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikKCSAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjsKCSAgICAgICAgaWYgKGQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpCgkgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7CgkgICAgICAgIHJldHVybiAvKihpbnQpICovIChkICsgKGQgPCAwLjAgPyAtMC41IDogMC41KSkgfCAwOwoJICAgIH07CgkgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG1heWJlIHJlbW92ZSByb3VuZCBtZXRob2QgYW5kIGNhbGwgZGlyZWN0bHkgTWF0aC5yb3VuZCwgaXQgbG9va3MgbGlrZSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGpzCgkgICAgLyoqCgkgICAgICogQHBhcmFtIGFYIHBvaW50IEEgeCBjb29yZGluYXRlCgkgICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlCgkgICAgICogQHBhcmFtIGJYIHBvaW50IEIgeCBjb29yZGluYXRlCgkgICAgICogQHBhcmFtIGJZIHBvaW50IEIgeSBjb29yZGluYXRlCgkgICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQgoJICAgICAqLwoJICAgIE1hdGhVdGlscy5kaXN0YW5jZSA9IGZ1bmN0aW9uIChhWCAvKmZsb2F0fGludCovLCBhWSAvKmZsb2F0fGludCovLCBiWCAvKmZsb2F0fGludCovLCBiWSAvKmZsb2F0fGludCovKSB7CgkgICAgICAgIHZhciB4RGlmZiA9IGFYIC0gYlg7CgkgICAgICAgIHZhciB5RGlmZiA9IGFZIC0gYlk7CgkgICAgICAgIHJldHVybiAvKihmbG9hdCkgKi8gTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBhWCBwb2ludCBBIHggY29vcmRpbmF0ZQoJICAgICAqIEBwYXJhbSBhWSBwb2ludCBBIHkgY29vcmRpbmF0ZQoJICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZQoJICAgICAqIEBwYXJhbSBiWSBwb2ludCBCIHkgY29vcmRpbmF0ZQoJICAgICAqIEByZXR1cm4gRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIEEgYW5kIEIKCSAgICAgKi8KCSAgICAvLyBwdWJsaWMgc3RhdGljIGRpc3RhbmNlKGFYOiBudW1iZXIgLyppbnQqLywgYVk6IG51bWJlciAvKmludCovLCBiWDogbnVtYmVyIC8qaW50Ki8sIGJZOiBudW1iZXIgLyppbnQqLyk6IGZsb2F0IHsKCSAgICAvLyAgIGNvbnN0IHhEaWZmID0gYVggLSBiWAoJICAgIC8vICAgY29uc3QgeURpZmYgPSBhWSAtIGJZCgkgICAgLy8gICByZXR1cm4gKGZsb2F0KSBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpOwoJICAgIC8vIH0KCSAgICAvKioKCSAgICAgKiBAcGFyYW0gYXJyYXkgdmFsdWVzIHRvIHN1bQoJICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlcyBpbiBhcnJheQoJICAgICAqLwoJICAgIE1hdGhVdGlscy5zdW0gPSBmdW5jdGlvbiAoYXJyYXkpIHsKCSAgICAgICAgdmFyIGNvdW50ID0gMDsKCSAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gYXJyYXkubGVuZ3RoOyBpICE9PSBsZW5ndGhfMTsgaSsrKSB7CgkgICAgICAgICAgICB2YXIgYSA9IGFycmF5W2ldOwoJICAgICAgICAgICAgY291bnQgKz0gYTsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gY291bnQ7CgkgICAgfTsKCSAgICByZXR1cm4gTWF0aFV0aWxzOwoJfSgpKTsKCU1hdGhVdGlscyQxLmRlZmF1bHQgPSBNYXRoVXRpbHM7CgoJdmFyIERldGVjdG9yUmVzdWx0JDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KERldGVjdG9yUmVzdWx0JDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qKgoJICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGV0ZWN0aW5nIGEgYmFyY29kZSBpbiBhbiBpbWFnZS4gVGhpcyBpbmNsdWRlcyB0aGUgcmF3CgkgKiBtYXRyaXggb2YgYmxhY2svd2hpdGUgcGl4ZWxzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGJhcmNvZGUsIGFuZCBwb3NzaWJseSBwb2ludHMgb2YgaW50ZXJlc3QKCSAqIGluIHRoZSBpbWFnZSwgbGlrZSB0aGUgbG9jYXRpb24gb2YgZmluZGVyIHBhdHRlcm5zIG9yIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgRGV0ZWN0b3JSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gRGV0ZWN0b3JSZXN1bHQoYml0cywgcG9pbnRzKSB7CgkgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7CgkgICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzOwoJICAgIH0KCSAgICBEZXRlY3RvclJlc3VsdC5wcm90b3R5cGUuZ2V0Qml0cyA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYml0czsKCSAgICB9OwoJICAgIERldGVjdG9yUmVzdWx0LnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLnBvaW50czsKCSAgICB9OwoJICAgIHJldHVybiBEZXRlY3RvclJlc3VsdDsKCX0oKSk7CglEZXRlY3RvclJlc3VsdCQxLmRlZmF1bHQgPSBEZXRlY3RvclJlc3VsdDsKCgl2YXIgR3JpZFNhbXBsZXJJbnN0YW5jZSQxID0ge307CgoJdmFyIERlZmF1bHRHcmlkU2FtcGxlciQxID0ge307CgoJdmFyIEdyaWRTYW1wbGVyJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyaWRTYW1wbGVyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xJDUgPSBOb3RGb3VuZEV4Y2VwdGlvbiQxOwoJLyoqCgkgKiBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcyBjYW4sIGdpdmVuIGxvY2F0aW9ucyBvZiBmaW5kZXIgcGF0dGVybnMgZm9yIGEgUVIgY29kZSBpbiBhbgoJICogaW1hZ2UsIHNhbXBsZSB0aGUgcmlnaHQgcG9pbnRzIGluIHRoZSBpbWFnZSB0byByZWNvbnN0cnVjdCB0aGUgUVIgY29kZSwgYWNjb3VudGluZyBmb3IKCSAqIHBlcnNwZWN0aXZlIGRpc3RvcnRpb24uIEl0IGlzIGFic3RyYWN0ZWQgc2luY2UgaXQgaXMgcmVsYXRpdmVseSBleHBlbnNpdmUgYW5kIHNob3VsZCBiZSBhbGxvd2VkCgkgKiB0byB0YWtlIGFkdmFudGFnZSBvZiBwbGF0Zm9ybS1zcGVjaWZpYyBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb25zLCBsaWtlIFN1bidzIEphdmEgQWR2YW5jZWQKCSAqIEltYWdpbmcgbGlicmFyeSwgYnV0IHdoaWNoIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIG90aGVyIGVudmlyb25tZW50cyBzdWNoIGFzIEoyTUUsIGFuZCB2aWNlCgkgKiB2ZXJzYS4KCSAqCgkgKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlZCBjYW4gYmUgY29udHJvbGxlZCBieSBjYWxsaW5nIHtAbGluayAjc2V0R3JpZFNhbXBsZXIoR3JpZFNhbXBsZXIpfQoJICogd2l0aCBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgdGhpcyBpbnRlcmZhY2UuCgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEdyaWRTYW1wbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIEdyaWRTYW1wbGVyKCkgewoJICAgIH0KCSAgICAvKioKCSAgICAgKiA8cD5DaGVja3MgYSBzZXQgb2YgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIHRvIHNhbXBsZSBwb2ludHMgb24gYW4gaW1hZ2UgYWdhaW5zdAoJICAgICAqIHRoZSBpbWFnZSdzIGRpbWVuc2lvbnMgdG8gc2VlIGlmIHRoZSBwb2ludCBhcmUgZXZlbiB3aXRoaW4gdGhlIGltYWdlLjwvcD4KCSAgICAgKgoJICAgICAqIDxwPlRoaXMgbWV0aG9kIHdpbGwgYWN0dWFsbHkgIm51ZGdlIiB0aGUgZW5kcG9pbnRzIGJhY2sgb250byB0aGUgaW1hZ2UgaWYgdGhleSBhcmUgZm91bmQgdG8gYmUKCSAgICAgKiBiYXJlbHkgKGxlc3MgdGhhbiAxIHBpeGVsKSBvZmYgdGhlIGltYWdlLiBUaGlzIGFjY291bnRzIGZvciBpbXBlcmZlY3QgZGV0ZWN0aW9uIG9mIGZpbmRlcgoJICAgICAqIHBhdHRlcm5zIGluIGFuIGltYWdlIHdoZXJlIHRoZSBRUiBDb2RlIHJ1bnMgYWxsIHRoZSB3YXkgdG8gdGhlIGltYWdlIGJvcmRlci48L3A+CgkgICAgICoKCSAgICAgKiA8cD5Gb3IgZWZmaWNpZW5jeSwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIHBvaW50cyBmcm9tIGVpdGhlciBlbmQgb2YgdGhlIGxpbmUgdW50aWwgb25lIGlzIGZvdW5kCgkgICAgICogdG8gYmUgd2l0aGluIHRoZSBpbWFnZS4gQmVjYXVzZSB0aGUgc2V0IG9mIHBvaW50cyBhcmUgYXNzdW1lZCB0byBiZSBsaW5lYXIsIHRoaXMgaXMgdmFsaWQuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGltYWdlIGltYWdlIGludG8gd2hpY2ggdGhlIHBvaW50cyBzaG91bGQgbWFwCgkgICAgICogQHBhcmFtIHBvaW50cyBhY3R1YWwgcG9pbnRzIGluIHgxLHkxLC4uLix4bix5biBmb3JtCgkgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhbiBlbmRwb2ludCBpcyBsaWVzIG91dHNpZGUgdGhlIGltYWdlIGJvdW5kYXJpZXMKCSAgICAgKi8KCSAgICBHcmlkU2FtcGxlci5jaGVja0FuZE51ZGdlUG9pbnRzID0gZnVuY3Rpb24gKGltYWdlLCBwb2ludHMpIHsKCSAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpOwoJICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gc3RhcnQgdW50aWwgd2Ugc2VlIHNvbWUgdGhhdCBhcmUgT0s6CgkgICAgICAgIHZhciBudWRnZWQgPSB0cnVlOwoJICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHsKCSAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0XSk7CgkgICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldCArIDFdKTsKCSAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7CgkgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEkNS5kZWZhdWx0KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBudWRnZWQgPSBmYWxzZTsKCSAgICAgICAgICAgIGlmICh4ID09PSAtMSkgewoJICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gMC4wOwoJICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBlbHNlIGlmICh4ID09PSB3aWR0aCkgewoJICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gd2lkdGggLSAxOwoJICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBpZiAoeSA9PT0gLTEpIHsKCSAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSAwLjA7CgkgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGVsc2UgaWYgKHkgPT09IGhlaWdodCkgewoJICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7CgkgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gZW5kOgoJICAgICAgICBudWRnZWQgPSB0cnVlOwoJICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSBwb2ludHMubGVuZ3RoIC0gMjsgb2Zmc2V0ID49IDAgJiYgbnVkZ2VkOyBvZmZzZXQgLT0gMikgewoJICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTsKCSAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0ICsgMV0pOwoJICAgICAgICAgICAgaWYgKHggPCAtMSB8fCB4ID4gd2lkdGggfHwgeSA8IC0xIHx8IHkgPiBoZWlnaHQpIHsKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMSQ1LmRlZmF1bHQoKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIG51ZGdlZCA9IGZhbHNlOwoJICAgICAgICAgICAgaWYgKHggPT09IC0xKSB7CgkgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7CgkgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGVsc2UgaWYgKHggPT09IHdpZHRoKSB7CgkgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSB3aWR0aCAtIDE7CgkgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGlmICh5ID09PSAtMSkgewoJICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IDAuMDsKCSAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZWxzZSBpZiAoeSA9PT0gaGVpZ2h0KSB7CgkgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gaGVpZ2h0IC0gMTsKCSAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgfTsKCSAgICByZXR1cm4gR3JpZFNhbXBsZXI7Cgl9KCkpOwoJR3JpZFNhbXBsZXIkMS5kZWZhdWx0ID0gR3JpZFNhbXBsZXI7CgoJdmFyIFBlcnNwZWN0aXZlVHJhbnNmb3JtJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlcnNwZWN0aXZlVHJhbnNmb3JtJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJLyoqCgkgKiA8cD5UaGlzIGNsYXNzIGltcGxlbWVudHMgYSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gaW4gdHdvIGRpbWVuc2lvbnMuIEdpdmVuIGZvdXIgc291cmNlIGFuZCBmb3VyCgkgKiBkZXN0aW5hdGlvbiBwb2ludHMsIGl0IHdpbGwgY29tcHV0ZSB0aGUgdHJhbnNmb3JtYXRpb24gaW1wbGllZCBiZXR3ZWVuIHRoZW0uIFRoZSBjb2RlIGlzIGJhc2VkCgkgKiBkaXJlY3RseSB1cG9uIHNlY3Rpb24gMy40LjIgb2YgR2VvcmdlIFdvbGJlcmcncyAiRGlnaXRhbCBJbWFnZSBXYXJwaW5nIjsgc2VlIHBhZ2VzIDU0LTU2LjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gUGVyc3BlY3RpdmVUcmFuc2Zvcm0oYTExIC8qZmxvYXQqLywgYTIxIC8qZmxvYXQqLywgYTMxIC8qZmxvYXQqLywgYTEyIC8qZmxvYXQqLywgYTIyIC8qZmxvYXQqLywgYTMyIC8qZmxvYXQqLywgYTEzIC8qZmxvYXQqLywgYTIzIC8qZmxvYXQqLywgYTMzIC8qZmxvYXQqLykgewoJICAgICAgICB0aGlzLmExMSA9IGExMTsKCSAgICAgICAgdGhpcy5hMjEgPSBhMjE7CgkgICAgICAgIHRoaXMuYTMxID0gYTMxOwoJICAgICAgICB0aGlzLmExMiA9IGExMjsKCSAgICAgICAgdGhpcy5hMjIgPSBhMjI7CgkgICAgICAgIHRoaXMuYTMyID0gYTMyOwoJICAgICAgICB0aGlzLmExMyA9IGExMzsKCSAgICAgICAgdGhpcy5hMjMgPSBhMjM7CgkgICAgICAgIHRoaXMuYTMzID0gYTMzOwoJICAgIH0KCSAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsID0gZnVuY3Rpb24gKHgwIC8qZmxvYXQqLywgeTAgLypmbG9hdCovLCB4MSAvKmZsb2F0Ki8sIHkxIC8qZmxvYXQqLywgeDIgLypmbG9hdCovLCB5MiAvKmZsb2F0Ki8sIHgzIC8qZmxvYXQqLywgeTMgLypmbG9hdCovLCB4MHAgLypmbG9hdCovLCB5MHAgLypmbG9hdCovLCB4MXAgLypmbG9hdCovLCB5MXAgLypmbG9hdCovLCB4MnAgLypmbG9hdCovLCB5MnAgLypmbG9hdCovLCB4M3AgLypmbG9hdCovLCB5M3AgLypmbG9hdCovKSB7CgkgICAgICAgIHZhciBxVG9TID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvU3F1YXJlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7CgkgICAgICAgIHZhciBzVG9RID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKHgwcCwgeTBwLCB4MXAsIHkxcCwgeDJwLCB5MnAsIHgzcCwgeTNwKTsKCSAgICAgICAgcmV0dXJuIHNUb1EudGltZXMocVRvUyk7CgkgICAgfTsKCSAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cykgewoJICAgICAgICB2YXIgbWF4ID0gcG9pbnRzLmxlbmd0aDsKCSAgICAgICAgdmFyIGExMSA9IHRoaXMuYTExOwoJICAgICAgICB2YXIgYTEyID0gdGhpcy5hMTI7CgkgICAgICAgIHZhciBhMTMgPSB0aGlzLmExMzsKCSAgICAgICAgdmFyIGEyMSA9IHRoaXMuYTIxOwoJICAgICAgICB2YXIgYTIyID0gdGhpcy5hMjI7CgkgICAgICAgIHZhciBhMjMgPSB0aGlzLmEyMzsKCSAgICAgICAgdmFyIGEzMSA9IHRoaXMuYTMxOwoJICAgICAgICB2YXIgYTMyID0gdGhpcy5hMzI7CgkgICAgICAgIHZhciBhMzMgPSB0aGlzLmEzMzsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkgKz0gMikgewoJICAgICAgICAgICAgdmFyIHggPSBwb2ludHNbaV07CgkgICAgICAgICAgICB2YXIgeSA9IHBvaW50c1tpICsgMV07CgkgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMzsKCSAgICAgICAgICAgIHBvaW50c1tpXSA9IChhMTEgKiB4ICsgYTIxICogeSArIGEzMSkgLyBkZW5vbWluYXRvcjsKCSAgICAgICAgICAgIHBvaW50c1tpICsgMV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludHNXaXRoVmFsdWVzID0gZnVuY3Rpb24gKHhWYWx1ZXMsIHlWYWx1ZXMpIHsKCSAgICAgICAgdmFyIGExMSA9IHRoaXMuYTExOwoJICAgICAgICB2YXIgYTEyID0gdGhpcy5hMTI7CgkgICAgICAgIHZhciBhMTMgPSB0aGlzLmExMzsKCSAgICAgICAgdmFyIGEyMSA9IHRoaXMuYTIxOwoJICAgICAgICB2YXIgYTIyID0gdGhpcy5hMjI7CgkgICAgICAgIHZhciBhMjMgPSB0aGlzLmEyMzsKCSAgICAgICAgdmFyIGEzMSA9IHRoaXMuYTMxOwoJICAgICAgICB2YXIgYTMyID0gdGhpcy5hMzI7CgkgICAgICAgIHZhciBhMzMgPSB0aGlzLmEzMzsKCSAgICAgICAgdmFyIG4gPSB4VmFsdWVzLmxlbmd0aDsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsKCSAgICAgICAgICAgIHZhciB4ID0geFZhbHVlc1tpXTsKCSAgICAgICAgICAgIHZhciB5ID0geVZhbHVlc1tpXTsKCSAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IGExMyAqIHggKyBhMjMgKiB5ICsgYTMzOwoJICAgICAgICAgICAgeFZhbHVlc1tpXSA9IChhMTEgKiB4ICsgYTIxICogeSArIGEzMSkgLyBkZW5vbWluYXRvcjsKCSAgICAgICAgICAgIHlWYWx1ZXNbaV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7CgkgICAgICAgIH0KCSAgICB9OwoJICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnNxdWFyZVRvUXVhZHJpbGF0ZXJhbCA9IGZ1bmN0aW9uICh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLykgewoJICAgICAgICB2YXIgZHgzID0geDAgLSB4MSArIHgyIC0geDM7CgkgICAgICAgIHZhciBkeTMgPSB5MCAtIHkxICsgeTIgLSB5MzsKCSAgICAgICAgaWYgKGR4MyA9PT0gMC4wICYmIGR5MyA9PT0gMC4wKSB7CgkgICAgICAgICAgICAvLyBBZmZpbmUKCSAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCwgeDIgLSB4MSwgeDAsIHkxIC0geTAsIHkyIC0geTEsIHkwLCAwLjAsIDAuMCwgMS4wKTsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgIHZhciBkeDEgPSB4MSAtIHgyOwoJICAgICAgICAgICAgdmFyIGR4MiA9IHgzIC0geDI7CgkgICAgICAgICAgICB2YXIgZHkxID0geTEgLSB5MjsKCSAgICAgICAgICAgIHZhciBkeTIgPSB5MyAtIHkyOwoJICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gZHgxICogZHkyIC0gZHgyICogZHkxOwoJICAgICAgICAgICAgdmFyIGExMyA9IChkeDMgKiBkeTIgLSBkeDIgKiBkeTMpIC8gZGVub21pbmF0b3I7CgkgICAgICAgICAgICB2YXIgYTIzID0gKGR4MSAqIGR5MyAtIGR4MyAqIGR5MSkgLyBkZW5vbWluYXRvcjsKCSAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCArIGExMyAqIHgxLCB4MyAtIHgwICsgYTIzICogeDMsIHgwLCB5MSAtIHkwICsgYTEzICogeTEsIHkzIC0geTAgKyBhMjMgKiB5MywgeTAsIGExMywgYTIzLCAxLjApOwoJICAgICAgICB9CgkgICAgfTsKCSAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9TcXVhcmUgPSBmdW5jdGlvbiAoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8pIHsKCSAgICAgICAgLy8gSGVyZSwgdGhlIGFkam9pbnQgc2VydmVzIGFzIHRoZSBpbnZlcnNlOgoJICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykuYnVpbGRBZGpvaW50KCk7CgkgICAgfTsKCSAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5wcm90b3R5cGUuYnVpbGRBZGpvaW50ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICAvLyBBZGpvaW50IGlzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIGNvZmFjdG9yIG1hdHJpeDoKCSAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh0aGlzLmEyMiAqIHRoaXMuYTMzIC0gdGhpcy5hMjMgKiB0aGlzLmEzMiwgdGhpcy5hMjMgKiB0aGlzLmEzMSAtIHRoaXMuYTIxICogdGhpcy5hMzMsIHRoaXMuYTIxICogdGhpcy5hMzIgLSB0aGlzLmEyMiAqIHRoaXMuYTMxLCB0aGlzLmExMyAqIHRoaXMuYTMyIC0gdGhpcy5hMTIgKiB0aGlzLmEzMywgdGhpcy5hMTEgKiB0aGlzLmEzMyAtIHRoaXMuYTEzICogdGhpcy5hMzEsIHRoaXMuYTEyICogdGhpcy5hMzEgLSB0aGlzLmExMSAqIHRoaXMuYTMyLCB0aGlzLmExMiAqIHRoaXMuYTIzIC0gdGhpcy5hMTMgKiB0aGlzLmEyMiwgdGhpcy5hMTMgKiB0aGlzLmEyMSAtIHRoaXMuYTExICogdGhpcy5hMjMsIHRoaXMuYTExICogdGhpcy5hMjIgLSB0aGlzLmExMiAqIHRoaXMuYTIxKTsKCSAgICB9OwoJICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnByb3RvdHlwZS50aW1lcyA9IGZ1bmN0aW9uIChvdGhlcikgewoJICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTExICogb3RoZXIuYTExICsgdGhpcy5hMjEgKiBvdGhlci5hMTIgKyB0aGlzLmEzMSAqIG90aGVyLmExMywgdGhpcy5hMTEgKiBvdGhlci5hMjEgKyB0aGlzLmEyMSAqIG90aGVyLmEyMiArIHRoaXMuYTMxICogb3RoZXIuYTIzLCB0aGlzLmExMSAqIG90aGVyLmEzMSArIHRoaXMuYTIxICogb3RoZXIuYTMyICsgdGhpcy5hMzEgKiBvdGhlci5hMzMsIHRoaXMuYTEyICogb3RoZXIuYTExICsgdGhpcy5hMjIgKiBvdGhlci5hMTIgKyB0aGlzLmEzMiAqIG90aGVyLmExMywgdGhpcy5hMTIgKiBvdGhlci5hMjEgKyB0aGlzLmEyMiAqIG90aGVyLmEyMiArIHRoaXMuYTMyICogb3RoZXIuYTIzLCB0aGlzLmExMiAqIG90aGVyLmEzMSArIHRoaXMuYTIyICogb3RoZXIuYTMyICsgdGhpcy5hMzIgKiBvdGhlci5hMzMsIHRoaXMuYTEzICogb3RoZXIuYTExICsgdGhpcy5hMjMgKiBvdGhlci5hMTIgKyB0aGlzLmEzMyAqIG90aGVyLmExMywgdGhpcy5hMTMgKiBvdGhlci5hMjEgKyB0aGlzLmEyMyAqIG90aGVyLmEyMiArIHRoaXMuYTMzICogb3RoZXIuYTIzLCB0aGlzLmExMyAqIG90aGVyLmEzMSArIHRoaXMuYTIzICogb3RoZXIuYTMyICsgdGhpcy5hMzMgKiBvdGhlci5hMzMpOwoJICAgIH07CgkgICAgcmV0dXJuIFBlcnNwZWN0aXZlVHJhbnNmb3JtOwoJfSgpKTsKCVBlcnNwZWN0aXZlVHJhbnNmb3JtJDEuZGVmYXVsdCA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCgl2YXIgX19leHRlbmRzJDIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEdyaWRTYW1wbGVyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqLwoJdmFyIEdyaWRTYW1wbGVyXzEgPSBHcmlkU2FtcGxlciQxOwoJdmFyIEJpdE1hdHJpeF8xJDEgPSBCaXRNYXRyaXgkMTsKCXZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xJDEgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybSQxOwoJdmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEkNCA9IE5vdEZvdW5kRXhjZXB0aW9uJDE7CgkvKioKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBEZWZhdWx0R3JpZFNhbXBsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJDIoRGVmYXVsdEdyaWRTYW1wbGVyLCBfc3VwZXIpOwoJICAgIGZ1bmN0aW9uIERlZmF1bHRHcmlkU2FtcGxlcigpIHsKCSAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzOwoJICAgIH0KCSAgICAvKkBPdmVycmlkZSovCgkgICAgRGVmYXVsdEdyaWRTYW1wbGVyLnByb3RvdHlwZS5zYW1wbGVHcmlkID0gZnVuY3Rpb24gKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgcDFUb1ggLypmbG9hdCovLCBwMVRvWSAvKmZsb2F0Ki8sIHAyVG9YIC8qZmxvYXQqLywgcDJUb1kgLypmbG9hdCovLCBwM1RvWCAvKmZsb2F0Ki8sIHAzVG9ZIC8qZmxvYXQqLywgcDRUb1ggLypmbG9hdCovLCBwNFRvWSAvKmZsb2F0Ki8sIHAxRnJvbVggLypmbG9hdCovLCBwMUZyb21ZIC8qZmxvYXQqLywgcDJGcm9tWCAvKmZsb2F0Ki8sIHAyRnJvbVkgLypmbG9hdCovLCBwM0Zyb21YIC8qZmxvYXQqLywgcDNGcm9tWSAvKmZsb2F0Ki8sIHA0RnJvbVggLypmbG9hdCovLCBwNEZyb21ZIC8qZmxvYXQqLykgewoJICAgICAgICB2YXIgdHJhbnNmb3JtID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm1fMSQxLmRlZmF1bHQucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbChwMVRvWCwgcDFUb1ksIHAyVG9YLCBwMlRvWSwgcDNUb1gsIHAzVG9ZLCBwNFRvWCwgcDRUb1ksIHAxRnJvbVgsIHAxRnJvbVksIHAyRnJvbVgsIHAyRnJvbVksIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsIHA0RnJvbVkpOwoJICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgdHJhbnNmb3JtKTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBEZWZhdWx0R3JpZFNhbXBsZXIucHJvdG90eXBlLnNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtID0gZnVuY3Rpb24gKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgdHJhbnNmb3JtKSB7CgkgICAgICAgIGlmIChkaW1lbnNpb25YIDw9IDAgfHwgZGltZW5zaW9uWSA8PSAwKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMSQ0LmRlZmF1bHQoKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXhfMSQxLmRlZmF1bHQoZGltZW5zaW9uWCwgZGltZW5zaW9uWSk7CgkgICAgICAgIHZhciBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBkaW1lbnNpb25YKTsKCSAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBkaW1lbnNpb25ZOyB5KyspIHsKCSAgICAgICAgICAgIHZhciBtYXggPSBwb2ludHMubGVuZ3RoOwoJICAgICAgICAgICAgdmFyIGlWYWx1ZSA9IHkgKyAwLjU7CgkgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7CgkgICAgICAgICAgICAgICAgcG9pbnRzW3hdID0gKHggLyAyKSArIDAuNTsKCSAgICAgICAgICAgICAgICBwb2ludHNbeCArIDFdID0gaVZhbHVlOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVBvaW50cyhwb2ludHMpOwoJICAgICAgICAgICAgLy8gUXVpY2sgY2hlY2sgdG8gc2VlIGlmIHBvaW50cyB0cmFuc2Zvcm1lZCB0byBzb21ldGhpbmcgaW5zaWRlIHRoZSBpbWFnZQoJICAgICAgICAgICAgLy8gc3VmZmljaWVudCB0byBjaGVjayB0aGUgZW5kcG9pbnRzCgkgICAgICAgICAgICBHcmlkU2FtcGxlcl8xLmRlZmF1bHQuY2hlY2tBbmROdWRnZVBvaW50cyhpbWFnZSwgcG9pbnRzKTsKCSAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXg7IHggKz0gMikgewoJICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KE1hdGguZmxvb3IocG9pbnRzW3hdKSwgTWF0aC5mbG9vcihwb2ludHNbeCArIDFdKSkpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrKC1pc2gpIHBpeGVsCgkgICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnNldCh4IC8gMiwgeSk7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBjYXRjaCAoYWlvb2JlIC8qOiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24qLykgewoJICAgICAgICAgICAgICAgIC8vIFRoaXMgZmVlbHMgd3JvbmcsIGJ1dCwgc29tZXRpbWVzIGlmIHRoZSBmaW5kZXIgcGF0dGVybnMgYXJlIG1pc2lkZW50aWZpZWQsIHRoZSByZXN1bHRpbmcKCSAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gZ2V0cyAidHdpc3RlZCIgc3VjaCB0aGF0IGl0IG1hcHMgYSBzdHJhaWdodCBsaW5lIG9mIHBvaW50cyB0byBhIHNldCBvZiBwb2ludHMKCSAgICAgICAgICAgICAgICAvLyB3aG9zZSBlbmRwb2ludHMgYXJlIGluIGJvdW5kcywgYnV0IG90aGVycyBhcmUgbm90LiBUaGVyZSBpcyBwcm9iYWJseSBzb21lIG1hdGhlbWF0aWNhbAoJICAgICAgICAgICAgICAgIC8vIHdheSB0byBkZXRlY3QgdGhpcyBhYm91dCB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCBJIGRvbid0IGtub3cgeWV0LgoJICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhbiB1Z2x5IHJ1bnRpbWUgZXhjZXB0aW9uIGRlc3BpdGUgb3VyIGNsZXZlciBjaGVja3MgYWJvdmUgLS0gY2FuJ3QgaGF2ZQoJICAgICAgICAgICAgICAgIC8vIHRoYXQuIFdlIGNvdWxkIGNoZWNrIGVhY2ggcG9pbnQncyBjb29yZGluYXRlcyBidXQgdGhhdCBmZWVscyBkdXBsaWNhdGl2ZS4gV2Ugc2V0dGxlIGZvcgoJICAgICAgICAgICAgICAgIC8vIGNhdGNoaW5nIGFuZCB3cmFwcGluZyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uCgkgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEkNC5kZWZhdWx0KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGJpdHM7CgkgICAgfTsKCSAgICByZXR1cm4gRGVmYXVsdEdyaWRTYW1wbGVyOwoJfShHcmlkU2FtcGxlcl8xLmRlZmF1bHQpKTsKCURlZmF1bHRHcmlkU2FtcGxlciQxLmRlZmF1bHQgPSBEZWZhdWx0R3JpZFNhbXBsZXI7CgoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyaWRTYW1wbGVySW5zdGFuY2UkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIERlZmF1bHRHcmlkU2FtcGxlcl8xID0gRGVmYXVsdEdyaWRTYW1wbGVyJDE7Cgl2YXIgR3JpZFNhbXBsZXJJbnN0YW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBHcmlkU2FtcGxlckluc3RhbmNlKCkgewoJICAgIH0KCSAgICAvKioKCSAgICAgKiBTZXRzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlciB1c2VkIGJ5IHRoZSBsaWJyYXJ5LiBPbmUgZ2xvYmFsCgkgICAgICogaW5zdGFuY2UgaXMgc3RvcmVkLCB3aGljaCBtYXkgc291bmQgcHJvYmxlbWF0aWMuIEJ1dCwgdGhlIGltcGxlbWVudGF0aW9uIHByb3ZpZGVkCgkgICAgICogb3VnaHQgdG8gYmUgYXBwcm9wcmlhdGUgZm9yIHRoZSBlbnRpcmUgcGxhdGZvcm0sIGFuZCBhbGwgdXNlcyBvZiB0aGlzIGxpYnJhcnkKCSAgICAgKiBpbiB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIEpWTS4gRm9yIGluc3RhbmNlLCBhbiBBbmRyb2lkIGFjdGl2aXR5IGNhbiBzd2FwIGluCgkgICAgICogYW4gaW1wbGVtZW50YXRpb24gdGhhdCB0YWtlcyBhZHZhbnRhZ2Ugb2YgbmF0aXZlIHBsYXRmb3JtIGxpYnJhcmllcy4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBuZXdHcmlkU2FtcGxlciBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgb2JqZWN0IHRvIGluc3RhbGwuCgkgICAgICovCgkgICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5zZXRHcmlkU2FtcGxlciA9IGZ1bmN0aW9uIChuZXdHcmlkU2FtcGxlcikgewoJICAgICAgICBHcmlkU2FtcGxlckluc3RhbmNlLmdyaWRTYW1wbGVyID0gbmV3R3JpZFNhbXBsZXI7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyCgkgICAgICovCgkgICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXI7CgkgICAgfTsKCSAgICBHcmlkU2FtcGxlckluc3RhbmNlLmdyaWRTYW1wbGVyID0gbmV3IERlZmF1bHRHcmlkU2FtcGxlcl8xLmRlZmF1bHQoKTsKCSAgICByZXR1cm4gR3JpZFNhbXBsZXJJbnN0YW5jZTsKCX0oKSk7CglHcmlkU2FtcGxlckluc3RhbmNlJDEuZGVmYXVsdCA9IEdyaWRTYW1wbGVySW5zdGFuY2U7CgoJdmFyIFJlc3VsdFBvaW50JDEgPSB7fTsKCgl2YXIgRmxvYXQkMSA9IHt9OwoKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbG9hdCQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKioKCSAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgRmxvYXQgY2xhc3MuCgkgKi8KCXZhciBGbG9hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBGbG9hdCgpIHsKCSAgICB9CgkgICAgLyoqCgkgICAgICogU2luY1RTIGhhcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gaW50IGFuZCBmbG9hdCwgdGhlcmUncyBhbGwgbnVtYmVycywKCSAgICAgKiB0aGlzIGlzIHVzZWQgb25seSB0byBwb2x5ZmlsbCBKYXZhIGNvZGUuCgkgICAgICovCgkgICAgRmxvYXQuZmxvYXRUb0ludEJpdHMgPSBmdW5jdGlvbiAoZikgewoJICAgICAgICByZXR1cm4gZjsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFRoZSBmbG9hdCBtYXggdmFsdWUgaW4gSlMgaXMgdGhlIG51bWJlciBtYXggdmFsdWUuCgkgICAgICovCgkgICAgRmxvYXQuTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7CgkgICAgcmV0dXJuIEZsb2F0OwoJfSgpKTsKCUZsb2F0JDEuZGVmYXVsdCA9IEZsb2F0OwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzdWx0UG9pbnQkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki8KCXZhciBNYXRoVXRpbHNfMSQxID0gTWF0aFV0aWxzJDE7Cgl2YXIgRmxvYXRfMSA9IEZsb2F0JDE7CgkvKioKCSAqIDxwPkVuY2Fwc3VsYXRlcyBhIHBvaW50IG9mIGludGVyZXN0IGluIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBiYXJjb2RlLiBUeXBpY2FsbHksIHRoaXMKCSAqIHdvdWxkIGJlIHRoZSBsb2NhdGlvbiBvZiBhIGZpbmRlciBwYXR0ZXJuIG9yIHRoZSBjb3JuZXIgb2YgdGhlIGJhcmNvZGUsIGZvciBleGFtcGxlLjwvcD4KCSAqCgkgKiBAYXV0aG9yIFNlYW4gT3dlbgoJICovCgl2YXIgUmVzdWx0UG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgZnVuY3Rpb24gUmVzdWx0UG9pbnQoeCwgeSkgewoJICAgICAgICB0aGlzLnggPSB4OwoJICAgICAgICB0aGlzLnkgPSB5OwoJICAgIH0KCSAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMueDsKCSAgICB9OwoJICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy55OwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVzdWx0UG9pbnQpIHsKCSAgICAgICAgICAgIHZhciBvdGhlclBvaW50ID0gb3RoZXI7CgkgICAgICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlclBvaW50LnggJiYgdGhpcy55ID09PSBvdGhlclBvaW50Lnk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgIH07CgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIDMxICogRmxvYXRfMS5kZWZhdWx0LmZsb2F0VG9JbnRCaXRzKHRoaXMueCkgKyBGbG9hdF8xLmRlZmF1bHQuZmxvYXRUb0ludEJpdHModGhpcy55KTsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnKSc7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0IEFCIGlzIGxlc3MgdGhhbiBBQwoJICAgICAqIGFuZCBCQyBpcyBsZXNzIHRoYW4gQUMsIGFuZCB0aGUgYW5nbGUgYmV0d2VlbiBCQyBhbmQgQkEgaXMgbGVzcyB0aGFuIDE4MCBkZWdyZWVzLgoJICAgICAqCgkgICAgICogQHBhcmFtIHBhdHRlcm5zIGFycmF5IG9mIHRocmVlIHtAY29kZSBSZXN1bHRQb2ludH0gdG8gb3JkZXIKCSAgICAgKi8KCSAgICBSZXN1bHRQb2ludC5vcmRlckJlc3RQYXR0ZXJucyA9IGZ1bmN0aW9uIChwYXR0ZXJucykgewoJICAgICAgICAvLyBGaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHBhdHRlcm4gY2VudGVycwoJICAgICAgICB2YXIgemVyb09uZURpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMV0pOwoJICAgICAgICB2YXIgb25lVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzFdLCBwYXR0ZXJuc1syXSk7CgkgICAgICAgIHZhciB6ZXJvVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1syXSk7CgkgICAgICAgIHZhciBwb2ludEE7CgkgICAgICAgIHZhciBwb2ludEI7CgkgICAgICAgIHZhciBwb2ludEM7CgkgICAgICAgIC8vIEFzc3VtZSBvbmUgY2xvc2VzdCB0byBvdGhlciB0d28gaXMgQjsgQSBhbmQgQyB3aWxsIGp1c3QgYmUgZ3Vlc3NlcyBhdCBmaXJzdAoJICAgICAgICBpZiAob25lVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlICYmIG9uZVR3b0Rpc3RhbmNlID49IHplcm9Ud29EaXN0YW5jZSkgewoJICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07CgkgICAgICAgICAgICBwb2ludEEgPSBwYXR0ZXJuc1sxXTsKCSAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdOwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgaWYgKHplcm9Ud29EaXN0YW5jZSA+PSBvbmVUd29EaXN0YW5jZSAmJiB6ZXJvVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlKSB7CgkgICAgICAgICAgICBwb2ludEIgPSBwYXR0ZXJuc1sxXTsKCSAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdOwoJICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07CgkgICAgICAgIH0KCSAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICBwb2ludEIgPSBwYXR0ZXJuc1syXTsKCSAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdOwoJICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMV07CgkgICAgICAgIH0KCSAgICAgICAgLy8gVXNlIGNyb3NzIHByb2R1Y3QgdG8gZmlndXJlIG91dCB3aGV0aGVyIEEgYW5kIEMgYXJlIGNvcnJlY3Qgb3IgZmxpcHBlZC4KCSAgICAgICAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50CgkgICAgICAgIC8vIHdlIHdhbnQgZm9yIEEsIEIsIEMuIElmIGl0J3MgbmVnYXRpdmUsIHRoZW4gd2UndmUgZ290IGl0IGZsaXBwZWQgYXJvdW5kIGFuZAoJICAgICAgICAvLyBzaG91bGQgc3dhcCBBIGFuZCBDLgoJICAgICAgICBpZiAodGhpcy5jcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIDwgMC4wKSB7CgkgICAgICAgICAgICB2YXIgdGVtcCA9IHBvaW50QTsKCSAgICAgICAgICAgIHBvaW50QSA9IHBvaW50QzsKCSAgICAgICAgICAgIHBvaW50QyA9IHRlbXA7CgkgICAgICAgIH0KCSAgICAgICAgcGF0dGVybnNbMF0gPSBwb2ludEE7CgkgICAgICAgIHBhdHRlcm5zWzFdID0gcG9pbnRCOwoJICAgICAgICBwYXR0ZXJuc1syXSA9IHBvaW50QzsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEBwYXJhbSBwYXR0ZXJuMSBmaXJzdCBwYXR0ZXJuCgkgICAgICogQHBhcmFtIHBhdHRlcm4yIHNlY29uZCBwYXR0ZXJuCgkgICAgICogQHJldHVybiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMKCSAgICAgKi8KCSAgICBSZXN1bHRQb2ludC5kaXN0YW5jZSA9IGZ1bmN0aW9uIChwYXR0ZXJuMSwgcGF0dGVybjIpIHsKCSAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xJDEuZGVmYXVsdC5kaXN0YW5jZShwYXR0ZXJuMS54LCBwYXR0ZXJuMS55LCBwYXR0ZXJuMi54LCBwYXR0ZXJuMi55KTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIFJldHVybnMgdGhlIHogY29tcG9uZW50IG9mIHRoZSBjcm9zcyBwcm9kdWN0IGJldHdlZW4gdmVjdG9ycyBCQyBhbmQgQkEuCgkgICAgICovCgkgICAgUmVzdWx0UG9pbnQuY3Jvc3NQcm9kdWN0WiA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50QiwgcG9pbnRDKSB7CgkgICAgICAgIHZhciBiWCA9IHBvaW50Qi54OwoJICAgICAgICB2YXIgYlkgPSBwb2ludEIueTsKCSAgICAgICAgcmV0dXJuICgocG9pbnRDLnggLSBiWCkgKiAocG9pbnRBLnkgLSBiWSkpIC0gKChwb2ludEMueSAtIGJZKSAqIChwb2ludEEueCAtIGJYKSk7CgkgICAgfTsKCSAgICByZXR1cm4gUmVzdWx0UG9pbnQ7Cgl9KCkpOwoJUmVzdWx0UG9pbnQkMS5kZWZhdWx0ID0gUmVzdWx0UG9pbnQ7CgoJdmFyIEFsaWdubWVudFBhdHRlcm5GaW5kZXIkMSA9IHt9OwoKCXZhciBBbGlnbm1lbnRQYXR0ZXJuJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fZXh0ZW5kcyQxID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKCSAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHwKCSAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9OwoJICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTsKCSAgICB9OwoJICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikgewoJICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH0KCSAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpOwoJICAgIH07Cgl9KSgpOwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEFsaWdubWVudFBhdHRlcm4kMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGV0ZWN0b3IgeyovCgl2YXIgUmVzdWx0UG9pbnRfMSQzID0gUmVzdWx0UG9pbnQkMTsKCS8qKgoJICogPHA+RW5jYXBzdWxhdGVzIGFuIGFsaWdubWVudCBwYXR0ZXJuLCB3aGljaCBhcmUgdGhlIHNtYWxsZXIgc3F1YXJlIHBhdHRlcm5zIGZvdW5kIGluCgkgKiBhbGwgYnV0IHRoZSBzaW1wbGVzdCBRUiBDb2Rlcy48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEFsaWdubWVudFBhdHRlcm4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7CgkgICAgX19leHRlbmRzJDEoQWxpZ25tZW50UGF0dGVybiwgX3N1cGVyKTsKCSAgICBmdW5jdGlvbiBBbGlnbm1lbnRQYXR0ZXJuKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHsKCSAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcG9zWCwgcG9zWSkgfHwgdGhpczsKCSAgICAgICAgX3RoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7CgkgICAgICAgIHJldHVybiBfdGhpczsKCSAgICB9CgkgICAgLyoqCgkgICAgICogPHA+RGV0ZXJtaW5lcyBpZiB0aGlzIGFsaWdubWVudCBwYXR0ZXJuICJhYm91dCBlcXVhbHMiIGFuIGFsaWdubWVudCBwYXR0ZXJuIGF0IHRoZSBzdGF0ZWQKCSAgICAgKiBwb3NpdGlvbiBhbmQgc2l6ZSAtLSBtZWFuaW5nLCBpdCBpcyBhdCBuZWFybHkgdGhlIHNhbWUgY2VudGVyIHdpdGggbmVhcmx5IHRoZSBzYW1lIHNpemUuPC9wPgoJICAgICAqLwoJICAgIEFsaWdubWVudFBhdHRlcm4ucHJvdG90eXBlLmFib3V0RXF1YWxzID0gZnVuY3Rpb24gKG1vZHVsZVNpemUgLypmbG9hdCovLCBpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8pIHsKCSAgICAgICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLmdldFkoKSkgPD0gbW9kdWxlU2l6ZSAmJiBNYXRoLmFicyhqIC0gdGhpcy5nZXRYKCkpIDw9IG1vZHVsZVNpemUpIHsKCSAgICAgICAgICAgIHZhciBtb2R1bGVTaXplRGlmZiA9IE1hdGguYWJzKG1vZHVsZVNpemUgLSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUpOwoJICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kIG1vZHVsZSBzaXplCgkgICAgICogd2l0aCBhIG5ldyBlc3RpbWF0ZS4gSXQgcmV0dXJucyBhIG5ldyB7QGNvZGUgRmluZGVyUGF0dGVybn0gY29udGFpbmluZyBhbiBhdmVyYWdlIG9mIHRoZSB0d28uCgkgICAgICovCgkgICAgQWxpZ25tZW50UGF0dGVybi5wcm90b3R5cGUuY29tYmluZUVzdGltYXRlID0gZnVuY3Rpb24gKGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLywgbmV3TW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHsKCSAgICAgICAgdmFyIGNvbWJpbmVkWCA9ICh0aGlzLmdldFgoKSArIGopIC8gMi4wOwoJICAgICAgICB2YXIgY29tYmluZWRZID0gKHRoaXMuZ2V0WSgpICsgaSkgLyAyLjA7CgkgICAgICAgIHZhciBjb21iaW5lZE1vZHVsZVNpemUgPSAodGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyAyLjA7CgkgICAgICAgIHJldHVybiBuZXcgQWxpZ25tZW50UGF0dGVybihjb21iaW5lZFgsIGNvbWJpbmVkWSwgY29tYmluZWRNb2R1bGVTaXplKTsKCSAgICB9OwoJICAgIHJldHVybiBBbGlnbm1lbnRQYXR0ZXJuOwoJfShSZXN1bHRQb2ludF8xJDMuZGVmYXVsdCkpOwoJQWxpZ25tZW50UGF0dGVybiQxLmRlZmF1bHQgPSBBbGlnbm1lbnRQYXR0ZXJuOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCgl2YXIgX192YWx1ZXMkMSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykgewoJICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwOwoJICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pOwoJICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gIm51bWJlciIpIHJldHVybiB7CgkgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7CgkgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07CgkgICAgICAgIH0KCSAgICB9OwoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/ICJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLiIgOiAiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLiIpOwoJfTsKCU9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbGlnbm1lbnRQYXR0ZXJuRmluZGVyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCXZhciBBbGlnbm1lbnRQYXR0ZXJuXzEgPSBBbGlnbm1lbnRQYXR0ZXJuJDE7Cgl2YXIgTm90Rm91bmRFeGNlcHRpb25fMSQzID0gTm90Rm91bmRFeGNlcHRpb24kMTsKCS8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki8KCS8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovCgkvKioKCSAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBhbGlnbm1lbnQgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBBbGlnbm1lbnQgcGF0dGVybnMgbG9vayBsaWtlIGZpbmRlcgoJICogcGF0dGVybnMgYnV0IGFyZSBzbWFsbGVyIGFuZCBhcHBlYXIgYXQgcmVndWxhciBpbnRlcnZhbHMgdGhyb3VnaG91dCB0aGUgaW1hZ2UuPC9wPgoJICoKCSAqIDxwPkF0IHRoZSBtb21lbnQgdGhpcyBvbmx5IGxvb2tzIGZvciB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuLjwvcD4KCSAqCgkgKiA8cD5UaGlzIGlzIG1vc3RseSBhIHNpbXBsaWZpZWQgY29weSBvZiB7QGxpbmsgRmluZGVyUGF0dGVybkZpbmRlcn0uIEl0IGlzIGNvcGllZCwKCSAqIHBhc3RlZCBhbmQgc3RyaXBwZWQgZG93biBoZXJlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgZHVwbGljYXRlCgkgKiBzb21lIGNvZGUuPC9wPgoJICoKCSAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuPC9wPgoJICoKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIC8qKgoJICAgICAqIDxwPkNyZWF0ZXMgYSBmaW5kZXIgdGhhdCB3aWxsIGxvb2sgaW4gYSBwb3J0aW9uIG9mIHRoZSB3aG9sZSBpbWFnZS48L3A+CgkgICAgICoKCSAgICAgKiBAcGFyYW0gaW1hZ2UgaW1hZ2UgdG8gc2VhcmNoCgkgICAgICogQHBhcmFtIHN0YXJ0WCBsZWZ0IGNvbHVtbiBmcm9tIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZwoJICAgICAqIEBwYXJhbSBzdGFydFkgdG9wIHJvdyBmcm9tIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZwoJICAgICAqIEBwYXJhbSB3aWR0aCB3aWR0aCBvZiByZWdpb24gdG8gc2VhcmNoCgkgICAgICogQHBhcmFtIGhlaWdodCBoZWlnaHQgb2YgcmVnaW9uIHRvIHNlYXJjaAoJICAgICAqIEBwYXJhbSBtb2R1bGVTaXplIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBzbyBmYXIKCSAgICAgKi8KCSAgICBmdW5jdGlvbiBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyKGltYWdlLCBzdGFydFggLyppbnQqLywgc3RhcnRZIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBtb2R1bGVTaXplIC8qZmxvYXQqLywgcmVzdWx0UG9pbnRDYWxsYmFjaykgewoJICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7CgkgICAgICAgIHRoaXMuc3RhcnRYID0gc3RhcnRYOwoJICAgICAgICB0aGlzLnN0YXJ0WSA9IHN0YXJ0WTsKCSAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoOwoJICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDsKCSAgICAgICAgdGhpcy5tb2R1bGVTaXplID0gbW9kdWxlU2l6ZTsKCSAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjazsKCSAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTsgLy8gbmV3IEFycmF5PGFueT4oNSkpCgkgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBhcnJheSBpbml0aWFsaXphdGlvbiB3aXRob3V0IHNpemUgYXMgdGhlIGxlbmd0aCBpcyBjaGVja2VkIGJlbG93CgkgICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSgzKTsKCSAgICB9CgkgICAgLyoqCgkgICAgICogPHA+VGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZmluZCB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuIGluIHRoZSBpbWFnZS4gSXQgaXMgYSBiaXQgbWVzc3kgc2luY2UKCSAgICAgKiBpdCdzIHByZXR0eSBwZXJmb3JtYW5jZS1jcml0aWNhbCBhbmQgc28gaXMgd3JpdHRlbiB0byBiZSBmYXN0IGZvcmVtb3N0LjwvcD4KCSAgICAgKgoJICAgICAqIEByZXR1cm4ge0BsaW5rIEFsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kCgkgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBub3QgZm91bmQKCSAgICAgKi8KCSAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgc3RhcnRYID0gdGhpcy5zdGFydFg7CgkgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDsKCSAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDsKCSAgICAgICAgdmFyIG1heEogPSBzdGFydFggKyB3aWR0aDsKCSAgICAgICAgdmFyIG1pZGRsZUkgPSB0aGlzLnN0YXJ0WSArIChoZWlnaHQgLyAyKTsKCSAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW4gMToxOjEgcmF0aW8KCSAgICAgICAgLy8gdGhpcyB0cmFja3MgdGhlIG51bWJlciBvZiBibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIHNlZW4gc28gZmFyCgkgICAgICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoMyk7CgkgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7CgkgICAgICAgIGZvciAodmFyIGlHZW4gPSAwOyBpR2VuIDwgaGVpZ2h0OyBpR2VuKyspIHsKCSAgICAgICAgICAgIC8vIFNlYXJjaCBmcm9tIG1pZGRsZSBvdXR3YXJkcwoJICAgICAgICAgICAgdmFyIGkgPSBtaWRkbGVJICsgKChpR2VuICYgMHgwMSkgPT09IDAgPyBNYXRoLmZsb29yKChpR2VuICsgMSkgLyAyKSA6IC1NYXRoLmZsb29yKChpR2VuICsgMSkgLyAyKSk7CgkgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwOwoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7CgkgICAgICAgICAgICB2YXIgaiA9IHN0YXJ0WDsKCSAgICAgICAgICAgIC8vIEJ1cm4gb2ZmIGxlYWRpbmcgd2hpdGUgcGl4ZWxzIGJlZm9yZSBhbnl0aGluZyBlbHNlOyBpZiB3ZSBzdGFydCBpbiB0aGUgbWlkZGxlIG9mCgkgICAgICAgICAgICAvLyBhIHdoaXRlIHJ1biwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGNvdW50IGl0cyBsZW5ndGgsIHNpbmNlIHdlIGRvbid0IGtub3cgaWYgdGhlCgkgICAgICAgICAgICAvLyB3aGl0ZSBydW4gY29udGludWVkIHRvIHRoZSBsZWZ0IG9mIHRoZSBzdGFydCBwb2ludAoJICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5nZXQoaiwgaSkpIHsKCSAgICAgICAgICAgICAgICBqKys7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gMDsKCSAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SikgewoJICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaiwgaSkpIHsKCSAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWwKCSAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMSkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHMKCSAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKzsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzCgkgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAyKSB7IC8vIEEgd2lubmVyPwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7IC8vIFllcwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBqKTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAxOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKzsKCSAgICAgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWwKCSAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMSkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHMKCSAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBqKys7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBpZiAodGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkgewoJICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIG1heEopOwoJICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgIT09IG51bGwpIHsKCSAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgLy8gSG1tLCBub3RoaW5nIHdlIHNhdyB3YXMgb2JzZXJ2ZWQgYW5kIGNvbmZpcm1lZCB0d2ljZS4gSWYgd2UgaGFkCgkgICAgICAgIC8vIGFueSBndWVzcyBhdCBhbGwsIHJldHVybiBpdC4KCSAgICAgICAgaWYgKHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aCAhPT0gMCkgewoJICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVDZW50ZXJzWzBdOwoJICAgICAgICB9CgkgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xJDMuZGVmYXVsdCgpOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogR2l2ZW4gYSBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCBzZWVuIGFuZCBhbiBlbmQgcG9zaXRpb24sCgkgICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIGJsYWNrL3doaXRlL2JsYWNrIHJ1bi4KCSAgICAgKi8KCSAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCwgZW5kIC8qaW50Ki8pIHsKCSAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzJdKSAtIHN0YXRlQ291bnRbMV0gLyAyLjA7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCByZWFkCgkgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8xIHJhdGlvcwoJICAgICAqICAgICAgICAgdXNlZCBieSBhbGlnbm1lbnQgcGF0dGVybnMgdG8gYmUgY29uc2lkZXJlZCBhIG1hdGNoCgkgICAgICovCgkgICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuZm91bmRQYXR0ZXJuQ3Jvc3MgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCkgewoJICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZTsKCSAgICAgICAgdmFyIG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHsKCSAgICAgICAgICAgIGlmIChNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFtpXSkgPj0gbWF4VmFyaWFuY2UpIHsKCSAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRydWU7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBhbGlnbm1lbnQgcGF0dGVybiwgdGhpcyBtZXRob2QKCSAgICAgKiAiY3Jvc3MtY2hlY2tzIiBieSBzY2FubmluZyBkb3duIHZlcnRpY2FsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBwb3NzaWJsZQoJICAgICAqIGFsaWdubWVudCBwYXR0ZXJuIHRvIHNlZSBpZiB0aGUgc2FtZSBwcm9wb3J0aW9uIGlzIGRldGVjdGVkLjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGFuIGFsaWdubWVudCBwYXR0ZXJuIHdhcyBkZXRlY3RlZAoJICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYW4gYWxpZ25tZW50IHBhdHRlcm4KCSAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlCgkgICAgICogb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW4KCSAgICAgKiBAcmV0dXJuIHZlcnRpY2FsIGNlbnRlciBvZiBhbGlnbm1lbnQgcGF0dGVybiwgb3Ige0BsaW5rIEZsb2F0I05hTn0gaWYgbm90IGZvdW5kCgkgICAgICovCgkgICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja1ZlcnRpY2FsID0gZnVuY3Rpb24gKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTsKCSAgICAgICAgdmFyIG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTsKCSAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50OwoJICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDsKCSAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7CgkgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwOwoJICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCBmcm9tIGNlbnRlcgoJICAgICAgICB2YXIgaSA9IHN0YXJ0STsKCSAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrOwoJICAgICAgICAgICAgaS0tOwoJICAgICAgICB9CgkgICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6CgkgICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbMF0rKzsKCSAgICAgICAgICAgIGktLTsKCSAgICAgICAgfQoJICAgICAgICBpZiAoc3RhdGVDb3VudFswXSA+IG1heENvdW50KSB7CgkgICAgICAgICAgICByZXR1cm4gTmFOOwoJICAgICAgICB9CgkgICAgICAgIC8vIE5vdyBhbHNvIGNvdW50IGRvd24gZnJvbSBjZW50ZXIKCSAgICAgICAgaSA9IHN0YXJ0SSArIDE7CgkgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrOwoJICAgICAgICAgICAgaSsrOwoJICAgICAgICB9CgkgICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzJdIDw9IG1heENvdW50KSB7CgkgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7CgkgICAgICAgICAgICBpKys7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHN0YXRlQ291bnRbMl0gPiBtYXhDb3VudCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdOwoJICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaSkgOiBOYU47CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiA8cD5UaGlzIGlzIGNhbGxlZCB3aGVuIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG9zc2libGUgYWxpZ25tZW50IHBhdHRlcm4uIEl0IHdpbGwKCSAgICAgKiBjcm9zcyBjaGVjayB3aXRoIGEgdmVydGljYWwgc2NhbiwgYW5kIGlmIHN1Y2Nlc3NmdWwsIHdpbGwgc2VlIGlmIHRoaXMgcGF0dGVybiBoYWQgYmVlbgoJICAgICAqIGZvdW5kIG9uIGEgcHJldmlvdXMgaG9yaXpvbnRhbCBzY2FuLiBJZiBzbywgd2UgY29uc2lkZXIgaXQgY29uZmlybWVkIGFuZCBjb25jbHVkZSB3ZSBoYXZlCgkgICAgICogZm91bmQgdGhlIGFsaWdubWVudCBwYXR0ZXJuLjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IHJlYWRpbmcgc3RhdGUgbW9kdWxlIGNvdW50cyBmcm9tIGhvcml6b250YWwgc2NhbgoJICAgICAqIEBwYXJhbSBpIHJvdyB3aGVyZSBhbGlnbm1lbnQgcGF0dGVybiBtYXkgYmUgZm91bmQKCSAgICAgKiBAcGFyYW0gaiBlbmQgb2YgcG9zc2libGUgYWxpZ25tZW50IHBhdHRlcm4gaW4gcm93CgkgICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgd2UgaGF2ZSBmb3VuZCB0aGUgc2FtZSBwYXR0ZXJuIHR3aWNlLCBvciBudWxsIGlmIG5vdAoJICAgICAqLwoJICAgIEFsaWdubWVudFBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmhhbmRsZVBvc3NpYmxlQ2VudGVyID0gZnVuY3Rpb24gKHN0YXRlQ291bnQsIGkgLyppbnQqLywgaiAvKmludCovKSB7CgkgICAgICAgIHZhciBlXzEsIF9hOwoJICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdOwoJICAgICAgICB2YXIgY2VudGVySiA9IEFsaWdubWVudFBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKTsKCSAgICAgICAgdmFyIGNlbnRlckkgPSB0aGlzLmNyb3NzQ2hlY2tWZXJ0aWNhbChpLCAvKihpbnQpICovIGNlbnRlckosIDIgKiBzdGF0ZUNvdW50WzFdLCBzdGF0ZUNvdW50VG90YWwpOwoJICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckkpKSB7CgkgICAgICAgICAgICB2YXIgZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IChzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0pIC8gMy4wOwoJICAgICAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzJDEodGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBfYy52YWx1ZTsKCSAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZToKCSAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlci5jb21iaW5lRXN0aW1hdGUoY2VudGVySSwgY2VudGVySiwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfQoJICAgICAgICAgICAgZmluYWxseSB7CgkgICAgICAgICAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICAvLyBIYWRuJ3QgZm91bmQgdGhpcyBiZWZvcmU7IHNhdmUgaXQKCSAgICAgICAgICAgIHZhciBwb2ludCA9IG5ldyBBbGlnbm1lbnRQYXR0ZXJuXzEuZGVmYXVsdChjZW50ZXJKLCBjZW50ZXJJLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTsKCSAgICAgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzLnB1c2gocG9pbnQpOwoJICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkgewoJICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBudWxsOwoJICAgIH07CgkgICAgcmV0dXJuIEFsaWdubWVudFBhdHRlcm5GaW5kZXI7Cgl9KCkpOwoJQWxpZ25tZW50UGF0dGVybkZpbmRlciQxLmRlZmF1bHQgPSBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyOwoKCXZhciBGaW5kZXJQYXR0ZXJuRmluZGVyJDEgPSB7fTsKCgl2YXIgRmluZGVyUGF0dGVybiQxID0ge307CgoJLyoKCSAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnMKCSAqCgkgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKCSAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KCSAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoJICoKCSAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgkgKgoJICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZQoJICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gIkFTIElTIiBCQVNJUywKCSAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgoJICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZAoJICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCgkgKi8KCXZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkgewoJICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHsKCSAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAoJICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fAoJICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07CgkgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpOwoJICAgIH07CgkgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7CgkgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7CgkgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfQoJICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7CgkgICAgfTsKCX0pKCk7CglPYmplY3QuZGVmaW5lUHJvcGVydHkoRmluZGVyUGF0dGVybiQxLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CgkvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki8KCXZhciBSZXN1bHRQb2ludF8xJDIgPSBSZXN1bHRQb2ludCQxOwoJLyoqCgkgKiA8cD5FbmNhcHN1bGF0ZXMgYSBmaW5kZXIgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSB0aHJlZSBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW4KCSAqIHRoZSBjb3JuZXJzIG9mIFFSIENvZGVzLiBJdCBhbHNvIGVuY2Fwc3VsYXRlcyBhIGNvdW50IG9mIHNpbWlsYXIgZmluZGVyIHBhdHRlcm5zLAoJICogYXMgYSBjb252ZW5pZW5jZSB0byB0aGUgZmluZGVyJ3MgYm9va2tlZXBpbmcuPC9wPgoJICoKCSAqIEBhdXRob3IgU2VhbiBPd2VuCgkgKi8KCXZhciBGaW5kZXJQYXR0ZXJuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikgewoJICAgIF9fZXh0ZW5kcyhGaW5kZXJQYXR0ZXJuLCBfc3VwZXIpOwoJICAgIC8vIEZpbmRlclBhdHRlcm4ocG9zWDogbnVtYmVyLypmbG9hdCovLCBwb3NZOiBudW1iZXIvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemU6IG51bWJlci8qZmxvYXQqLykgewoJICAgIC8vICAgdGhpcyhwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplLCAxKQoJICAgIC8vIH0KCSAgICBmdW5jdGlvbiBGaW5kZXJQYXR0ZXJuKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGNvdW50IC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcG9zWCwgcG9zWSkgfHwgdGhpczsKCSAgICAgICAgX3RoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7CgkgICAgICAgIF90aGlzLmNvdW50ID0gY291bnQ7CgkgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7CgkgICAgICAgICAgICBfdGhpcy5jb3VudCA9IDE7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIF90aGlzOwoJICAgIH0KCSAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplOwoJICAgIH07CgkgICAgRmluZGVyUGF0dGVybi5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmNvdW50OwoJICAgIH07CgkgICAgLyoKCSAgICB2b2lkIGluY3JlbWVudENvdW50KCkgewoJICAgICAgdGhpcy5jb3VudCsrCgkgICAgfQoJICAgICAqLwoJICAgIC8qKgoJICAgICAqIDxwPkRldGVybWluZXMgaWYgdGhpcyBmaW5kZXIgcGF0dGVybiAiYWJvdXQgZXF1YWxzIiBhIGZpbmRlciBwYXR0ZXJuIGF0IHRoZSBzdGF0ZWQKCSAgICAgKiBwb3NpdGlvbiBhbmQgc2l6ZSAtLSBtZWFuaW5nLCBpdCBpcyBhdCBuZWFybHkgdGhlIHNhbWUgY2VudGVyIHdpdGggbmVhcmx5IHRoZSBzYW1lIHNpemUuPC9wPgoJICAgICAqLwoJICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmFib3V0RXF1YWxzID0gZnVuY3Rpb24gKG1vZHVsZVNpemUgLypmbG9hdCovLCBpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8pIHsKCSAgICAgICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLmdldFkoKSkgPD0gbW9kdWxlU2l6ZSAmJiBNYXRoLmFicyhqIC0gdGhpcy5nZXRYKCkpIDw9IG1vZHVsZVNpemUpIHsKCSAgICAgICAgICAgIHZhciBtb2R1bGVTaXplRGlmZiA9IE1hdGguYWJzKG1vZHVsZVNpemUgLSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUpOwoJICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kIG1vZHVsZSBzaXplCgkgICAgICogd2l0aCBhIG5ldyBlc3RpbWF0ZS4gSXQgcmV0dXJucyBhIG5ldyB7QGNvZGUgRmluZGVyUGF0dGVybn0gY29udGFpbmluZyBhIHdlaWdodGVkIGF2ZXJhZ2UKCSAgICAgKiBiYXNlZCBvbiBjb3VudC4KCSAgICAgKi8KCSAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5jb21iaW5lRXN0aW1hdGUgPSBmdW5jdGlvbiAoaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovLCBuZXdNb2R1bGVTaXplIC8qZmxvYXQqLykgewoJICAgICAgICB2YXIgY29tYmluZWRDb3VudCA9IHRoaXMuY291bnQgKyAxOwoJICAgICAgICB2YXIgY29tYmluZWRYID0gKHRoaXMuY291bnQgKiB0aGlzLmdldFgoKSArIGopIC8gY29tYmluZWRDb3VudDsKCSAgICAgICAgdmFyIGNvbWJpbmVkWSA9ICh0aGlzLmNvdW50ICogdGhpcy5nZXRZKCkgKyBpKSAvIGNvbWJpbmVkQ291bnQ7CgkgICAgICAgIHZhciBjb21iaW5lZE1vZHVsZVNpemUgPSAodGhpcy5jb3VudCAqIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSArIG5ld01vZHVsZVNpemUpIC8gY29tYmluZWRDb3VudDsKCSAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuKGNvbWJpbmVkWCwgY29tYmluZWRZLCBjb21iaW5lZE1vZHVsZVNpemUsIGNvbWJpbmVkQ291bnQpOwoJICAgIH07CgkgICAgcmV0dXJuIEZpbmRlclBhdHRlcm47Cgl9KFJlc3VsdFBvaW50XzEkMi5kZWZhdWx0KSk7CglGaW5kZXJQYXR0ZXJuJDEuZGVmYXVsdCA9IEZpbmRlclBhdHRlcm47CgoJdmFyIEZpbmRlclBhdHRlcm5JbmZvJDEgPSB7fTsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpbmRlclBhdHRlcm5JbmZvJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qKgoJICogPHA+RW5jYXBzdWxhdGVzIGluZm9ybWF0aW9uIGFib3V0IGZpbmRlciBwYXR0ZXJucyBpbiBhbiBpbWFnZSwgaW5jbHVkaW5nIHRoZSBsb2NhdGlvbiBvZgoJICogdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJucywgYW5kIHRoZWlyIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEZpbmRlclBhdHRlcm5JbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIEZpbmRlclBhdHRlcm5JbmZvKHBhdHRlcm5DZW50ZXJzKSB7CgkgICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IHBhdHRlcm5DZW50ZXJzWzBdOwoJICAgICAgICB0aGlzLnRvcExlZnQgPSBwYXR0ZXJuQ2VudGVyc1sxXTsKCSAgICAgICAgdGhpcy50b3BSaWdodCA9IHBhdHRlcm5DZW50ZXJzWzJdOwoJICAgIH0KCSAgICBGaW5kZXJQYXR0ZXJuSW5mby5wcm90b3R5cGUuZ2V0Qm90dG9tTGVmdCA9IGZ1bmN0aW9uICgpIHsKCSAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tTGVmdDsKCSAgICB9OwoJICAgIEZpbmRlclBhdHRlcm5JbmZvLnByb3RvdHlwZS5nZXRUb3BMZWZ0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy50b3BMZWZ0OwoJICAgIH07CgkgICAgRmluZGVyUGF0dGVybkluZm8ucHJvdG90eXBlLmdldFRvcFJpZ2h0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy50b3BSaWdodDsKCSAgICB9OwoJICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuSW5mbzsKCX0oKSk7CglGaW5kZXJQYXR0ZXJuSW5mbyQxLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuSW5mbzsKCgkvKgoJICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9ycwoJICoKCSAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwoJICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgoJICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgkgKgoJICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCSAqCgkgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCgkgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAoJICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCgkgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCgkgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KCSAqLwoJdmFyIF9fdmFsdWVzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7CgkgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7CgkgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7CgkgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSAibnVtYmVyIikgcmV0dXJuIHsKCSAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkgewoJICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDsKCSAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTsKCSAgICAgICAgfQoJICAgIH07CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gIk9iamVjdCBpcyBub3QgaXRlcmFibGUuIiA6ICJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuIik7Cgl9OwoJT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpbmRlclBhdHRlcm5GaW5kZXIkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGV0ZWN0b3IgeyovCgl2YXIgRGVjb2RlSGludFR5cGVfMSQyID0gRGVjb2RlSGludFR5cGUkMTsKCXZhciBSZXN1bHRQb2ludF8xJDEgPSBSZXN1bHRQb2ludCQxOwoJdmFyIEZpbmRlclBhdHRlcm5fMSA9IEZpbmRlclBhdHRlcm4kMTsKCXZhciBGaW5kZXJQYXR0ZXJuSW5mb18xID0gRmluZGVyUGF0dGVybkluZm8kMTsKCXZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xJDIgPSBOb3RGb3VuZEV4Y2VwdGlvbiQxOwoJLyppbXBvcnQgamF2YS5pby5TZXJpYWxpemFibGU7Ki8KCS8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki8KCS8qaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uczsqLwoJLyppbXBvcnQgamF2YS51dGlsLkNvbXBhcmF0b3I7Ki8KCS8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovCgkvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovCgkvKioKCSAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBmaW5kZXIgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBGaW5kZXIgcGF0dGVybnMgYXJlIHRoZSBzcXVhcmUKCSAqIG1hcmtlcnMgYXQgdGhyZWUgY29ybmVycyBvZiBhIFFSIENvZGUuPC9wPgoJICoKCSAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuCgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIEZpbmRlclBhdHRlcm5GaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7CgkgICAgLyoqCgkgICAgICogPHA+Q3JlYXRlcyBhIGZpbmRlciB0aGF0IHdpbGwgc2VhcmNoIHRoZSBpbWFnZSBmb3IgdGhyZWUgZmluZGVyIHBhdHRlcm5zLjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSB0byBzZWFyY2gKCSAgICAgKi8KCSAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoaW1hZ2U6IEJpdE1hdHJpeCkgewoJICAgIC8vICAgdGhpcyhpbWFnZSwgbnVsbCkKCSAgICAvLyB9CgkgICAgZnVuY3Rpb24gRmluZGVyUGF0dGVybkZpbmRlcihpbWFnZSwgcmVzdWx0UG9pbnRDYWxsYmFjaykgewoJICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7CgkgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7CgkgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzID0gW107CgkgICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSg1KTsKCSAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjazsKCSAgICB9CgkgICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmltYWdlOwoJICAgIH07CgkgICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZ2V0UG9zc2libGVDZW50ZXJzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnM7CgkgICAgfTsKCSAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGhpbnRzKSB7CgkgICAgICAgIHZhciB0cnlIYXJkZXIgPSAoaGludHMgIT09IG51bGwgJiYgaGludHMgIT09IHVuZGVmaW5lZCkgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMSQyLmRlZmF1bHQuVFJZX0hBUkRFUik7CgkgICAgICAgIHZhciBwdXJlQmFyY29kZSA9IChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkKSAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xJDIuZGVmYXVsdC5QVVJFX0JBUkNPREUpOwoJICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlOwoJICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpOwoJICAgICAgICB2YXIgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7CgkgICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluCgkgICAgICAgIC8vIDE6MTozOjE6MSByYXRpbzsgdGhpcyB0cmFja3MgdGhlIG51bWJlciBvZiBzdWNoIG1vZHVsZXMgc2VlbiBzbyBmYXIKCSAgICAgICAgLy8gTGV0J3MgYXNzdW1lIHRoYXQgdGhlIG1heGltdW0gdmVyc2lvbiBRUiBDb2RlIHdlIHN1cHBvcnQgdGFrZXMgdXAgMS80IHRoZSBoZWlnaHQgb2YgdGhlCgkgICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiBhY2NvdW50IGZvciB0aGUgY2VudGVyIGJlaW5nIDMgbW9kdWxlcyBpbiBzaXplLiBUaGlzIGdpdmVzIHRoZSBzbWFsbGVzdAoJICAgICAgICAvLyBudW1iZXIgb2YgcGl4ZWxzIHRoZSBjZW50ZXIgY291bGQgYmUsIHNvIHNraXAgdGhpcyBvZnRlbi4gV2hlbiB0cnlpbmcgaGFyZGVyLCBsb29rIGZvciBhbGwKCSAgICAgICAgLy8gUVIgdmVyc2lvbnMgcmVnYXJkbGVzcyBvZiBob3cgZGVuc2UgdGhleSBhcmUuCgkgICAgICAgIHZhciBpU2tpcCA9IE1hdGguZmxvb3IoKDMgKiBtYXhJKSAvICg0ICogRmluZGVyUGF0dGVybkZpbmRlci5NQVhfTU9EVUxFUykpOwoJICAgICAgICBpZiAoaVNraXAgPCBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQIHx8IHRyeUhhcmRlcikgewoJICAgICAgICAgICAgaVNraXAgPSBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQOwoJICAgICAgICB9CgkgICAgICAgIHZhciBkb25lID0gZmFsc2U7CgkgICAgICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoNSk7CgkgICAgICAgIGZvciAodmFyIGkgPSBpU2tpcCAtIDE7IGkgPCBtYXhJICYmICFkb25lOyBpICs9IGlTa2lwKSB7CgkgICAgICAgICAgICAvLyBHZXQgYSByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzCgkgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwOwoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7CgkgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwOwoJICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IDA7CgkgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heEo7IGorKykgewoJICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaiwgaSkpIHsKCSAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWwKCSAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMSkgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHMKCSAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWwKCSAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMCkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHMKCSAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDQpIHsgLy8gQSB3aW5uZXI/CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGosIHB1cmVCYXJjb2RlKTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkgewoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZXhhbWluaW5nIGV2ZXJ5IG90aGVyIGxpbmUuIENoZWNraW5nIGVhY2ggbGluZSB0dXJuZWQgb3V0IHRvIGJlIHRvbwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIGFuZCBkaWRuJ3QgaW1wcm92ZSBwZXJmb3JtYW5jZS4KCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlTa2lwID0gMjsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQgPT09IHRydWUpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93U2tpcCA9IHRoaXMuZmluZFJvd1NraXAoKTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93U2tpcCA+IHN0YXRlQ291bnRbMl0pIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJldHdlZW4gcm93IG9mIGxvd2VyIGNvbmZpcm1lZCBjZW50ZXIKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRvcCBvZiBwcmVzdW1lZCB0aGlyZCBjb25maXJtZWQgY2VudGVyCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBiYWNrIHVwIGEgYml0IHRvIGdldCBhIGZ1bGwgY2hhbmNlIG9mIGRldGVjdGluZwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCwgZW50aXJlIHdpZHRoIG9mIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVybgoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJ5IHJvd1NraXAsIGJ1dCBiYWNrIG9mZiBieSBzdGF0ZUNvdW50WzJdIChzaXplIG9mIGxhc3QgY2VudGVyCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHBhdHRlcm4gd2Ugc2F3KSB0byBiZSBjb25zZXJ2YXRpdmUsIGFuZCBhbHNvIGJhY2sgb2ZmIGJ5IGlTa2lwIHdoaWNoCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGFib3V0IHRvIGJlIHJlLWFkZGVkCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcm93U2tpcCAtIHN0YXRlQ291bnRbMl0gLSBpU2tpcDsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IG1heEogLSAxOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IHN0YXRlQ291bnRbM107CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gc3RhdGVDb3VudFs0XTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAzOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgc3RhdGUgdG8gc3RhcnQgbG9va2luZyBhZ2FpbgoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAwOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBObywgc2hpZnQgY291bnRzIGJhY2sgYnkgdHdvCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07CgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxOwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMzsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WysrY3VycmVudFN0YXRlXSsrOwoJICAgICAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHMKCSAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgaWYgKEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsKCSAgICAgICAgICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKLCBwdXJlQmFyY29kZSk7CgkgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkgewoJICAgICAgICAgICAgICAgICAgICBpU2tpcCA9IHN0YXRlQ291bnRbMF07CgkgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgdGhpcmQgb25lCgkgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHBhdHRlcm5JbmZvID0gdGhpcy5zZWxlY3RCZXN0UGF0dGVybnMoKTsKCSAgICAgICAgUmVzdWx0UG9pbnRfMSQxLmRlZmF1bHQub3JkZXJCZXN0UGF0dGVybnMocGF0dGVybkluZm8pOwoJICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm5JbmZvXzEuZGVmYXVsdChwYXR0ZXJuSW5mbyk7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBHaXZlbiBhIGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHNlZW4gYW5kIGFuIGVuZCBwb3NpdGlvbiwKCSAgICAgKiBmaWd1cmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoaXMgcnVuLgoJICAgICAqLwoJICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZCA9IGZ1bmN0aW9uIChzdGF0ZUNvdW50LCBlbmQgLyppbnQqLykgewoJICAgICAgICByZXR1cm4gKGVuZCAtIHN0YXRlQ291bnRbNF0gLSBzdGF0ZUNvdW50WzNdKSAtIHN0YXRlQ291bnRbMl0gLyAyLjA7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCByZWFkCgkgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8zLzEvMSByYXRpb3MKCSAgICAgKiAgICAgICAgIHVzZWQgYnkgZmluZGVyIHBhdHRlcm5zIHRvIGJlIGNvbnNpZGVyZWQgYSBtYXRjaAoJICAgICAqLwoJICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3MgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCkgewoJICAgICAgICB2YXIgdG90YWxNb2R1bGVTaXplID0gMDsKCSAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHsKCSAgICAgICAgICAgIHZhciBjb3VudCA9IHN0YXRlQ291bnRbaV07CgkgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHsKCSAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gY291bnQ7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHRvdGFsTW9kdWxlU2l6ZSA8IDcpIHsKCSAgICAgICAgICAgIHJldHVybiBmYWxzZTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIDcuMDsKCSAgICAgICAgdmFyIG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDsKCSAgICAgICAgLy8gQWxsb3cgbGVzcyB0aGFuIDUwJSB2YXJpYW5jZSBmcm9tIDEtMS0zLTEtMSBwcm9wb3J0aW9ucwoJICAgICAgICByZXR1cm4gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMF0pIDwgbWF4VmFyaWFuY2UgJiYKCSAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzFdKSA8IG1heFZhcmlhbmNlICYmCgkgICAgICAgICAgICBNYXRoLmFicygzLjAgKiBtb2R1bGVTaXplIC0gc3RhdGVDb3VudFsyXSkgPCAzICogbWF4VmFyaWFuY2UgJiYKCSAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzNdKSA8IG1heFZhcmlhbmNlICYmCgkgICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFs0XSkgPCBtYXhWYXJpYW5jZTsKCSAgICB9OwoJICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgY3Jvc3NDaGVja1N0YXRlQ291bnQgPSB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50OwoJICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFswXSA9IDA7CgkgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzFdID0gMDsKCSAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbMl0gPSAwOwoJICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFszXSA9IDA7CgkgICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzRdID0gMDsKCSAgICAgICAgcmV0dXJuIGNyb3NzQ2hlY2tTdGF0ZUNvdW50OwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQWZ0ZXIgYSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZAoJICAgICAqICJjcm9zcy1jcm9zcy1jcm9zcy1jaGVja3MiIGJ5IHNjYW5uaW5nIGRvd24gZGlhZ29uYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlCgkgICAgICogZmluZGVyIHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuCgkgICAgICoKCSAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZAoJICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVybgoJICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmUKCSAgICAgKiAgb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW4KCSAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgVGhlIG9yaWdpbmFsIHN0YXRlIGNvdW50IHRvdGFsLgoJICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9wb3J0aW9ucyBhcmUgd2l0aGluZyBleHBlY3RlZCBsaW1pdHMKCSAgICAgKi8KCSAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrRGlhZ29uYWwgPSBmdW5jdGlvbiAoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykgewoJICAgICAgICB2YXIgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTsKCSAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAsIGxlZnQgZnJvbSBjZW50ZXIgZmluZGluZyBibGFjayBjZW50ZXIgbWFzcwoJICAgICAgICB2YXIgaSA9IDA7CgkgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7CgkgICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrOwoJICAgICAgICAgICAgaSsrOwoJICAgICAgICB9CgkgICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpKSB7CgkgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgIH0KCSAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyB3aGl0ZSBzcGFjZQoJICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmICFpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmCgkgICAgICAgICAgICBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7CgkgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7CgkgICAgICAgICAgICBpKys7CgkgICAgICAgIH0KCSAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZToKCSAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7CgkgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgIH0KCSAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyBibGFjayBib3JkZXIKCSAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiBpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmCgkgICAgICAgICAgICBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7CgkgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7CgkgICAgICAgICAgICBpKys7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIHZhciBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7CgkgICAgICAgIHZhciBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biwgcmlnaHQgZnJvbSBjZW50ZXIKCSAgICAgICAgaSA9IDE7CgkgICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgaW1hZ2UuZ2V0KGNlbnRlckogKyBpLCBzdGFydEkgKyBpKSkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrOwoJICAgICAgICAgICAgaSsrOwoJICAgICAgICB9CgkgICAgICAgIC8vIFJhbiBvZmYgdGhlIGVkZ2U/CgkgICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4SikgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgIWltYWdlLmdldChjZW50ZXJKICsgaSwgc3RhcnRJICsgaSkgJiYKCSAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrOwoJICAgICAgICAgICAgaSsrOwoJICAgICAgICB9CgkgICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7CgkgICAgICAgICAgICByZXR1cm4gZmFsc2U7CgkgICAgICAgIH0KCSAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmCgkgICAgICAgICAgICBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKzsKCSAgICAgICAgICAgIGkrKzsKCSAgICAgICAgfQoJICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuIDEwMCUgZGlmZmVyZW50IHRoYW4KCSAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlCgkgICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsgc3RhdGVDb3VudFs0XTsKCSAgICAgICAgcmV0dXJuIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA8IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAmJgoJICAgICAgICAgICAgRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPkFmdGVyIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZAoJICAgICAqICJjcm9zcy1jaGVja3MiIGJ5IHNjYW5uaW5nIGRvd24gdmVydGljYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlCgkgICAgICogZmluZGVyIHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIHN0YXJ0SSByb3cgd2hlcmUgYSBmaW5kZXIgcGF0dGVybiB3YXMgZGV0ZWN0ZWQKCSAgICAgKiBAcGFyYW0gY2VudGVySiBjZW50ZXIgb2YgdGhlIHNlY3Rpb24gdGhhdCBhcHBlYXJzIHRvIGNyb3NzIGEgZmluZGVyIHBhdHRlcm4KCSAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlCgkgICAgICogb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW4KCSAgICAgKiBAcmV0dXJuIHZlcnRpY2FsIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVybiwgb3Ige0BsaW5rIEZsb2F0I05hTn0gaWYgbm90IGZvdW5kCgkgICAgICovCgkgICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja1ZlcnRpY2FsID0gZnVuY3Rpb24gKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTsKCSAgICAgICAgdmFyIG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTsKCSAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7CgkgICAgICAgIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyCgkgICAgICAgIHZhciBpID0gc3RhcnRJOwoJICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrOwoJICAgICAgICAgICAgaS0tOwoJICAgICAgICB9CgkgICAgICAgIGlmIChpIDwgMCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICB3aGlsZSAoaSA+PSAwICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrOwoJICAgICAgICAgICAgaS0tOwoJICAgICAgICB9CgkgICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6CgkgICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrOwoJICAgICAgICAgICAgaS0tOwoJICAgICAgICB9CgkgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biBmcm9tIGNlbnRlcgoJICAgICAgICBpID0gc3RhcnRJICsgMTsKCSAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrOwoJICAgICAgICAgICAgaSsrOwoJICAgICAgICB9CgkgICAgICAgIGlmIChpID09PSBtYXhJKSB7CgkgICAgICAgICAgICByZXR1cm4gTmFOOwoJICAgICAgICB9CgkgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrOwoJICAgICAgICAgICAgaSsrOwoJICAgICAgICB9CgkgICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKzsKCSAgICAgICAgICAgIGkrKzsKCSAgICAgICAgfQoJICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIG1vcmUgdGhhbiA0MCUgZGlmZmVyZW50IHRoYW4KCSAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlCgkgICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbNF07CgkgICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPkxpa2Uge0BsaW5rICNjcm9zc0NoZWNrVmVydGljYWwoaW50LCBpbnQsIGludCwgaW50KX0sIGFuZCBpbiBmYWN0IGlzIGJhc2ljYWxseSBpZGVudGljYWwsCgkgICAgICogZXhjZXB0IGl0IHJlYWRzIGhvcml6b250YWxseSBpbnN0ZWFkIG9mIHZlcnRpY2FsbHkuIFRoaXMgaXMgdXNlZCB0byBjcm9zcy1jcm9zcwoJICAgICAqIGNoZWNrIGEgdmVydGljYWwgY3Jvc3MgY2hlY2sgYW5kIGxvY2F0ZSB0aGUgcmVhbCBjZW50ZXIgb2YgdGhlIGFsaWdubWVudCBwYXR0ZXJuLjwvcD4KCSAgICAgKi8KCSAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChzdGFydEogLyppbnQqLywgY2VudGVySSAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7CgkgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7CgkgICAgICAgIHZhciBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7CgkgICAgICAgIHZhciBqID0gc3RhcnRKOwoJICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrOwoJICAgICAgICAgICAgai0tOwoJICAgICAgICB9CgkgICAgICAgIGlmIChqIDwgMCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICB3aGlsZSAoaiA+PSAwICYmICFpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrOwoJICAgICAgICAgICAgai0tOwoJICAgICAgICB9CgkgICAgICAgIGlmIChqIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgd2hpbGUgKGogPj0gMCAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkgewoJICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrOwoJICAgICAgICAgICAgai0tOwoJICAgICAgICB9CgkgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgaiA9IHN0YXJ0SiArIDE7CgkgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkpIHsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKzsKCSAgICAgICAgICAgIGorKzsKCSAgICAgICAgfQoJICAgICAgICBpZiAoaiA9PT0gbWF4SikgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzNdIDwgbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHN0YXRlQ291bnRbM10rKzsKCSAgICAgICAgICAgIGorKzsKCSAgICAgICAgfQoJICAgICAgICBpZiAoaiA9PT0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7CgkgICAgICAgICAgICByZXR1cm4gTmFOOwoJICAgICAgICB9CgkgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7CgkgICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7CgkgICAgICAgICAgICBqKys7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHsKCSAgICAgICAgICAgIHJldHVybiBOYU47CgkgICAgICAgIH0KCSAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBzaWduaWZpY2FudGx5IGRpZmZlcmVudCB0aGFuCgkgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZQoJICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArCgkgICAgICAgICAgICBzdGF0ZUNvdW50WzRdOwoJICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgewoJICAgICAgICAgICAgcmV0dXJuIE5hTjsKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKSA6IE5hTjsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbAoJICAgICAqIGNyb3NzIGNoZWNrIHdpdGggYSB2ZXJ0aWNhbCBzY2FuLCBhbmQgaWYgc3VjY2Vzc2Z1bCwgd2lsbCwgYWgsIGNyb3NzLWNyb3NzLWNoZWNrCgkgICAgICogd2l0aCBhbm90aGVyIGhvcml6b250YWwgc2Nhbi4gVGhpcyBpcyBuZWVkZWQgcHJpbWFyaWx5IHRvIGxvY2F0ZSB0aGUgcmVhbCBob3Jpem9udGFsCgkgICAgICogY2VudGVyIG9mIHRoZSBwYXR0ZXJuIGluIGNhc2VzIG9mIGV4dHJlbWUgc2tldy4KCSAgICAgKiBBbmQgdGhlbiB3ZSBjcm9zcy1jcm9zcy1jcm9zcyBjaGVjayB3aXRoIGFub3RoZXIgZGlhZ29uYWwgc2Nhbi48L3A+CgkgICAgICoKCSAgICAgKiA8cD5JZiB0aGF0IHN1Y2NlZWRzIHRoZSBmaW5kZXIgcGF0dGVybiBsb2NhdGlvbiBpcyBhZGRlZCB0byBhIGxpc3QgdGhhdCB0cmFja3MKCSAgICAgKiB0aGUgbnVtYmVyIG9mIHRpbWVzIGVhY2ggbG9jYXRpb24gaGFzIGJlZW4gbmVhcmx5LW1hdGNoZWQgYXMgYSBmaW5kZXIgcGF0dGVybi4KCSAgICAgKiBFYWNoIGFkZGl0aW9uYWwgZmluZCBpcyBtb3JlIGV2aWRlbmNlIHRoYXQgdGhlIGxvY2F0aW9uIGlzIGluIGZhY3QgYSBmaW5kZXIKCSAgICAgKiBwYXR0ZXJuIGNlbnRlcgoJICAgICAqCgkgICAgICogQHBhcmFtIHN0YXRlQ291bnQgcmVhZGluZyBzdGF0ZSBtb2R1bGUgY291bnRzIGZyb20gaG9yaXpvbnRhbCBzY2FuCgkgICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGZpbmRlciBwYXR0ZXJuIG1heSBiZSBmb3VuZAoJICAgICAqIEBwYXJhbSBqIGVuZCBvZiBwb3NzaWJsZSBmaW5kZXIgcGF0dGVybiBpbiByb3cKCSAgICAgKiBAcGFyYW0gcHVyZUJhcmNvZGUgdHJ1ZSBpZiBpbiAicHVyZSBiYXJjb2RlIiBtb2RlCgkgICAgICogQHJldHVybiB0cnVlIGlmIGEgZmluZGVyIHBhdHRlcm4gY2FuZGlkYXRlIHdhcyBmb3VuZCB0aGlzIHRpbWUKCSAgICAgKi8KCSAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5oYW5kbGVQb3NzaWJsZUNlbnRlciA9IGZ1bmN0aW9uIChzdGF0ZUNvdW50LCBpIC8qaW50Ki8sIGogLyppbnQqLywgcHVyZUJhcmNvZGUpIHsKCSAgICAgICAgdmFyIHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gKwoJICAgICAgICAgICAgc3RhdGVDb3VudFs0XTsKCSAgICAgICAgdmFyIGNlbnRlckogPSBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7CgkgICAgICAgIHZhciBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpOwoJICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckkpKSB7CgkgICAgICAgICAgICAvLyBSZS1jcm9zcyBjaGVjawoJICAgICAgICAgICAgY2VudGVySiA9IHRoaXMuY3Jvc3NDaGVja0hvcml6b250YWwoLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCk7CgkgICAgICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckopICYmCgkgICAgICAgICAgICAgICAgKCFwdXJlQmFyY29kZSB8fCB0aGlzLmNyb3NzQ2hlY2tEaWFnb25hbCgvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKSkpIHsKCSAgICAgICAgICAgICAgICB2YXIgZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IHN0YXRlQ291bnRUb3RhbCAvIDcuMDsKCSAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTsKCSAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVDZW50ZXJzID0gdGhpcy5wb3NzaWJsZUNlbnRlcnM7CgkgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGhfMSA9IHBvc3NpYmxlQ2VudGVycy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoXzE7IGluZGV4KyspIHsKCSAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHBvc3NpYmxlQ2VudGVyc1tpbmRleF07CgkgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFib3V0IHRoZSBzYW1lIGNlbnRlciBhbmQgbW9kdWxlIHNpemU6CgkgICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuYWJvdXRFcXVhbHMoZXN0aW1hdGVkTW9kdWxlU2l6ZSwgY2VudGVySSwgY2VudGVySikpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1tpbmRleF0gPSBjZW50ZXIuY29tYmluZUVzdGltYXRlKGNlbnRlckksIGNlbnRlckosIGVzdGltYXRlZE1vZHVsZVNpemUpOwoJICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlOwoJICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkgewoJICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgRmluZGVyUGF0dGVybl8xLmRlZmF1bHQoY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7CgkgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTsKCSAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogQHJldHVybiBudW1iZXIgb2Ygcm93cyB3ZSBjb3VsZCBzYWZlbHkgc2tpcCBkdXJpbmcgc2Nhbm5pbmcsIGJhc2VkIG9uIHRoZSBmaXJzdAoJICAgICAqICAgICAgICAgdHdvIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBsb2NhdGVkLiBJbiBzb21lIGNhc2VzIHRoZWlyIHBvc2l0aW9uIHdpbGwKCSAgICAgKiAgICAgICAgIGFsbG93IHVzIHRvIGluZmVyIHRoYXQgdGhlIHRoaXJkIHBhdHRlcm4gbXVzdCBsaWUgYmVsb3cgYSBjZXJ0YWluIHBvaW50IGZhcnRoZXIKCSAgICAgKiAgICAgICAgIGRvd24gaW4gdGhlIGltYWdlLgoJICAgICAqLwoJICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZpbmRSb3dTa2lwID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgZV8xLCBfYTsKCSAgICAgICAgdmFyIG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDsKCSAgICAgICAgaWYgKG1heCA8PSAxKSB7CgkgICAgICAgICAgICByZXR1cm4gMDsKCSAgICAgICAgfQoJICAgICAgICB2YXIgZmlyc3RDb25maXJtZWRDZW50ZXIgPSBudWxsOwoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlQ2VudGVycyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHsKCSAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gX2MudmFsdWU7CgkgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkgewoJICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb25maXJtZWRDZW50ZXIgPT0gbnVsbCkgewoJICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RDb25maXJtZWRDZW50ZXIgPSBjZW50ZXI7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHR3byBjb25maXJtZWQgY2VudGVycwoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93IGZhciBkb3duIGNhbiB3ZSBza2lwIGJlZm9yZSByZXN1bWluZyBsb29raW5nIGZvciB0aGUgbmV4dAoJICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF0dGVybj8gSW4gdGhlIHdvcnN0IGNhc2UsIG9ubHkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUKCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gdGhlIHggLyB5IGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY2VudGVycy4KCSAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgeW91IGZpbmQgdG9wIGxlZnQgbGFzdC4KCSAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzU2tpcHBlZCA9IHRydWU7CgkgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyooaW50KSAqLyBNYXRoLmZsb29yKChNYXRoLmFicyhmaXJzdENvbmZpcm1lZENlbnRlci5nZXRYKCkgLSBjZW50ZXIuZ2V0WCgpKSAtCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WSgpIC0gY2VudGVyLmdldFkoKSkpIC8gMik7CgkgICAgICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH0KCSAgICAgICAgZmluYWxseSB7CgkgICAgICAgICAgICB0cnkgewoJICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH0KCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gMDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgd2UgaGF2ZSBmb3VuZCBhdCBsZWFzdCAzIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZAoJICAgICAqICAgICAgICAgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcyBlYWNoLCBhbmQsIHRoZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgb2YgdGhlCgkgICAgICogICAgICAgICBjYW5kaWRhdGVzIGlzICJwcmV0dHkgc2ltaWxhciIKCSAgICAgKi8KCSAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYjsKCSAgICAgICAgdmFyIGNvbmZpcm1lZENvdW50ID0gMDsKCSAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDsKCSAgICAgICAgdmFyIG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDsKCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfZC52YWx1ZTsKCSAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkgewoJICAgICAgICAgICAgICAgICAgICBjb25maXJtZWRDb3VudCsrOwoJICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9CgkgICAgICAgIGZpbmFsbHkgewoJICAgICAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGNvbmZpcm1lZENvdW50IDwgMykgewoJICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwoJICAgICAgICB9CgkgICAgICAgIC8vIE9LLCB3ZSBoYXZlIGF0IGxlYXN0IDMgY29uZmlybWVkIGNlbnRlcnMsIGJ1dCwgaXQncyBwb3NzaWJsZSB0aGF0IG9uZSBpcyBhICJmYWxzZSBwb3NpdGl2ZSIKCSAgICAgICAgLy8gYW5kIHRoYXQgd2UgbmVlZCB0byBrZWVwIGxvb2tpbmcuIFdlIGRldGVjdCB0aGlzIGJ5IGFza2luZyBpZiB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplcwoJICAgICAgICAvLyB2YXJ5IHRvbyBtdWNoLiBXZSBhcmJpdHJhcmlseSBzYXkgdGhhdCB3aGVuIHRoZSB0b3RhbCBkZXZpYXRpb24gZnJvbSBhdmVyYWdlIGV4Y2VlZHMKCSAgICAgICAgLy8gNSUgb2YgdGhlIHRvdGFsIG1vZHVsZSBzaXplIGVzdGltYXRlcywgaXQncyB0b28gbXVjaC4KCSAgICAgICAgdmFyIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBtYXg7CgkgICAgICAgIHZhciB0b3RhbERldmlhdGlvbiA9IDAuMDsKCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7CgkgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfZi52YWx1ZTsKCSAgICAgICAgICAgICAgICB0b3RhbERldmlhdGlvbiArPSBNYXRoLmFicyhwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpOwoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9CgkgICAgICAgIGZpbmFsbHkgewoJICAgICAgICAgICAgdHJ5IHsKCSAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRvdGFsRGV2aWF0aW9uIDw9IDAuMDUgKiB0b3RhbE1vZHVsZVNpemU7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBAcmV0dXJuIHRoZSAzIGJlc3Qge0BsaW5rIEZpbmRlclBhdHRlcm59cyBmcm9tIG91ciBsaXN0IG9mIGNhbmRpZGF0ZXMuIFRoZSAiYmVzdCIgYXJlCgkgICAgICogICAgICAgICB0aG9zZSB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZCBhdCBsZWFzdCB7QGxpbmsgI0NFTlRFUl9RVU9SVU19IHRpbWVzLCBhbmQgd2hvc2UgbW9kdWxlCgkgICAgICogICAgICAgICBzaXplIGRpZmZlcnMgZnJvbSB0aGUgYXZlcmFnZSBhbW9uZyB0aG9zZSBwYXR0ZXJucyB0aGUgbGVhc3QKCSAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIDMgc3VjaCBmaW5kZXIgcGF0dGVybnMgZG8gbm90IGV4aXN0CgkgICAgICovCgkgICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuc2VsZWN0QmVzdFBhdHRlcm5zID0gZnVuY3Rpb24gKCkgewoJICAgICAgICB2YXIgZV80LCBfYSwgZV81LCBfYjsKCSAgICAgICAgdmFyIHN0YXJ0U2l6ZSA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDsKCSAgICAgICAgaWYgKHN0YXJ0U2l6ZSA8IDMpIHsKCSAgICAgICAgICAgIC8vIENvdWxkbid0IGZpbmQgZW5vdWdoIGZpbmRlciBwYXR0ZXJucwoJICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEkMi5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzOwoJICAgICAgICB2YXIgYXZlcmFnZTsKCSAgICAgICAgLy8gRmlsdGVyIG91dGxpZXIgcG9zc2liaWxpdGllcyB3aG9zZSBtb2R1bGUgc2l6ZSBpcyB0b28gZGlmZmVyZW50CgkgICAgICAgIGlmIChzdGFydFNpemUgPiAzKSB7CgkgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIG9ubHkgYWZmb3JkIHRvIGRvIHNvIGlmIHdlIGhhdmUgYXQgbGVhc3QgNCBwb3NzaWJpbGl0aWVzIHRvIGNob29zZSBmcm9tCgkgICAgICAgICAgICB2YXIgdG90YWxNb2R1bGVTaXplID0gMC4wOwoJICAgICAgICAgICAgdmFyIHNxdWFyZSA9IDAuMDsKCSAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlQ2VudGVycyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHsKCSAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IF9kLnZhbHVlOwoJICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGNlbnRlci5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7CgkgICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBzaXplOwoJICAgICAgICAgICAgICAgICAgICBzcXVhcmUgKz0gc2l6ZSAqIHNpemU7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH0KCSAgICAgICAgICAgIGZpbmFsbHkgewoJICAgICAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfQoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIHN0YXJ0U2l6ZTsKCSAgICAgICAgICAgIHZhciBzdGREZXYgPSBNYXRoLnNxcnQoc3F1YXJlIC8gc3RhcnRTaXplIC0gYXZlcmFnZSAqIGF2ZXJhZ2UpOwoJICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoCgkgICAgICAgICAgICAvKioKCSAgICAgICAgICAgICAqIDxwPk9yZGVycyBieSBmdXJ0aGVzdCBmcm9tIGF2ZXJhZ2U8L3A+CgkgICAgICAgICAgICAgKi8KCSAgICAgICAgICAgIC8vIEZ1cnRoZXN0RnJvbUF2ZXJhZ2VDb21wYXJhdG9yIGltcGxlbWVudHMgQ29tcGFyYXRvcjxGaW5kZXJQYXR0ZXJuPgoJICAgICAgICAgICAgZnVuY3Rpb24gKGNlbnRlcjEsIGNlbnRlcjIpIHsKCSAgICAgICAgICAgICAgICB2YXIgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpOwoJICAgICAgICAgICAgICAgIHZhciBkQiA9IE1hdGguYWJzKGNlbnRlcjEuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7CgkgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAtMSA6IGRBID4gZEIgPyAxIDogMDsKCSAgICAgICAgICAgIH0pOwoJICAgICAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5tYXgoMC4yICogYXZlcmFnZSwgc3RkRGV2KTsKCSAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVDZW50ZXJzLmxlbmd0aCAmJiBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoID4gMzsgaSsrKSB7CgkgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBwb3NzaWJsZUNlbnRlcnNbaV07CgkgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSkgPiBsaW1pdCkgewoJICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKGksIDEpOwoJICAgICAgICAgICAgICAgICAgICBpLS07CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGlmIChwb3NzaWJsZUNlbnRlcnMubGVuZ3RoID4gMykgewoJICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBhbGwgYnV0IHRob3NlIGZpcnN0IHNpemUgY2FuZGlkYXRlIHBvaW50cyB3ZSBmb3VuZC4KCSAgICAgICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwLjA7CgkgICAgICAgICAgICB0cnkgewoJICAgICAgICAgICAgICAgIGZvciAodmFyIHBvc3NpYmxlQ2VudGVyc18xID0gX192YWx1ZXMocG9zc2libGVDZW50ZXJzKSwgcG9zc2libGVDZW50ZXJzXzFfMSA9IHBvc3NpYmxlQ2VudGVyc18xLm5leHQoKTsgIXBvc3NpYmxlQ2VudGVyc18xXzEuZG9uZTsgcG9zc2libGVDZW50ZXJzXzFfMSA9IHBvc3NpYmxlQ2VudGVyc18xLm5leHQoKSkgewoJICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVDZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNfMV8xLnZhbHVlOwoJICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcG9zc2libGVDZW50ZXIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9CgkgICAgICAgICAgICBmaW5hbGx5IHsKCSAgICAgICAgICAgICAgICB0cnkgewoJICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVDZW50ZXJzXzFfMSAmJiAhcG9zc2libGVDZW50ZXJzXzFfMS5kb25lICYmIChfYiA9IHBvc3NpYmxlQ2VudGVyc18xLnJldHVybikpIF9iLmNhbGwocG9zc2libGVDZW50ZXJzXzEpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gcG9zc2libGVDZW50ZXJzLmxlbmd0aDsKCSAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zb3J0KAoJICAgICAgICAgICAgLyoqCgkgICAgICAgICAgICAgKiA8cD5PcmRlcnMgYnkge0BsaW5rIEZpbmRlclBhdHRlcm4jZ2V0Q291bnQoKX0sIGRlc2NlbmRpbmcuPC9wPgoJICAgICAgICAgICAgICovCgkgICAgICAgICAgICAvLyBDZW50ZXJDb21wYXJhdG9yIGltcGxlbWVudHMgQ29tcGFyYXRvcjxGaW5kZXJQYXR0ZXJuPgoJICAgICAgICAgICAgZnVuY3Rpb24gKGNlbnRlcjEsIGNlbnRlcjIpIHsKCSAgICAgICAgICAgICAgICBpZiAoY2VudGVyMi5nZXRDb3VudCgpID09PSBjZW50ZXIxLmdldENvdW50KCkpIHsKCSAgICAgICAgICAgICAgICAgICAgdmFyIGRBID0gTWF0aC5hYnMoY2VudGVyMi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTsKCSAgICAgICAgICAgICAgICAgICAgdmFyIGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTsKCSAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAxIDogZEEgPiBkQiA/IC0xIDogMDsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIyLmdldENvdW50KCkgLSBjZW50ZXIxLmdldENvdW50KCk7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfSk7CgkgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKDMpOyAvLyB0aGlzIGlzIG5vdCByZWFseSBuZWNlc3NhcnkgYXMgd2Ugb25seSByZXR1cm4gZmlyc3QgMyBhbnl3YXkKCSAgICAgICAgfQoJICAgICAgICByZXR1cm4gWwoJICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzBdLAoJICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzFdLAoJICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzJdCgkgICAgICAgIF07CgkgICAgfTsKCSAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0gPSAyOwoJICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVAgPSAzOyAvLyAxIHBpeGVsL21vZHVsZSB0aW1lcyAzIG1vZHVsZXMvY2VudGVyCgkgICAgRmluZGVyUGF0dGVybkZpbmRlci5NQVhfTU9EVUxFUyA9IDU3OyAvLyBzdXBwb3J0IHVwIHRvIHZlcnNpb24gMTAgZm9yIG1vYmlsZSBjbGllbnRzCgkgICAgcmV0dXJuIEZpbmRlclBhdHRlcm5GaW5kZXI7Cgl9KCkpOwoJRmluZGVyUGF0dGVybkZpbmRlciQxLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuRmluZGVyOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV0ZWN0b3IkMSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwoJdmFyIE1hdGhVdGlsc18xID0gTWF0aFV0aWxzJDE7Cgl2YXIgRGV0ZWN0b3JSZXN1bHRfMSA9IERldGVjdG9yUmVzdWx0JDE7CgkvLyBpbXBvcnQgR3JpZFNhbXBsZXIgZnJvbSAnLi4vLi4vY29tbW9uL0dyaWRTYW1wbGVyJzsKCXZhciBHcmlkU2FtcGxlckluc3RhbmNlXzEgPSBHcmlkU2FtcGxlckluc3RhbmNlJDE7Cgl2YXIgUGVyc3BlY3RpdmVUcmFuc2Zvcm1fMSA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtJDE7Cgl2YXIgRGVjb2RlSGludFR5cGVfMSQxID0gRGVjb2RlSGludFR5cGUkMTsKCXZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xJDEgPSBOb3RGb3VuZEV4Y2VwdGlvbiQxOwoJdmFyIFJlc3VsdFBvaW50XzEgPSBSZXN1bHRQb2ludCQxOwoJdmFyIFZlcnNpb25fMSA9IFZlcnNpb24kMTsKCXZhciBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyXzEgPSBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyJDE7Cgl2YXIgRmluZGVyUGF0dGVybkZpbmRlcl8xID0gRmluZGVyUGF0dGVybkZpbmRlciQxOwoJLyppbXBvcnQgamF2YS51dGlsLk1hcDsqLwoJLyoqCgkgKiA8cD5FbmNhcHN1bGF0ZXMgbG9naWMgdGhhdCBjYW4gZGV0ZWN0IGEgUVIgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgUVIgQ29kZQoJICogaXMgcm90YXRlZCBvciBza2V3ZWQsIG9yIHBhcnRpYWxseSBvYnNjdXJlZC48L3A+CgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIERldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkgewoJICAgIGZ1bmN0aW9uIERldGVjdG9yKGltYWdlKSB7CgkgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTsKCSAgICB9CgkgICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTsKCSAgICB9OwoJICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRSZXN1bHRQb2ludENhbGxiYWNrID0gZnVuY3Rpb24gKCkgewoJICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogPHA+RGV0ZWN0cyBhIFFSIENvZGUgaW4gYW4gaW1hZ2UuPC9wPgoJICAgICAqCgkgICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBRUiBDb2RlCgkgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBRUiBDb2RlIGNhbm5vdCBiZSBmb3VuZAoJICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZAoJICAgICAqLwoJICAgIC8vIHB1YmxpYyBkZXRlY3QoKTogRGV0ZWN0b3JSZXN1bHQgLyp0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiovIHsKCSAgICAvLyAgIHJldHVybiBkZXRlY3QobnVsbCkKCSAgICAvLyB9CgkgICAgLyoqCgkgICAgICogPHA+RGV0ZWN0cyBhIFFSIENvZGUgaW4gYW4gaW1hZ2UuPC9wPgoJICAgICAqCgkgICAgICogQHBhcmFtIGhpbnRzIG9wdGlvbmFsIGhpbnRzIHRvIGRldGVjdG9yCgkgICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBRUiBDb2RlCgkgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBRUiBDb2RlIGNhbm5vdCBiZSBmb3VuZAoJICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZAoJICAgICAqLwoJICAgIERldGVjdG9yLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbiAoaGludHMpIHsKCSAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gKGhpbnRzID09PSBudWxsIHx8IGhpbnRzID09PSB1bmRlZmluZWQpID8gbnVsbCA6CgkgICAgICAgICAgICAvKihSZXN1bHRQb2ludENhbGxiYWNrKSAqLyBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMSQxLmRlZmF1bHQuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spOwoJICAgICAgICB2YXIgZmluZGVyID0gbmV3IEZpbmRlclBhdHRlcm5GaW5kZXJfMS5kZWZhdWx0KHRoaXMuaW1hZ2UsIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayk7CgkgICAgICAgIHZhciBpbmZvID0gZmluZGVyLmZpbmQoaGludHMpOwoJICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRmluZGVyUGF0dGVybkluZm8oaW5mbyk7CgkgICAgfTsKCSAgICBEZXRlY3Rvci5wcm90b3R5cGUucHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvID0gZnVuY3Rpb24gKGluZm8pIHsKCSAgICAgICAgdmFyIHRvcExlZnQgPSBpbmZvLmdldFRvcExlZnQoKTsKCSAgICAgICAgdmFyIHRvcFJpZ2h0ID0gaW5mby5nZXRUb3BSaWdodCgpOwoJICAgICAgICB2YXIgYm90dG9tTGVmdCA9IGluZm8uZ2V0Qm90dG9tTGVmdCgpOwoJICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZSh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCk7CgkgICAgICAgIGlmIChtb2R1bGVTaXplIDwgMS4wKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMSQxLmRlZmF1bHQoJ05vIHBhdHRlcm4gZm91bmQgaW4gcHJvY2Nlc3MgZmluZGVyLicpOwoJICAgICAgICB9CgkgICAgICAgIHZhciBkaW1lbnNpb24gPSBEZXRlY3Rvci5jb21wdXRlRGltZW5zaW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBtb2R1bGVTaXplKTsKCSAgICAgICAgdmFyIHByb3Zpc2lvbmFsVmVyc2lvbiA9IFZlcnNpb25fMS5kZWZhdWx0LmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbihkaW1lbnNpb24pOwoJICAgICAgICB2YXIgbW9kdWxlc0JldHdlZW5GUENlbnRlcnMgPSBwcm92aXNpb25hbFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpIC0gNzsKCSAgICAgICAgdmFyIGFsaWdubWVudFBhdHRlcm4gPSBudWxsOwoJICAgICAgICAvLyBBbnl0aGluZyBhYm92ZSB2ZXJzaW9uIDEgaGFzIGFuIGFsaWdubWVudCBwYXR0ZXJuCgkgICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24uZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMoKS5sZW5ndGggPiAwKSB7CgkgICAgICAgICAgICAvLyBHdWVzcyB3aGVyZSBhICJib3R0b20gcmlnaHQiIGZpbmRlciBwYXR0ZXJuIHdvdWxkIGhhdmUgYmVlbgoJICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0WCA9IHRvcFJpZ2h0LmdldFgoKSAtIHRvcExlZnQuZ2V0WCgpICsgYm90dG9tTGVmdC5nZXRYKCk7CgkgICAgICAgICAgICB2YXIgYm90dG9tUmlnaHRZID0gdG9wUmlnaHQuZ2V0WSgpIC0gdG9wTGVmdC5nZXRZKCkgKyBib3R0b21MZWZ0LmdldFkoKTsKCSAgICAgICAgICAgIC8vIEVzdGltYXRlIHRoYXQgYWxpZ25tZW50IHBhdHRlcm4gaXMgY2xvc2VyIGJ5IDMgbW9kdWxlcwoJICAgICAgICAgICAgLy8gZnJvbSAiYm90dG9tIHJpZ2h0IiB0byBrbm93biB0b3AgbGVmdCBsb2NhdGlvbgoJICAgICAgICAgICAgdmFyIGNvcnJlY3Rpb25Ub1RvcExlZnQgPSAxLjAgLSAzLjAgLyBtb2R1bGVzQmV0d2VlbkZQQ2VudGVyczsKCSAgICAgICAgICAgIHZhciBlc3RBbGlnbm1lbnRYID0gLyooaW50KSAqLyBNYXRoLmZsb29yKHRvcExlZnQuZ2V0WCgpICsgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFggLSB0b3BMZWZ0LmdldFgoKSkpOwoJICAgICAgICAgICAgdmFyIGVzdEFsaWdubWVudFkgPSAvKihpbnQpICovIE1hdGguZmxvb3IodG9wTGVmdC5nZXRZKCkgKyBjb3JyZWN0aW9uVG9Ub3BMZWZ0ICogKGJvdHRvbVJpZ2h0WSAtIHRvcExlZnQuZ2V0WSgpKSk7CgkgICAgICAgICAgICAvLyBLaW5kIG9mIGFyYml0cmFyeSAtLSBleHBhbmQgc2VhcmNoIHJhZGl1cyBiZWZvcmUgZ2l2aW5nIHVwCgkgICAgICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8PSAxNjsgaSA8PD0gMSkgewoJICAgICAgICAgICAgICAgIHRyeSB7CgkgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudFBhdHRlcm4gPSB0aGlzLmZpbmRBbGlnbm1lbnRJblJlZ2lvbihtb2R1bGVTaXplLCBlc3RBbGlnbm1lbnRYLCBlc3RBbGlnbm1lbnRZLCBpKTsKCSAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIGNhdGNoIChyZSAvKk5vdEZvdW5kRXhjZXB0aW9uKi8pIHsKCSAgICAgICAgICAgICAgICAgICAgaWYgKCEocmUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbl8xJDEuZGVmYXVsdCkpIHsKCSAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlOwoJICAgICAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBuZXh0IHJvdW5kCgkgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYWxpZ25tZW50IHBhdHRlcm4uLi4gd2VsbCB0cnkgYW55d2F5IHdpdGhvdXQgaXQKCSAgICAgICAgfQoJICAgICAgICB2YXIgdHJhbnNmb3JtID0gRGV0ZWN0b3IuY3JlYXRlVHJhbnNmb3JtKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBhbGlnbm1lbnRQYXR0ZXJuLCBkaW1lbnNpb24pOwoJICAgICAgICB2YXIgYml0cyA9IERldGVjdG9yLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24pOwoJICAgICAgICB2YXIgcG9pbnRzOwoJICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiA9PT0gbnVsbCkgewoJICAgICAgICAgICAgcG9pbnRzID0gW2JvdHRvbUxlZnQsIHRvcExlZnQsIHRvcFJpZ2h0XTsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIHsKCSAgICAgICAgICAgIHBvaW50cyA9IFtib3R0b21MZWZ0LCB0b3BMZWZ0LCB0b3BSaWdodCwgYWxpZ25tZW50UGF0dGVybl07CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3RvclJlc3VsdF8xLmRlZmF1bHQoYml0cywgcG9pbnRzKTsKCSAgICB9OwoJICAgIERldGVjdG9yLmNyZWF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYWxpZ25tZW50UGF0dGVybiwgZGltZW5zaW9uIC8qaW50Ki8pIHsKCSAgICAgICAgdmFyIGRpbU1pbnVzVGhyZWUgPSBkaW1lbnNpb24gLSAzLjU7CgkgICAgICAgIHZhciBib3R0b21SaWdodFg7IC8qZmxvYXQqLwoJICAgICAgICB2YXIgYm90dG9tUmlnaHRZOyAvKmZsb2F0Ki8KCSAgICAgICAgdmFyIHNvdXJjZUJvdHRvbVJpZ2h0WDsgLypmbG9hdCovCgkgICAgICAgIHZhciBzb3VyY2VCb3R0b21SaWdodFk7IC8qZmxvYXQqLwoJICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiAhPT0gbnVsbCkgewoJICAgICAgICAgICAgYm90dG9tUmlnaHRYID0gYWxpZ25tZW50UGF0dGVybi5nZXRYKCk7CgkgICAgICAgICAgICBib3R0b21SaWdodFkgPSBhbGlnbm1lbnRQYXR0ZXJuLmdldFkoKTsKCSAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IGRpbU1pbnVzVGhyZWUgLSAzLjA7CgkgICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFkgPSBzb3VyY2VCb3R0b21SaWdodFg7CgkgICAgICAgIH0KCSAgICAgICAgZWxzZSB7CgkgICAgICAgICAgICAvLyBEb24ndCBoYXZlIGFuIGFsaWdubWVudCBwYXR0ZXJuLCBqdXN0IG1ha2UgdXAgdGhlIGJvdHRvbS1yaWdodCBwb2ludAoJICAgICAgICAgICAgYm90dG9tUmlnaHRYID0gKHRvcFJpZ2h0LmdldFgoKSAtIHRvcExlZnQuZ2V0WCgpKSArIGJvdHRvbUxlZnQuZ2V0WCgpOwoJICAgICAgICAgICAgYm90dG9tUmlnaHRZID0gKHRvcFJpZ2h0LmdldFkoKSAtIHRvcExlZnQuZ2V0WSgpKSArIGJvdHRvbUxlZnQuZ2V0WSgpOwoJICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRYID0gZGltTWludXNUaHJlZTsKCSAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WSA9IGRpbU1pbnVzVGhyZWU7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIFBlcnNwZWN0aXZlVHJhbnNmb3JtXzEuZGVmYXVsdC5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsKDMuNSwgMy41LCBkaW1NaW51c1RocmVlLCAzLjUsIHNvdXJjZUJvdHRvbVJpZ2h0WCwgc291cmNlQm90dG9tUmlnaHRZLCAzLjUsIGRpbU1pbnVzVGhyZWUsIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0WCwgYm90dG9tUmlnaHRZLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpOwoJICAgIH07CgkgICAgRGV0ZWN0b3Iuc2FtcGxlR3JpZCA9IGZ1bmN0aW9uIChpbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24gLyppbnQqLykgewoJICAgICAgICB2YXIgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2VfMS5kZWZhdWx0LmdldEluc3RhbmNlKCk7CgkgICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtKGltYWdlLCBkaW1lbnNpb24sIGRpbWVuc2lvbiwgdHJhbnNmb3JtKTsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPkNvbXB1dGVzIHRoZSBkaW1lbnNpb24gKG51bWJlciBvZiBtb2R1bGVzIG9uIGEgc2l6ZSkgb2YgdGhlIFFSIENvZGUgYmFzZWQgb24gdGhlIHBvc2l0aW9uCgkgICAgICogb2YgdGhlIGZpbmRlciBwYXR0ZXJucyBhbmQgZXN0aW1hdGVkIG1vZHVsZSBzaXplLjwvcD4KCSAgICAgKi8KCSAgICBEZXRlY3Rvci5jb21wdXRlRGltZW5zaW9uID0gZnVuY3Rpb24gKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBtb2R1bGVTaXplIC8qZmxvYXQqLykgewoJICAgICAgICB2YXIgdGx0ckNlbnRlcnNEaW1lbnNpb24gPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKFJlc3VsdFBvaW50XzEuZGVmYXVsdC5kaXN0YW5jZSh0b3BMZWZ0LCB0b3BSaWdodCkgLyBtb2R1bGVTaXplKTsKCSAgICAgICAgdmFyIHRsYmxDZW50ZXJzRGltZW5zaW9uID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChSZXN1bHRQb2ludF8xLmRlZmF1bHQuZGlzdGFuY2UodG9wTGVmdCwgYm90dG9tTGVmdCkgLyBtb2R1bGVTaXplKTsKCSAgICAgICAgdmFyIGRpbWVuc2lvbiA9IE1hdGguZmxvb3IoKHRsdHJDZW50ZXJzRGltZW5zaW9uICsgdGxibENlbnRlcnNEaW1lbnNpb24pIC8gMikgKyA3OwoJICAgICAgICBzd2l0Y2ggKGRpbWVuc2lvbiAmIDB4MDMpIHsgLy8gbW9kIDQKCSAgICAgICAgICAgIGNhc2UgMDoKCSAgICAgICAgICAgICAgICBkaW1lbnNpb24rKzsKCSAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgIC8vIDE/IGRvIG5vdGhpbmcKCSAgICAgICAgICAgIGNhc2UgMjoKCSAgICAgICAgICAgICAgICBkaW1lbnNpb24tLTsKCSAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgIGNhc2UgMzoKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMSQxLmRlZmF1bHQoJ0RpbWVuc2lvbnMgY291bGQgYmUgbm90IGZvdW5kLicpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiBkaW1lbnNpb247CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiA8cD5Db21wdXRlcyBhbiBhdmVyYWdlIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBiYXNlZCBvbiBlc3RpbWF0ZWQgZGVyaXZlZCBmcm9tIHRoZSBwb3NpdGlvbnMKCSAgICAgKiBvZiB0aGUgdGhyZWUgZmluZGVyIHBhdHRlcm5zLjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSB0b3BMZWZ0IGRldGVjdGVkIHRvcC1sZWZ0IGZpbmRlciBwYXR0ZXJuIGNlbnRlcgoJICAgICAqIEBwYXJhbSB0b3BSaWdodCBkZXRlY3RlZCB0b3AtcmlnaHQgZmluZGVyIHBhdHRlcm4gY2VudGVyCgkgICAgICogQHBhcmFtIGJvdHRvbUxlZnQgZGV0ZWN0ZWQgYm90dG9tLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyCgkgICAgICogQHJldHVybiBlc3RpbWF0ZWQgbW9kdWxlIHNpemUKCSAgICAgKi8KCSAgICBEZXRlY3Rvci5wcm90b3R5cGUuY2FsY3VsYXRlTW9kdWxlU2l6ZSA9IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCkgewoJICAgICAgICAvLyBUYWtlIHRoZSBhdmVyYWdlCgkgICAgICAgIHJldHVybiAodGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5KHRvcExlZnQsIHRvcFJpZ2h0KSArCgkgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgYm90dG9tTGVmdCkpIC8gMi4wOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogPHA+RXN0aW1hdGVzIG1vZHVsZSBzaXplIGJhc2VkIG9uIHR3byBmaW5kZXIgcGF0dGVybnMgLS0gaXQgdXNlcwoJICAgICAqIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoaW50LCBpbnQsIGludCwgaW50KX0gdG8gZmlndXJlIHRoZQoJICAgICAqIHdpZHRoIG9mIGVhY2gsIG1lYXN1cmluZyBhbG9uZyB0aGUgYXhpcyBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuPC9wPgoJICAgICAqLwoJICAgIERldGVjdG9yLnByb3RvdHlwZS5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5ID0gZnVuY3Rpb24gKHBhdHRlcm4sIG90aGVyUGF0dGVybikgewoJICAgICAgICB2YXIgbW9kdWxlU2l6ZUVzdDEgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFgoKSksIAoJICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRZKCkpLCAKCSAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRYKCkpLCAKCSAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRZKCkpKTsKCSAgICAgICAgdmFyIG1vZHVsZVNpemVFc3QyID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFgoKSksIAoJICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFkoKSksIAoJICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCAKCSAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WSgpKSk7CgkgICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MSkpIHsKCSAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRXN0MiAvIDcuMDsKCSAgICAgICAgfQoJICAgICAgICBpZiAoaXNOYU4obW9kdWxlU2l6ZUVzdDIpKSB7CgkgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDEgLyA3LjA7CgkgICAgICAgIH0KCSAgICAgICAgLy8gQXZlcmFnZSB0aGVtLCBhbmQgZGl2aWRlIGJ5IDcgc2luY2Ugd2UndmUgY291bnRlZCB0aGUgd2lkdGggb2YgMyBibGFjayBtb2R1bGVzLAoJICAgICAgICAvLyBhbmQgMSB3aGl0ZSBhbmQgMSBibGFjayBtb2R1bGUgb24gZWl0aGVyIHNpZGUuIEVyZ28sIGRpdmlkZSBzdW0gYnkgMTQuCgkgICAgICAgIHJldHVybiAobW9kdWxlU2l6ZUVzdDEgKyBtb2R1bGVTaXplRXN0MikgLyAxNC4wOwoJICAgIH07CgkgICAgLyoqCgkgICAgICogU2VlIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGludCwgaW50LCBpbnQsIGludCl9OyBjb21wdXRlcyB0aGUgdG90YWwgd2lkdGggb2YKCSAgICAgKiBhIGZpbmRlciBwYXR0ZXJuIGJ5IGxvb2tpbmcgZm9yIGEgYmxhY2std2hpdGUtYmxhY2sgcnVuIGZyb20gdGhlIGNlbnRlciBpbiB0aGUgZGlyZWN0aW9uCgkgICAgICogb2YgYW5vdGhlciBwb2ludCAoYW5vdGhlciBmaW5kZXIgcGF0dGVybiBjZW50ZXIpLCBhbmQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0b28uCgkgICAgICovCgkgICAgRGV0ZWN0b3IucHJvdG90eXBlLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzID0gZnVuY3Rpb24gKGZyb21YIC8qaW50Ki8sIGZyb21ZIC8qaW50Ki8sIHRvWCAvKmludCovLCB0b1kgLyppbnQqLykgewoJICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7CgkgICAgICAgIC8vIE5vdyBjb3VudCBvdGhlciB3YXkgLS0gZG9uJ3QgcnVuIG9mZiBpbWFnZSB0aG91Z2ggb2YgY291cnNlCgkgICAgICAgIHZhciBzY2FsZSA9IDEuMDsKCSAgICAgICAgdmFyIG90aGVyVG9YID0gZnJvbVggLSAodG9YIC0gZnJvbVgpOwoJICAgICAgICBpZiAob3RoZXJUb1ggPCAwKSB7CgkgICAgICAgICAgICBzY2FsZSA9IGZyb21YIC8gLyooZmxvYXQpICovIChmcm9tWCAtIG90aGVyVG9YKTsKCSAgICAgICAgICAgIG90aGVyVG9YID0gMDsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIGlmIChvdGhlclRvWCA+PSB0aGlzLmltYWdlLmdldFdpZHRoKCkpIHsKCSAgICAgICAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDEgLSBmcm9tWCkgLyAvKihmbG9hdCkgKi8gKG90aGVyVG9YIC0gZnJvbVgpOwoJICAgICAgICAgICAgb3RoZXJUb1ggPSB0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxOwoJICAgICAgICB9CgkgICAgICAgIHZhciBvdGhlclRvWSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihmcm9tWSAtICh0b1kgLSBmcm9tWSkgKiBzY2FsZSk7CgkgICAgICAgIHNjYWxlID0gMS4wOwoJICAgICAgICBpZiAob3RoZXJUb1kgPCAwKSB7CgkgICAgICAgICAgICBzY2FsZSA9IGZyb21ZIC8gLyooZmxvYXQpICovIChmcm9tWSAtIG90aGVyVG9ZKTsKCSAgICAgICAgICAgIG90aGVyVG9ZID0gMDsKCSAgICAgICAgfQoJICAgICAgICBlbHNlIGlmIChvdGhlclRvWSA+PSB0aGlzLmltYWdlLmdldEhlaWdodCgpKSB7CgkgICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMSAtIGZyb21ZKSAvIC8qKGZsb2F0KSAqLyAob3RoZXJUb1kgLSBmcm9tWSk7CgkgICAgICAgICAgICBvdGhlclRvWSA9IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxOwoJICAgICAgICB9CgkgICAgICAgIG90aGVyVG9YID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGZyb21YICsgKG90aGVyVG9YIC0gZnJvbVgpICogc2NhbGUpOwoJICAgICAgICByZXN1bHQgKz0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCBvdGhlclRvWCwgb3RoZXJUb1kpOwoJICAgICAgICAvLyBNaWRkbGUgcGl4ZWwgaXMgZG91YmxlLWNvdW50ZWQgdGhpcyB3YXk7IHN1YnRyYWN0IDEKCSAgICAgICAgcmV0dXJuIHJlc3VsdCAtIDEuMDsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPlRoaXMgbWV0aG9kIHRyYWNlcyBhIGxpbmUgZnJvbSBhIHBvaW50IGluIHRoZSBpbWFnZSwgaW4gdGhlIGRpcmVjdGlvbiB0b3dhcmRzIGFub3RoZXIgcG9pbnQuCgkgICAgICogSXQgYmVnaW5zIGluIGEgYmxhY2sgcmVnaW9uLCBhbmQga2VlcHMgZ29pbmcgdW50aWwgaXQgZmluZHMgd2hpdGUsIHRoZW4gYmxhY2ssIHRoZW4gd2hpdGUgYWdhaW4uCgkgICAgICogSXQgcmVwb3J0cyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgdG8gdGhpcyBwb2ludC48L3A+CgkgICAgICoKCSAgICAgKiA8cD5UaGlzIGlzIHVzZWQgd2hlbiBmaWd1cmluZyBvdXQgaG93IHdpZGUgYSBmaW5kZXIgcGF0dGVybiBpcywgd2hlbiB0aGUgZmluZGVyIHBhdHRlcm4KCSAgICAgKiBtYXkgYmUgc2tld2VkIG9yIHJvdGF0ZWQuPC9wPgoJICAgICAqLwoJICAgIERldGVjdG9yLnByb3RvdHlwZS5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4gPSBmdW5jdGlvbiAoZnJvbVggLyppbnQqLywgZnJvbVkgLyppbnQqLywgdG9YIC8qaW50Ki8sIHRvWSAvKmludCovKSB7CgkgICAgICAgIC8vIE1pbGQgdmFyaWFudCBvZiBCcmVzZW5oYW0ncyBhbGdvcml0aG0KCSAgICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlc2VuaGFtJ3NfbGluZV9hbGdvcml0aG0KCSAgICAgICAgdmFyIHN0ZWVwID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpID4gTWF0aC5hYnModG9YIC0gZnJvbVgpOwoJICAgICAgICBpZiAoc3RlZXApIHsKCSAgICAgICAgICAgIHZhciB0ZW1wID0gZnJvbVg7CgkgICAgICAgICAgICBmcm9tWCA9IGZyb21ZOwoJICAgICAgICAgICAgZnJvbVkgPSB0ZW1wOwoJICAgICAgICAgICAgdGVtcCA9IHRvWDsKCSAgICAgICAgICAgIHRvWCA9IHRvWTsKCSAgICAgICAgICAgIHRvWSA9IHRlbXA7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnModG9YIC0gZnJvbVgpOwoJICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSk7CgkgICAgICAgIHZhciBlcnJvciA9IC1keCAvIDI7CgkgICAgICAgIHZhciB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xOwoJICAgICAgICB2YXIgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTsKCSAgICAgICAgLy8gSW4gYmxhY2sgcGl4ZWxzLCBsb29raW5nIGZvciB3aGl0ZSwgZmlyc3Qgb3Igc2Vjb25kIHRpbWUuCgkgICAgICAgIHZhciBzdGF0ZSA9IDA7CgkgICAgICAgIC8vIExvb3AgdXAgdW50aWwgeCA9PSB0b1gsIGJ1dCBub3QgYmV5b25kCgkgICAgICAgIHZhciB4TGltaXQgPSB0b1ggKyB4c3RlcDsKCSAgICAgICAgZm9yICh2YXIgeCA9IGZyb21YLCB5ID0gZnJvbVk7IHggIT09IHhMaW1pdDsgeCArPSB4c3RlcCkgewoJICAgICAgICAgICAgdmFyIHJlYWxYID0gc3RlZXAgPyB5IDogeDsKCSAgICAgICAgICAgIHZhciByZWFsWSA9IHN0ZWVwID8geCA6IHk7CgkgICAgICAgICAgICAvLyBEb2VzIGN1cnJlbnQgcGl4ZWwgbWVhbiB3ZSBoYXZlIG1vdmVkIHdoaXRlIHRvIGJsYWNrIG9yIHZpY2UgdmVyc2E/CgkgICAgICAgICAgICAvLyBTY2FubmluZyBibGFjayBpbiBzdGF0ZSAwLDIgYW5kIHdoaXRlIGluIHN0YXRlIDEsIHNvIGlmIHdlIGZpbmQgdGhlIHdyb25nCgkgICAgICAgICAgICAvLyBjb2xvciwgYWR2YW5jZSB0byBuZXh0IHN0YXRlIG9yIGVuZCBpZiB3ZSBhcmUgaW4gc3RhdGUgMiBhbHJlYWR5CgkgICAgICAgICAgICBpZiAoKHN0YXRlID09PSAxKSA9PT0gdGhpcy5pbWFnZS5nZXQocmVhbFgsIHJlYWxZKSkgewoJICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikgewoJICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzXzEuZGVmYXVsdC5kaXN0YW5jZSh4LCB5LCBmcm9tWCwgZnJvbVkpOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBzdGF0ZSsrOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgZXJyb3IgKz0gZHk7CgkgICAgICAgICAgICBpZiAoZXJyb3IgPiAwKSB7CgkgICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkgewoJICAgICAgICAgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICAgICAgeSArPSB5c3RlcDsKCSAgICAgICAgICAgICAgICBlcnJvciAtPSBkeDsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICAvLyBGb3VuZCBibGFjay13aGl0ZS1ibGFjazsgZ2l2ZSB0aGUgYmVuZWZpdCBvZiB0aGUgZG91YnQgdGhhdCB0aGUgbmV4dCBwaXhlbCBvdXRzaWRlIHRoZSBpbWFnZQoJICAgICAgICAvLyBpcyAid2hpdGUiIHNvIHRoaXMgbGFzdCBwb2ludCBhdCAodG9YK3hTdGVwLHRvWSkgaXMgdGhlIHJpZ2h0IGVuZGluZy4gVGhpcyBpcyByZWFsbHkgYQoJICAgICAgICAvLyBzbWFsbCBhcHByb3hpbWF0aW9uOyAodG9YK3hTdGVwLHRvWSt5U3RlcCkgbWlnaHQgYmUgcmVhbGx5IGNvcnJlY3QuIElnbm9yZSB0aGlzLgoJICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHsKCSAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHNfMS5kZWZhdWx0LmRpc3RhbmNlKHRvWCArIHhzdGVwLCB0b1ksIGZyb21YLCBmcm9tWSk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gZWxzZSB3ZSBkaWRuJ3QgZmluZCBldmVuIGJsYWNrLXdoaXRlLWJsYWNrOyBubyBlc3RpbWF0ZSBpcyByZWFsbHkgcG9zc2libGUKCSAgICAgICAgcmV0dXJuIE5hTjsKCSAgICB9OwoJICAgIC8qKgoJICAgICAqIDxwPkF0dGVtcHRzIHRvIGxvY2F0ZSBhbiBhbGlnbm1lbnQgcGF0dGVybiBpbiBhIGxpbWl0ZWQgcmVnaW9uIG9mIHRoZSBpbWFnZSwgd2hpY2ggaXMKCSAgICAgKiBndWVzc2VkIHRvIGNvbnRhaW4gaXQuIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIEFsaWdubWVudFBhdHRlcm59LjwvcD4KCSAgICAgKgoJICAgICAqIEBwYXJhbSBvdmVyYWxsRXN0TW9kdWxlU2l6ZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgc28gZmFyCgkgICAgICogQHBhcmFtIGVzdEFsaWdubWVudFggeCBjb29yZGluYXRlIG9mIGNlbnRlciBvZiBhcmVhIHByb2JhYmx5IGNvbnRhaW5pbmcgYWxpZ25tZW50IHBhdHRlcm4KCSAgICAgKiBAcGFyYW0gZXN0QWxpZ25tZW50WSB5IGNvb3JkaW5hdGUgb2YgYWJvdmUKCSAgICAgKiBAcGFyYW0gYWxsb3dhbmNlRmFjdG9yIG51bWJlciBvZiBwaXhlbHMgaW4gYWxsIGRpcmVjdGlvbnMgdG8gc2VhcmNoIGZyb20gdGhlIGNlbnRlcgoJICAgICAqIEByZXR1cm4ge0BsaW5rIEFsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kLCBvciBudWxsIG90aGVyd2lzZQoJICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnMgZHVyaW5nIGRldGVjdGlvbgoJICAgICAqLwoJICAgIERldGVjdG9yLnByb3RvdHlwZS5maW5kQWxpZ25tZW50SW5SZWdpb24gPSBmdW5jdGlvbiAob3ZlcmFsbEVzdE1vZHVsZVNpemUgLypmbG9hdCovLCBlc3RBbGlnbm1lbnRYIC8qaW50Ki8sIGVzdEFsaWdubWVudFkgLyppbnQqLywgYWxsb3dhbmNlRmFjdG9yIC8qZmxvYXQqLykgewoJICAgICAgICAvLyBMb29rIGZvciBhbiBhbGlnbm1lbnQgcGF0dGVybiAoMyBtb2R1bGVzIGluIHNpemUpIGFyb3VuZCB3aGVyZSBpdAoJICAgICAgICAvLyBzaG91bGQgYmUKCSAgICAgICAgdmFyIGFsbG93YW5jZSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihhbGxvd2FuY2VGYWN0b3IgKiBvdmVyYWxsRXN0TW9kdWxlU2l6ZSk7CgkgICAgICAgIHZhciBhbGlnbm1lbnRBcmVhTGVmdFggPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRYIC0gYWxsb3dhbmNlKTsKCSAgICAgICAgdmFyIGFsaWdubWVudEFyZWFSaWdodFggPSBNYXRoLm1pbih0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxLCBlc3RBbGlnbm1lbnRYICsgYWxsb3dhbmNlKTsKCSAgICAgICAgaWYgKGFsaWdubWVudEFyZWFSaWdodFggLSBhbGlnbm1lbnRBcmVhTGVmdFggPCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSAqIDMpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xJDEuZGVmYXVsdCgnQWxpZ25tZW50IHRvcCBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTsKCSAgICAgICAgfQoJICAgICAgICB2YXIgYWxpZ25tZW50QXJlYVRvcFkgPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRZIC0gYWxsb3dhbmNlKTsKCSAgICAgICAgdmFyIGFsaWdubWVudEFyZWFCb3R0b21ZID0gTWF0aC5taW4odGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDEsIGVzdEFsaWdubWVudFkgKyBhbGxvd2FuY2UpOwoJICAgICAgICBpZiAoYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykgewoJICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEkMS5kZWZhdWx0KCdBbGlnbm1lbnQgYm90dG9tIGV4Y2VlZHMgZXN0aW1hdGVkIG1vZHVsZSBzaXplLicpOwoJICAgICAgICB9CgkgICAgICAgIHZhciBhbGlnbm1lbnRGaW5kZXIgPSBuZXcgQWxpZ25tZW50UGF0dGVybkZpbmRlcl8xLmRlZmF1bHQodGhpcy5pbWFnZSwgYWxpZ25tZW50QXJlYUxlZnRYLCBhbGlnbm1lbnRBcmVhVG9wWSwgYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCwgYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSwgb3ZlcmFsbEVzdE1vZHVsZVNpemUsIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayk7CgkgICAgICAgIHJldHVybiBhbGlnbm1lbnRGaW5kZXIuZmluZCgpOwoJICAgIH07CgkgICAgcmV0dXJuIERldGVjdG9yOwoJfSgpKTsKCURldGVjdG9yJDEuZGVmYXVsdCA9IERldGVjdG9yOwoKCS8qCgkgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzCgkgKgoJICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7CgkgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCgkgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKCSAqCgkgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoJICoKCSAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKCSAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCgkgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KCSAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKCSAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgoJICovCglPYmplY3QuZGVmaW5lUHJvcGVydHkoUVJDb2RlUmVhZGVyJDEsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKCS8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlIHsqLwoJdmFyIEJhcmNvZGVGb3JtYXRfMSA9IEJhcmNvZGVGb3JtYXQkMTsKCXZhciBCaXRNYXRyaXhfMSA9IEJpdE1hdHJpeCQxOwoJdmFyIERlY29kZUhpbnRUeXBlXzEgPSBEZWNvZGVIaW50VHlwZSQxOwoJdmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSBOb3RGb3VuZEV4Y2VwdGlvbiQxOwoJdmFyIFJlc3VsdF8xID0gUmVzdWx0JDE7Cgl2YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSBSZXN1bHRNZXRhZGF0YVR5cGUkMTsKCS8vIGltcG9ydCBEZXRlY3RvclJlc3VsdCBmcm9tICcuLi9jb21tb24vRGV0ZWN0b3JSZXN1bHQnOwoJdmFyIERlY29kZXJfMSA9IERlY29kZXIkMTsKCXZhciBRUkNvZGVEZWNvZGVyTWV0YURhdGFfMSA9IFFSQ29kZURlY29kZXJNZXRhRGF0YSQxOwoJdmFyIERldGVjdG9yXzEgPSBEZXRlY3RvciQxOwoJLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki8KCS8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki8KCS8qKgoJICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgUVIgQ29kZXMgaW4gYW4gaW1hZ2UuCgkgKgoJICogQGF1dGhvciBTZWFuIE93ZW4KCSAqLwoJdmFyIFFSQ29kZVJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHsKCSAgICBmdW5jdGlvbiBRUkNvZGVSZWFkZXIoKSB7CgkgICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyXzEuZGVmYXVsdCgpOwoJICAgIH0KCSAgICBRUkNvZGVSZWFkZXIucHJvdG90eXBlLmdldERlY29kZXIgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAgIHJldHVybiB0aGlzLmRlY29kZXI7CgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgUVIgY29kZSBpbiBhbiBpbWFnZS4KCSAgICAgKgoJICAgICAqIEByZXR1cm4gYSByZXByZXNlbnRpbmc6IHN0cmluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBRUiBjb2RlCgkgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIFFSIGNvZGUgY2Fubm90IGJlIGZvdW5kCgkgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBRUiBjb2RlIGNhbm5vdCBiZSBkZWNvZGVkCgkgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzCgkgICAgICovCgkgICAgLypAT3ZlcnJpZGUqLwoJICAgIC8vIHB1YmxpYyBkZWNvZGUoaW1hZ2U6IEJpbmFyeUJpdG1hcCk6IFJlc3VsdCAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiAqLyB7CgkgICAgLy8gICByZXR1cm4gdGhpcy5kZWNvZGUoaW1hZ2UsIG51bGwpCgkgICAgLy8gfQoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBRUkNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMpIHsKCSAgICAgICAgdmFyIGRlY29kZXJSZXN1bHQ7CgkgICAgICAgIHZhciBwb2ludHM7CgkgICAgICAgIGlmIChoaW50cyAhPT0gdW5kZWZpbmVkICYmIGhpbnRzICE9PSBudWxsICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QVVJFX0JBUkNPREUpKSB7CgkgICAgICAgICAgICB2YXIgYml0cyA9IFFSQ29kZVJlYWRlci5leHRyYWN0UHVyZUJpdHMoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7CgkgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZUJpdE1hdHJpeChiaXRzLCBoaW50cyk7CgkgICAgICAgICAgICBwb2ludHMgPSBRUkNvZGVSZWFkZXIuTk9fUE9JTlRTOwoJICAgICAgICB9CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgICAgdmFyIGRldGVjdG9yUmVzdWx0ID0gbmV3IERldGVjdG9yXzEuZGVmYXVsdChpbWFnZS5nZXRCbGFja01hdHJpeCgpKS5kZXRlY3QoaGludHMpOwoJICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGVCaXRNYXRyaXgoZGV0ZWN0b3JSZXN1bHQuZ2V0Qml0cygpLCBoaW50cyk7CgkgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTsKCSAgICAgICAgfQoJICAgICAgICAvLyBJZiB0aGUgY29kZSB3YXMgbWlycm9yZWQ6IHN3YXAgdGhlIGJvdHRvbS1sZWZ0IGFuZCB0aGUgdG9wLXJpZ2h0IHBvaW50cy4KCSAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKSBpbnN0YW5jZW9mIFFSQ29kZURlY29kZXJNZXRhRGF0YV8xLmRlZmF1bHQpIHsKCSAgICAgICAgICAgIGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKS5hcHBseU1pcnJvcmVkQ29ycmVjdGlvbihwb2ludHMpOwoJICAgICAgICB9CgkgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUmVzdWx0XzEuZGVmYXVsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUVJfQ09ERSwgdW5kZWZpbmVkKTsKCSAgICAgICAgdmFyIGJ5dGVTZWdtZW50cyA9IGRlY29kZXJSZXN1bHQuZ2V0Qnl0ZVNlZ21lbnRzKCk7CgkgICAgICAgIGlmIChieXRlU2VnbWVudHMgIT09IG51bGwpIHsKCSAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTsKCSAgICAgICAgaWYgKGVjTGV2ZWwgIT09IG51bGwpIHsKCSAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwsIGVjTGV2ZWwpOwoJICAgICAgICB9CgkgICAgICAgIGlmIChkZWNvZGVyUmVzdWx0Lmhhc1N0cnVjdHVyZWRBcHBlbmQoKSkgewoJICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0UsIGRlY29kZXJSZXN1bHQuZ2V0U3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyKCkpOwoJICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZLCBkZWNvZGVyUmVzdWx0LmdldFN0cnVjdHVyZWRBcHBlbmRQYXJpdHkoKSk7CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHJlc3VsdDsKCSAgICB9OwoJICAgIC8qQE92ZXJyaWRlKi8KCSAgICBRUkNvZGVSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgewoJICAgICAgICAvLyBkbyBub3RoaW5nCgkgICAgfTsKCSAgICAvKioKCSAgICAgKiBUaGlzIG1ldGhvZCBkZXRlY3RzIGEgY29kZSBpbiBhICJwdXJlIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2UKCSAgICAgKiB3aGljaCBjb250YWlucyBvbmx5IGFuIHVucm90YXRlZCwgdW5za2V3ZWQsIGltYWdlIG9mIGEgY29kZSwgd2l0aCBzb21lIHdoaXRlIGJvcmRlcgoJICAgICAqIGFyb3VuZCBpdC4gVGhpcyBpcyBhIHNwZWNpYWxpemVkIG1ldGhvZCB0aGF0IHdvcmtzIGV4Y2VwdGlvbmFsbHkgZmFzdCBpbiB0aGlzIHNwZWNpYWwKCSAgICAgKiBjYXNlLgoJICAgICAqCgkgICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmRhdGFtYXRyaXguRGF0YU1hdHJpeFJlYWRlciNleHRyYWN0UHVyZUJpdHMoQml0TWF0cml4KQoJICAgICAqLwoJICAgIFFSQ29kZVJlYWRlci5leHRyYWN0UHVyZUJpdHMgPSBmdW5jdGlvbiAoaW1hZ2UpIHsKCSAgICAgICAgdmFyIGxlZnRUb3BCbGFjayA9IGltYWdlLmdldFRvcExlZnRPbkJpdCgpOwoJICAgICAgICB2YXIgcmlnaHRCb3R0b21CbGFjayA9IGltYWdlLmdldEJvdHRvbVJpZ2h0T25CaXQoKTsKCSAgICAgICAgaWYgKGxlZnRUb3BCbGFjayA9PT0gbnVsbCB8fCByaWdodEJvdHRvbUJsYWNrID09PSBudWxsKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgdmFyIG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSk7CgkgICAgICAgIHZhciB0b3AgPSBsZWZ0VG9wQmxhY2tbMV07CgkgICAgICAgIHZhciBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdOwoJICAgICAgICB2YXIgbGVmdCA9IGxlZnRUb3BCbGFja1swXTsKCSAgICAgICAgdmFyIHJpZ2h0ID0gcmlnaHRCb3R0b21CbGFja1swXTsKCSAgICAgICAgLy8gU2FuaXR5IGNoZWNrIQoJICAgICAgICBpZiAobGVmdCA+PSByaWdodCB8fCB0b3AgPj0gYm90dG9tKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKGJvdHRvbSAtIHRvcCAhPT0gcmlnaHQgLSBsZWZ0KSB7CgkgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UsIHdoZXJlIGJvdHRvbS1yaWdodCBtb2R1bGUgd2Fzbid0IGJsYWNrIHNvIHdlIGZvdW5kIHNvbWV0aGluZyBlbHNlIGluIHRoZSBsYXN0IHJvdwoJICAgICAgICAgICAgLy8gQXNzdW1lIGl0J3MgYSBzcXVhcmUsIHNvIHVzZSBoZWlnaHQgYXMgdGhlIHdpZHRoCgkgICAgICAgICAgICByaWdodCA9IGxlZnQgKyAoYm90dG9tIC0gdG9wKTsKCSAgICAgICAgICAgIGlmIChyaWdodCA+PSBpbWFnZS5nZXRXaWR0aCgpKSB7CgkgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhhdCB3b3VsZCBub3QgbWFrZSBzZW5zZSAtLSBvZmYgaW1hZ2UKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgdmFyIG1hdHJpeFdpZHRoID0gTWF0aC5yb3VuZCgocmlnaHQgLSBsZWZ0ICsgMSkgLyBtb2R1bGVTaXplKTsKCSAgICAgICAgdmFyIG1hdHJpeEhlaWdodCA9IE1hdGgucm91bmQoKGJvdHRvbSAtIHRvcCArIDEpIC8gbW9kdWxlU2l6ZSk7CgkgICAgICAgIGlmIChtYXRyaXhXaWR0aCA8PSAwIHx8IG1hdHJpeEhlaWdodCA8PSAwKSB7CgkgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKG1hdHJpeEhlaWdodCAhPT0gbWF0cml4V2lkdGgpIHsKCSAgICAgICAgICAgIC8vIE9ubHkgcG9zc2libHkgZGVjb2RlIHNxdWFyZSByZWdpb25zCgkgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgIH0KCSAgICAgICAgLy8gUHVzaCBpbiB0aGUgImJvcmRlciIgYnkgaGFsZiB0aGUgbW9kdWxlIHdpZHRoIHNvIHRoYXQgd2Ugc3RhcnQKCSAgICAgICAgLy8gc2FtcGxpbmcgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbW9kdWxlLiBKdXN0IGluIGNhc2UgdGhlIGltYWdlIGlzIGEKCSAgICAgICAgLy8gbGl0dGxlIG9mZiwgdGhpcyB3aWxsIGhlbHAgcmVjb3Zlci4KCSAgICAgICAgdmFyIG51ZGdlID0gLyooaW50KSAqLyBNYXRoLmZsb29yKG1vZHVsZVNpemUgLyAyLjApOwoJICAgICAgICB0b3AgKz0gbnVkZ2U7CgkgICAgICAgIGxlZnQgKz0gbnVkZ2U7CgkgICAgICAgIC8vIEJ1dCBjYXJlZnVsIHRoYXQgdGhpcyBkb2VzIG5vdCBzYW1wbGUgb2ZmIHRoZSBlZGdlCgkgICAgICAgIC8vICJyaWdodCIgaXMgdGhlIGZhcnRoZXN0LXJpZ2h0IHZhbGlkIHBpeGVsIGxvY2F0aW9uIC0tIHJpZ2h0KzEgaXMgbm90IG5lY2Vzc2FyaWx5CgkgICAgICAgIC8vIFRoaXMgaXMgcG9zaXRpdmUgYnkgaG93IG11Y2ggdGhlIGlubmVyIHggbG9vcCBiZWxvdyB3b3VsZCBiZSB0b28gbGFyZ2UKCSAgICAgICAgdmFyIG51ZGdlZFRvb0ZhclJpZ2h0ID0gbGVmdCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4V2lkdGggLSAxKSAqIG1vZHVsZVNpemUpIC0gcmlnaHQ7CgkgICAgICAgIGlmIChudWRnZWRUb29GYXJSaWdodCA+IDApIHsKCSAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJSaWdodCA+IG51ZGdlKSB7CgkgICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnQKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBsZWZ0IC09IG51ZGdlZFRvb0ZhclJpZ2h0OwoJICAgICAgICB9CgkgICAgICAgIC8vIFNlZSBsb2dpYyBhYm92ZQoJICAgICAgICB2YXIgbnVkZ2VkVG9vRmFyRG93biA9IHRvcCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4SGVpZ2h0IC0gMSkgKiBtb2R1bGVTaXplKSAtIGJvdHRvbTsKCSAgICAgICAgaWYgKG51ZGdlZFRvb0ZhckRvd24gPiAwKSB7CgkgICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyRG93biA+IG51ZGdlKSB7CgkgICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnQKCSAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB0b3AgLT0gbnVkZ2VkVG9vRmFyRG93bjsKCSAgICAgICAgfQoJICAgICAgICAvLyBOb3cganVzdCByZWFkIG9mZiB0aGUgYml0cwoJICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpOwoJICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG1hdHJpeEhlaWdodDsgeSsrKSB7CgkgICAgICAgICAgICB2YXIgaU9mZnNldCA9IHRvcCArIC8qKGludCkgKi8gTWF0aC5mbG9vcih5ICogbW9kdWxlU2l6ZSk7CgkgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1hdHJpeFdpZHRoOyB4KyspIHsKCSAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGxlZnQgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeCAqIG1vZHVsZVNpemUpLCBpT2Zmc2V0KSkgewoJICAgICAgICAgICAgICAgICAgICBiaXRzLnNldCh4LCB5KTsKCSAgICAgICAgICAgICAgICB9CgkgICAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIGJpdHM7CgkgICAgfTsKCSAgICBRUkNvZGVSZWFkZXIubW9kdWxlU2l6ZSA9IGZ1bmN0aW9uIChsZWZ0VG9wQmxhY2ssIGltYWdlKSB7CgkgICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTsKCSAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTsKCSAgICAgICAgdmFyIHggPSBsZWZ0VG9wQmxhY2tbMF07CgkgICAgICAgIHZhciB5ID0gbGVmdFRvcEJsYWNrWzFdOwoJICAgICAgICB2YXIgaW5CbGFjayA9IHRydWU7CgkgICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IDA7CgkgICAgICAgIHdoaWxlICh4IDwgd2lkdGggJiYgeSA8IGhlaWdodCkgewoJICAgICAgICAgICAgaWYgKGluQmxhY2sgIT09IGltYWdlLmdldCh4LCB5KSkgewoJICAgICAgICAgICAgICAgIGlmICgrK3RyYW5zaXRpb25zID09PSA1KSB7CgkgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgICAgICBpbkJsYWNrID0gIWluQmxhY2s7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICB4Kys7CgkgICAgICAgICAgICB5Kys7CgkgICAgICAgIH0KCSAgICAgICAgaWYgKHggPT09IHdpZHRoIHx8IHkgPT09IGhlaWdodCkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpOwoJICAgICAgICB9CgkgICAgICAgIHJldHVybiAoeCAtIGxlZnRUb3BCbGFja1swXSkgLyA3LjA7CgkgICAgfTsKCSAgICBRUkNvZGVSZWFkZXIuTk9fUE9JTlRTID0gbmV3IEFycmF5KCk7CgkgICAgcmV0dXJuIFFSQ29kZVJlYWRlcjsKCX0oKSk7Cgl2YXIgX2RlZmF1bHQgPSBRUkNvZGVSZWFkZXIkMS5kZWZhdWx0ID0gUVJDb2RlUmVhZGVyOwoKCXZhciB0b0dyYXlzY2FsZUJ1ZmZlciA9IGZ1bmN0aW9uIHRvR3JheXNjYWxlQnVmZmVyKGltYWdlQnVmZmVyLCB3aWR0aCwgaGVpZ2h0KSB7CgkgIHZhciBncmF5c2NhbGVCdWZmZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpOwoKCSAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCBsZW5ndGhfMSA9IGltYWdlQnVmZmVyLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpICs9IDQsIGorKykgewoJICAgIHZhciBncmF5ID0gdm9pZCAwOwoJICAgIHZhciBhbHBoYSA9IGltYWdlQnVmZmVyW2kgKyAzXTsgLy8gVGhlIGNvbG9yIG9mIGZ1bGx5LXRyYW5zcGFyZW50IHBpeGVscyBpcyBpcnJlbGV2YW50LiBUaGV5IGFyZSBvZnRlbiwgdGVjaG5pY2FsbHksIGZ1bGx5LXRyYW5zcGFyZW50CgkgICAgLy8gYmxhY2sgKDAgYWxwaGEsIGFuZCB0aGVuIDAgUkdCKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCwgb2YgY291cnNlIGFzIHRoZSAid2hpdGUiIGFyZWEgaW4gYQoJICAgIC8vIGJhcmNvZGUgaW1hZ2UuIEZvcmNlIGFueSBzdWNoIHBpeGVsIHRvIGJlIHdoaXRlOgoKCSAgICBpZiAoYWxwaGEgPT09IDApIHsKCSAgICAgIGdyYXkgPSAweEZGOwoJICAgIH0gZWxzZSB7CgkgICAgICB2YXIgcGl4ZWxSID0gaW1hZ2VCdWZmZXJbaV07CgkgICAgICB2YXIgcGl4ZWxHID0gaW1hZ2VCdWZmZXJbaSArIDFdOwoJICAgICAgdmFyIHBpeGVsQiA9IGltYWdlQnVmZmVyW2kgKyAyXTsgLy8gLjI5OVIgKyAwLjU4N0cgKyAwLjExNEIgKFlVVi9ZSVEgZm9yIFBBTCBhbmQgTlRTQyksCgkgICAgICAvLyAoMzA2KlIpID4+IDEwIGlzIGFwcHJveGltYXRlbHkgZXF1YWwgdG8gUiowLjI5OSwgYW5kIHNvIG9uLgoJICAgICAgLy8gMHgyMDAgPj4gMTAgaXMgMC41LCBpdCBpbXBsZW1lbnRzIHJvdW5kaW5nLgoKCSAgICAgIGdyYXkgPSAzMDYgKiBwaXhlbFIgKyA2MDEgKiBwaXhlbEcgKyAxMTcgKiBwaXhlbEIgKyAweDIwMCA+PiAxMDsKCSAgICB9CgoJICAgIGdyYXlzY2FsZUJ1ZmZlcltqXSA9IGdyYXk7CgkgIH0KCgkgIHJldHVybiBncmF5c2NhbGVCdWZmZXI7Cgl9OwoKCXZhciByZWFkZXIgPSBuZXcgX2RlZmF1bHQoKTsKCXNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7CgkgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzCgkgIHRyeSB7CgkgICAgdmFyIGx1bWluYW5jZXMgPSB0b0dyYXlzY2FsZUJ1ZmZlcihlLmRhdGEuZGF0YSwgZS5kYXRhLndpZHRoLCBlLmRhdGEuaGVpZ2h0KTsKCSAgICB2YXIgbHVtaW5hbmNlU291cmNlID0gbmV3IF9kZWZhdWx0JDEobHVtaW5hbmNlcywgZS5kYXRhLndpZHRoLCBlLmRhdGEuaGVpZ2h0KTsKCSAgICB2YXIgaHlicmlkQmluYXJpemVyID0gbmV3IF9kZWZhdWx0JDIobHVtaW5hbmNlU291cmNlKTsKCSAgICB2YXIgYmluYXJ5Qml0bWFwID0gbmV3IF9kZWZhdWx0JDMoaHlicmlkQmluYXJpemVyKTsKCSAgICB2YXIgZGVjb2RlZCA9IHJlYWRlci5kZWNvZGUoYmluYXJ5Qml0bWFwKTsKCSAgICBwb3N0TWVzc2FnZShkZWNvZGVkKTsKCSAgfSBjYXRjaCAoZXJyKSB7CgkgICAgcG9zdE1lc3NhZ2UobnVsbCk7CgkgIH0KCX0pOwoKfSkoKTsKCg=="
    ),
    mk = ["constraints", "onError", "onLoad", "onScan", "resolution", "qrArea"];
  function Rs(g, I) {
    var e = Object.keys(g);
    if (Object.getOwnPropertySymbols) {
      var C = Object.getOwnPropertySymbols(g);
      I &&
        (C = C.filter(function (l) {
          return Object.getOwnPropertyDescriptor(g, l).enumerable;
        })),
        e.push.apply(e, C);
    }
    return e;
  }
  function Xs(g) {
    for (var I = 1; I < arguments.length; I++) {
      var e = arguments[I] != null ? arguments[I] : {};
      I % 2
        ? Rs(Object(e), !0).forEach(function (C) {
            L2(g, C, e[C]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(g, Object.getOwnPropertyDescriptors(e))
        : Rs(Object(e)).forEach(function (C) {
            Object.defineProperty(g, C, Object.getOwnPropertyDescriptor(e, C));
          });
    }
    return g;
  }
  var Zk = function () {
      return new uk();
    },
    Js = function (I) {
      I &&
        (I.getVideoTracks && I.getAudioTracks
          ? (I.getVideoTracks().forEach(function (e) {
              I.removeTrack(e), e.stop();
            }),
            I.getAudioTracks().forEach(function (e) {
              I.removeTrack(e), e.stop();
            }))
          : I.stop());
    },
    va = function (I) {
      var e = I.constraints,
        C = I.onError,
        l = I.onLoad,
        t = I.onScan,
        n = I.resolution,
        o = I.qrArea,
        A = q2(I, mk),
        c = a.useRef(null),
        d = a.useRef(null),
        i = a.useRef(document.createElement("canvas")),
        r = a.useRef(null),
        u = a.useRef(),
        b = a.useState(null),
        m = O2(b, 2),
        p = m[0],
        G = m[1],
        Z = a.useRef(!1),
        B = a.useRef();
      a.useEffect(
        function () {
          B.current = Zk();
          var S = B.current;
          return (
            (S.onmessage = function (V) {
              t &&
                t(
                  V.data ? Xs(Xs({}, V.data), {}, { canvas: i.current }) : null
                ),
                (Z.current = !1);
            }),
            function () {
              S.terminate();
            }
          );
        },
        [t]
      );
      var y = JSON.stringify(o),
        h = a.useCallback(
          function () {
            var S = JSON.parse(y),
              V = B.current,
              f =
                d.current &&
                d.current.readyState === d.current.HAVE_ENOUGH_DATA;
            if (!Z.current && f) {
              Z.current = !0;
              var k = d.current.videoWidth,
                F = d.current.videoHeight,
                K = k > F ? k : F,
                P = Math.floor((n / K) * 100) / 100;
              (F = Math.floor(P * F)),
                (k = Math.floor(P * k)),
                (i.current.width = k),
                (i.current.height = F),
                (r.current = i.current.getContext("2d")),
                r.current.drawImage(d.current, 0, 0, k, F);
              var T;
              S && S.length === 2 && S[0] > 0 && S[1] > 0
                ? (T = r.current.getImageData(
                    Math.floor((k - S[0]) / 2),
                    Math.floor((F - S[1]) / 2),
                    S[0],
                    S[1]
                  ))
                : (T = r.current.getImageData(0, 0, k, F)),
                V.postMessage(T);
            }
            u.current = requestAnimationFrame(h);
          },
          [n, y]
        ),
        W = JSON.stringify(e);
      return (
        a.useEffect(
          function () {
            var S = JSON.parse(W),
              V = !0;
            return (
              navigator.mediaDevices
                .getUserMedia(S)
                .then(function (f) {
                  if (!V) Js(f);
                  else {
                    c.current = f;
                    try {
                      d.current &&
                        ((d.current.srcObject = f),
                        d.current.setAttribute("playsinline", !0));
                    } catch {
                      G(window.URL.createObjectURL(f));
                    }
                    l && l(), (u.current = requestAnimationFrame(h));
                  }
                })
                .catch(function (f) {
                  return V ? C(f) : null;
                }),
              function () {
                cancelAnimationFrame(u.current),
                  (V = !1),
                  Js(c.current),
                  p && window.URL.revokeObjectURL(p);
              }
            );
          },
          [h, W, C, l, p]
        ),
        a.createElement(
          "video",
          Ud({ autoPlay: !0, playsInline: !0, src: p, ref: d }, A)
        )
      );
    };
  va.propTypes = {
    constraints: HC.object,
    onError: HC.func.isRequired,
    onLoad: HC.func,
    onScan: HC.func.isRequired,
    resolution: HC.number,
    qrArea: HC.array,
  };
  va.defaultProps = {
    constraints: { audio: !1, video: !0 },
    resolution: 640,
    qrArea: [],
  };
  const Gk = () => {
      const g = eA(),
        [I, e] = a.useState(""),
        [C, l] = a.useState(null),
        [t, n] = a.useState(!1),
        o = (i) => {
          i && (e(i.text), n(!1), g(`/scan-qr/details?qrCode=${i.text}`));
        },
        A = (i) => {
          console.error(i), l(i.message), n(!1);
        },
        c = () => {
          e(""), l(null), n(!0);
        },
        d = () => {
          g("/menu");
        };
      return (
        !t && !I && !C && n(!0),
        s.jsxs("div", {
          className:
            "container mx-auto px-4 py-8 flex flex-col items-center max-w-md space-y-6",
          children: [
            s.jsxs("div", {
              className: "text-center mb-6",
              children: [
                s.jsx("h1", {
                  className: "text-3xl font-bold text-primary tracking-tight",
                  children: "Scan QR Code",
                }),
                s.jsx("p", {
                  className:
                    "mt-2 text-lg text-muted-foreground text-center max-w-xs mx-auto",
                  children: "Position the QR code within the camera frame",
                }),
              ],
            }),
            s.jsxs("div", {
              className:
                "w-full max-w-md min-h-[300px] bg-muted rounded-lg shadow-inner overflow-hidden",
              children: [
                t &&
                  s.jsx(va, {
                    delay: 300,
                    onError: A,
                    onScan: o,
                    style: { width: "100%" },
                  }),
                !t &&
                  !C &&
                  I &&
                  s.jsx("div", {
                    className: "flex items-center justify-center h-full",
                    children: s.jsx("p", {
                      className: "text-center text-green-600 font-semibold",
                      children: "Scan Successful!",
                    }),
                  }),
                !t &&
                  C &&
                  s.jsx("div", {
                    className: "flex items-center justify-center h-full",
                    children: s.jsxs("p", {
                      className: "text-center text-red-600 font-semibold",
                      children: ["Scan Failed: ", C],
                    }),
                  }),
              ],
            }),
            C &&
              s.jsxs(Sa, {
                variant: "destructive",
                className: "w-full max-w-md",
                children: [
                  s.jsx(GS, { className: "h-4 w-4" }),
                  s.jsx(Va, { children: "Scan Error" }),
                  s.jsx(Wa, {
                    children: C || "An unknown error occurred during scanning.",
                  }),
                ],
              }),
            s.jsxs("div", {
              className: "w-full max-w-md grid grid-cols-1 gap-4",
              children: [
                s.jsxs(fg, {
                  onClick: c,
                  variant: "outline",
                  size: "lg",
                  className: "w-full shadow-md",
                  disabled: t && !C,
                  children: [
                    s.jsx(ZS, { className: "mr-2 h-5 w-5" }),
                    "Retry Scan",
                  ],
                }),
                s.jsxs(fg, {
                  onClick: d,
                  variant: "ghost",
                  className: "w-full pt-4",
                  children: [
                    s.jsx(uS, { className: "mr-2 h-5 w-5" }),
                    "Back to Menu",
                  ],
                }),
              ],
            }),
          ],
        })
      );
    },
    bk = "AIzaSyBGhsCjGOhFcSgB9aVwQ0rfgMkkPlhJTJo",
    Bk = "1kVzhjXX45GLnqiLiqmeg81sy0FAtEd70EcMAo2_Ejlc",
    pk = "Form Responses",
    Yn = {
      TIMESTAMP: "Timestamp",
      EMAIL: "Email Address",
      NAME: "Name (Last Name, First Name, Middle Initial)",
      CROP: "Crop",
      VARIETY: "Variety",
      LOT_NUMBER: "Lot Number",
      BAG_NUMBER: "Bag Number",
      HARVEST_DATE: "Date of Harvest",
      STORED_DATE: "Date Stored",
      VOLUME: "Volume Stored",
      UNIT: "Unit",
      GERMINATION_RATE: "Germination Rate (%)",
      MOISTURE_CONTENT: "Moisture Content (%)",
      SEED_CLASS: "Seed Class",
      SEED_PHOTO: "Seed Photo",
      CROP_PHOTO: "Standing Crop Photo",
      PROGRAM: "Program",
      REMARKS: "Remarks",
      INVENTORY: "Inventory",
      LOCATION: "Location",
      ARCHIVED: "Archived",
      LAST_MODIFIED: "Last Modified",
      CODE: "Code",
      QR_IMAGE: "QR Image",
      QR_DOCUMENT: "QR Document",
      STATUS: "Status",
    },
      // In your yk function in js.html
      yk = async (g) => {
        try {
          console.log("Client: About to call fetchSeedDetailsByQrCode with:", g);
          // Call the server-side function using google.script.run
          return new Promise((resolve, reject) => {
            console.log("Client: Setting up google.script.run promise");
            google.script.run
              .withSuccessHandler(result => {
                console.log("Client: Received result from server:", result);
                resolve(result);
              })
              .withFailureHandler(error => {
                console.error("Client: Error from server:", error);
                reject(new Error(error.message || "Error fetching data from Google Sheets"));
              })
              .fetchSeedDetailsByQrCode(g);
            console.log("Client: Called fetchSeedDetailsByQrCode");
          });
        } catch (C) {
          console.error("Client: Caught error:", C);
          throw C;
        }
      },
    hk = () => {
      const [g] = Ah(),
        I = g.get("qrCode"),
        e = eA(),
        [C, l] = a.useState(null),
        [t, n] = a.useState(!0),
        [o, A] = a.useState(null);
      a.useEffect(() => {
        (async () => {
          if (!I) {
            A("QR code not provided in the URL."), n(!1);
            return;
          }
          n(!0), A(null), l(null);
          try {
            const i = await yk(I);
            i
              ? l(i)
              : A(
                  `No seed details found for QR code: '${I}'. Please scan again or check the data source.`
                );
          } catch (i) {
            console.error("Error fetching seed details:", i),
              A(
                i.message ||
                  "An unknown error occurred while fetching seed details."
              );
          } finally {
            n(!1);
          }
        })();
      }, [I]);
      const c = Object.entries(C || {}).filter(
        ([d, i]) => i != null && i !== "" && i !== "N/A"
      );
      return t
        ? s.jsxs("div", {
            className:
              "flex flex-col items-center justify-center min-h-[200px] p-8",
            children: [
              s.jsx(BZ, { className: "h-12 w-12 animate-spin text-primary" }),
              s.jsxs("p", {
                className: "mt-4 text-lg text-center",
                children: ["Loading seed details for '", I || "...", "'..."],
              }),
              s.jsx("p", {
                className: "mt-1 text-muted-foreground text-center",
                children: "Please wait a moment.",
              }),
            ],
          })
        : o
        ? s.jsxs("div", {
            className: "max-w-2xl mx-auto",
            children: [
              s.jsxs(Sa, {
                variant: "destructive",
                children: [
                  s.jsx(mS, { className: "h-4 w-4" }),
                  s.jsx(Va, { children: "Error Retrieving Details" }),
                  s.jsx(Wa, {
                    children:
                      o ||
                      "An unknown error occurred while fetching seed details.",
                  }),
                ],
              }),
              s.jsx("div", {
                className: "flex justify-center mt-4",
                children: s.jsxs(fg, {
                  variant: "outline",
                  onClick: () => e("/scan-qr"),
                  children: [
                    s.jsx(_r, { className: "mr-2 h-4 w-4" }),
                    " Back to Scan",
                  ],
                }),
              }),
            ],
          })
        : s.jsx(Fo, {
            className: "shadow-xl",
            children: s.jsxs("div", {
              className: "p-6",
              children: [
                s.jsxs("div", {
                  className: "flex items-start justify-between pb-2 border-b",
                  children: [
                    s.jsx("div", {
                      children: s.jsxs("h2", {
                        className: "text-2xl font-bold text-primary",
                        children: [
                          "Seed Details: ",
                          C == null ? void 0 : C.Crop,
                          " - ",
                          C == null ? void 0 : C.Variety,
                        ],
                      }),
                    }),
                    s.jsxs(fg, {
                      variant: "outline",
                      size: "icon",
                      onClick: () => e("/scan-qr"),
                      "aria-label": "Back to Scan QR",
                      className: "flex-shrink-0",
                      children: [
                        s.jsx(_r, { className: "h-4 w-4" }),
                        s.jsx("span", {
                          className: "sr-only",
                          children: "Back to Scan QR",
                        }),
                      ],
                    }),
                  ],
                }),
                s.jsxs("div", {
                  className:
                    "bg-muted/50 rounded-lg p-6 mt-6 flex flex-col sm:flex-row items-center sm:items-start gap-6",
                  children: [
                    s.jsx("div", {
                      className: "flex-shrink-0",
                      children: s.jsx("div", {
                        className:
                          "h-[150px] w-[150px] rounded-md border shadow-md bg-gray-200 flex items-center justify-center text-gray-500",
                        children: s.jsx("span", { children: "No Image" }),
                      }),
                    }),
                    s.jsxs("div", {
                      className: "flex-grow text-center sm:text-left",
                      children: [
                        s.jsx("p", {
                          className: "text-sm text-muted-foreground",
                          children: "Scanned QR Code (ID):",
                        }),
                        s.jsx("p", {
                          className: "text-2xl font-mono font-semibold",
                          children: I || "N/A",
                        }),
                      ],
                    }),
                  ],
                }),
                s.jsx("p", {
                  className: "mt-6 text-gray-700 text-center sm:text-left",
                  children:
                    "Detailed information for the scanned seed lot retrieved from the system.",
                }),
                s.jsxs("div", {
                  className: "overflow-x-auto mt-6",
                  children: [
                    s.jsxs("table", {
                      className: "w-full table-auto",
                      children: [
                        s.jsx("thead", {
                          children: s.jsxs("tr", {
                            children: [
                              s.jsx("th", {
                                className:
                                  "w-[200px] text-left text-sm font-medium text-gray-500 uppercase tracking-wider pb-2",
                                children: "Attribute",
                              }),
                              s.jsx("th", {
                                className:
                                  "text-left text-sm font-medium text-gray-500 uppercase tracking-wider pb-2",
                                children: "Value",
                              }),
                            ],
                          }),
                        }),
                        s.jsx("tbody", {
                          className: "divide-y divide-gray-200",
                          children: c.map(([d, i]) =>
                            s.jsxs(
                              "tr",
                              {
                                children: [
                                  s.jsx("td", {
                                    className:
                                      "py-2 pr-4 text-sm font-medium text-gray-900",
                                    children: d,
                                  }),
                                  s.jsx("td", {
                                    className: "py-2 text-sm text-gray-700",
                                    children: String(i),
                                  }),
                                ],
                              },
                              d
                            )
                          ),
                        }),
                      ],
                    }),
                    c.length === 0 &&
                      s.jsx("p", {
                        className: "text-center text-gray-500 mt-4",
                        children: "No detailed attributes found for this seed.",
                      }),
                  ],
                }),
                (C == null ? void 0 : C.CODE) &&
                  s.jsxs("div", {
                    className: "flex justify-end mt-6 flex-wrap gap-4",
                    children: [
                      " ",
                      s.jsx(fg, {
                        asChild: !0,
                        children: s.jsxs("a", {
                          href: `/seed-withdrawal/${C.CODE}`,
                          children: [" ", "Withdraw Seed"],
                        }),
                      }),
                    ],
                  }),
              ],
            }),
          });
    },
    Sk = () =>
      s.jsx("div", {
        className: "container mx-auto px-4 py-8 max-w-3xl",
        children: s.jsx(a.Suspense, {
          fallback: s.jsxs("div", {
            className:
              "flex flex-col items-center justify-center min-h-[200px] p-8",
            children: [
              s.jsx(BZ, { className: "h-12 w-12 animate-spin text-primary" }),
              s.jsx("p", {
                className: "mt-4 text-lg text-center",
                children: "Preparing QR details page...",
              }),
              s.jsx("p", {
                className: "mt-1 text-muted-foreground text-center",
                children: "Please wait a moment.",
              }),
            ],
          }),
          children: s.jsx(hk, {}),
        }),
      }),
    Vk = [
      { title: "Home", url: "/", component: w2 },
      { title: "Menu", url: "/menu", component: z2 },
      { title: "Tasks", url: "/Tasks", component: Y2 },
      { title: "Settings", url: "/settings", component: H2 },
      { title: "Contact", url: "/contact", component: dh },
      { title: "Profile", url: "/profile", component: ch },
      { title: "Scan QR", url: "/scan-qr", component: Gk },
      { title: "Scan QR Details", url: "/scan-qr/details", component: Sk },
    ];
  function Wk({ title: g, titleId: I, ...e }, C) {
    return a.createElement(
      "svg",
      Object.assign(
        {
          xmlns: "http://www.w3.org/2000/svg",
          fill: "none",
          viewBox: "0 0 24 24",
          strokeWidth: 1.5,
          stroke: "currentColor",
          "aria-hidden": "true",
          "data-slot": "icon",
          ref: C,
          "aria-labelledby": I,
        },
        e
      ),
      g ? a.createElement("title", { id: I }, g) : null,
      a.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5",
      })
    );
  }
  const Rk = a.forwardRef(Wk),
    Xk = ({ setIsMenuOpen: g }) => {
      RC();
      const I = () => {
        g((e) => !e);
      };
      return s.jsx("header", {
        className:
          "sticky top-0 z-40 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60",
        children: s.jsxs("div", {
          className:
            "container flex h-16 items-center justify-between px-4 sm:px-6 lg:px-8",
          children: [
            s.jsx("img", {
              src: "/logos/square.svg",
              alt: "SIS Logo",
              className: "h-8 w-auto",
            }),
            s.jsx("h1", {
              className:
                "text-xl font-semibold text-foreground hidden sm:block",
            }),
            s.jsx("button", {
              onClick: I,
              className: "text-gray-600 focus:outline-none",
              "aria-label": "Open menu",
              children: s.jsx(Rk, { className: "h-6 w-6" }),
            }),
          ],
        }),
      });
    },
    Jk = "SIS",
    vk = [
      { label: "Home", href: "/" },
      { label: "Menu", href: "/menu" },
      { label: "Monitor Inventory", href: "/monitor-inventory" },
      { label: "Scan QR", href: "/scan-qr" },
      { label: "Seed Withdrawal", href: "/seed-withdrawal" },
      { label: "Tasks", href: "/Tasks" },
    ];
  function kk({ isMenuOpen: g, setIsMenuOpen: I }) {
    const { pathname: e } = RC();
    return g
      ? s.jsxs("div", {
          className:
            "flex flex-col bg-background/95 backdrop-blur-sm supports-[backdrop-filter]:bg-background/80 animate-in fade-in-20",
          children: [
            s.jsxs("div", {
              className:
                "container flex h-16 items-center justify-between px-4 sm:px-6 lg:px-8 border-b",
              children: [
                s.jsxs("div", {
                  className: "flex items-center gap-3",
                  children: [
                    s.jsx("img", {
                      src: "/logos/square.svg",
                      alt: "SIS Logo",
                      className: "h-8 w-auto",
                    }),
                    s.jsxs("h2", {
                      className: "text-2xl font-bold text-primary",
                      children: [Jk, " Menu"],
                    }),
                  ],
                }),
                s.jsx(fg, {
                  variant: "ghost",
                  size: "icon",
                  onClick: () => I(!1),
                  "aria-label": "Close menu",
                  children: s.jsx(bS, { className: "h-6 w-6" }),
                }),
              ],
            }),
            s.jsx("nav", {
              className:
                "flex-1 flex flex-col items-center p-8 space-y-6 mt-16",
              children: s.jsx("ul", {
                className: "space-y-4 text-center w-full max-w-xs",
                children: vk.map((C) =>
                  s.jsx(
                    "li",
                    {
                      children: s.jsx(ho, {
                        to: C.href,
                        className: O(
                          "text-2xl font-medium text-foreground hover:text-primary transition-colors block py-3 rounded-md",
                          e === C.href ? "bg-muted text-primary" : ""
                        ),
                        onClick: () => I(!1),
                        children: C.label,
                      }),
                    },
                    C.href
                  )
                ),
              }),
            }),
          ],
        })
      : null;
  }
  function fk() {
    const [g, I] = a.useState(!1);
    return s.jsx(lh, {
      children: s.jsxs("div", {
        className: "app-container",
        children: [
          s.jsx(Xk, { setIsMenuOpen: I }),
          s.jsxs("div", {
            className: "content",
            children: [
              s.jsx(Oy, {
                children: Vk.map((e) =>
                  s.jsx(
                    eZ,
                    { path: e.url, element: s.jsx(e.component, {}) },
                    e.title
                  )
                ),
              }),
              g &&
                s.jsx("div", {
                  className: "fixed inset-0 z-50",
                  children: s.jsx(kk, { isMenuOpen: g, setIsMenuOpen: I }),
                }),
            ],
          }),
        ],
      }),
    });
  }
  Qm.createRoot(document.getElementById("root")).render(
    s.jsx(ee.StrictMode, { children: s.jsx(fk, {}) })
  );
</script>
